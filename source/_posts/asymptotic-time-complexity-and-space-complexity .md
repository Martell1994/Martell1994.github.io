---
title: 一次搞懂时间复杂度和空间复杂度
date: 2017-01-08 02:17:34
tag: 数据结构
categories: 算法
---

学习数据结构和算法时，难免提到时间复杂度（asymptotic time complexity）和空间复杂度（space complexity）的概念。

## 时间复杂度

概念：描述一个算法**执行时间**与数据规模的增长关系，记作：$T(n) = O(f(n))$。

计算时间复杂度时，需要遵循这一条原则：**如果一个算法的执行次数是 $T(n)$，那么只保留最高次项，同时忽略最高项的系数后得到函数 $f(n)$，此时时间复杂度就是 $O(f(n))$。**

比如：

$T(n)=n+5$，时间复杂度为 $O(n)$；

$T(n)=n^3+n^2+1$，时间复杂度为 $O(n^3)$；

$T(n)=4n^3$，时间复杂度为 $O(n^3)$。

下面举几个例子：

### 常数阶

我们知道常数项对函数的增长速度影响并不大，所以当 $T(n) = c$，$c$ 为一个常数时，我们说这个算法的时间复杂度为 $ O(1)$。 **哈希算法就是典型的 $O(1)$ 时间复杂度**，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）。

```c
int n = 100;
int sum = n * (n + 1) / 2;
printf("%i\n", sum);  
```

像上面这段代码，无论 $n$ 是多少，运行步骤都一样，所以时间复杂度是 $O(1)$。

### 线性阶

$O(n)$ 代表数据量增大 $n$ 倍，耗时也增大 $n$ 倍，比如常见的**遍历算法**。

对于一个循环，假设循环体的时间复杂度为  $O(m)$，循环次数为 $n$，那么循环的时间复杂度为 $O(m×n)$；

```c
for(int i = 0; i < n; i++) {        // 循环次数为 n
    printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
}
```

此时时间复杂度为  $O(1×n)$，即  $O(n)$。

### 平方阶

$Ο(n^2)$：代表数据量增大 $n$ 倍，时间复杂度就是 $n^2$ ，比如**冒泡排序**。

对于下面这个多循环，循环次数为 $n×n$，那么时间复杂度为 $O(n × n × 1)$，即 $O(n^2)$。

```c
for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
        printf("Hello, World!\n");
    }
}
```

### 对数阶

$O(log_2n)$：当数据增大 $n$ 倍时，耗时增大 $log_2n$ 倍。比如下面这段代码，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度。

```c
for (int i = 1; i <= n; i++) {
  i *= 2;
  printf("%i\n", i);
}
```

**二分查找**的时间复杂度就是 $O(log_2n)$。

### 对数阶乘以 $n$

$O(nlog_2n)$：当数据增大 $n$ 倍时，耗时增大 $nlog_2n$ 倍，比如。比如下面这段代码，当数据增大256倍时，耗时增大256*8=2048倍，这个复杂度高于线性阶低于平方阶。

```c
for(int i = 0; i < n; i++) {
  for (int i = 2; i < n; i++) {
    i *= 2;
    printf("%i\n", i);
  }
}
```

**归并排序**的时间复杂度就是 $O(nlog_2n)$。

### 指数阶

$O(2^n)$：当数据增大 $n$ 倍时，耗时增大 $2^n$ 倍，比如斐波那契数列：

```c
long aFunc(int n) {
  if (n <= 1) {
    return 1;
  } else {
    return aFunc(n - 1) + aFunc(n - 2);
  }
}
```

常见的算法时间复杂度由小到大依次为：

$Ο(1)＜Ο(log_2n)＜Ο(n)＜Ο(nlog_2n)＜Ο(n^2)＜Ο(2^n)$

## 空间复杂度

概念：描述一个算法**占用空间**与数据规模的增长关系，记作：$S(n) = O(f(n))$。

一个算法在计算机上占用的内存包括：程序代码所占用的空间、输入输出数据所占用的空间、辅助变量所占用的空间这三个方面。程序代码所占用的空间取决于算法本身的长短，输入输出数据所占用的空间取决于要解决的问题，是通过参数表调用函数传递而来，只有辅助变量是算法运行过程中临时占用的存储空间，与空间复杂度相关。

通常来说，只要算法不涉及到动态分配的空间以及递归、栈所需的空间，空间复杂度通常为 $O(1)$。

算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。

<script>
  if (!window.MathJax || !MathJax.Hub) {
    const script = document.createElement('script'); 
    script.src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
    document.head.appendChild(script);
  } else MathJax.Hub.Queue(['Typeset', MathJax.Hub, document.querySelector('main')]);
</script>