---
title: 一次搞懂时间复杂度和空间复杂度
date: 2017-01-08 02:17:34
tag: 数据结构
categories: 算法
---

学习数据结构和算法时，难免提到时间复杂度（asymptotic time complexity）和空间复杂度（space complexity）的概念。

<!--more-->

## 时间复杂度

概念：描述一个算法**执行时间**与数据规模的增长关系，记作：T(n) = O(f(n))。

计算时间复杂度时，需要遵循这一条原则：**如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时时间复杂度就是 O(f(n))。**

比如：

T(n)=n+5，时间复杂度为 O(n)；

T(n)=n³+n²+1，时间复杂度为 O(n³)；

T(n)=4n³，时间复杂度为 O(n³)。

下面举几个例子：

### 常数阶

我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c 为一个常数时，我们说这个算法的时间复杂度为 O(1)。 **哈希算法就是典型的 O(1) 时间复杂度**，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）。

```c
int n = 100;
int sum = n * (n + 1) / 2;
printf("%i\n", sum);  
```

像上面这段代码，无论 n 是多少，运行步骤都一样，所以时间复杂度是 O(1)。

### 线性阶

O(n) 代表数据量增大 n 倍，耗时也增大 n 倍，比如常见的**遍历算法**。

对于一个循环，假设循环体的时间复杂度为 O(m)，循环次数为 n，那么循环的时间复杂度为 O(m×n)；

```c
for(int i = 0; i < n; i++) {        // 循环次数为 n
    printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
}
```

此时时间复杂度为 O(1×n)，即 O(n)。

### 平方阶

Ο(n²)：代表数据量增大 n 倍，时间复杂度就是 n² ，比如**冒泡排序**。

对于下面这个多循环，循环次数为 n×n，那么时间复杂度为 O(n × n × 1)，即 O(n²)。

```c
for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
        printf("Hello, World!\n");
    }
}
```

### 对数阶

O(logn)：当数据增大 n 倍时，耗时增大 logn 倍。比如下面这段代码，当数据增大 256 倍时，耗时只增大 8 倍，是比线性还要低的时间复杂度。

```c
for (int i = 1; i <= n; i++) {
  i *= 2;
  printf("%i\n", i);
}
```

**二分查找**的时间复杂度就是 O(logn)。

### 对数阶乘以 n

O(nlogn)：当数据增大 n 倍时，耗时增大 nlogn 倍，比如。比如下面这段代码，当数据增大 256 倍时，耗时增大 256*8=2048 倍，这个复杂度高于线性阶低于平方阶。

```c
for(int i = 0; i < n; i++) {
  for (int i = 2; i < n; i++) {
    i *= 2;
    printf("%i\n", i);
  }
}
```

**归并排序**的时间复杂度就是 O(nlogn)。

### 指数阶

O(\(2^n\))：当数据增大 n 倍时，耗时增大 \(2^n\) 倍，比如斐波那契数列：

```c
long aFunc(int n) {
  if (n <= 1) {
    return 1;
  } else {
    return aFunc(n - 1) + aFunc(n - 2);
  }
}
```

常见的算法时间复杂度由小到大依次为：

Ο(1)＜Ο(logn)＜Ο(n)＜Ο(nlogn)＜Ο(n²)＜Ο(\(2^n\))

## 空间复杂度

概念：描述一个算法**占用空间**与数据规模的增长关系，记作：S(n) = O(f(n))。

一个算法在计算机上占用的内存包括：程序代码所占用的空间、输入输出数据所占用的空间、辅助变量所占用的空间这三个方面。程序代码所占用的空间取决于算法本身的长短，输入输出数据所占用的空间取决于要解决的问题，是通过参数表调用函数传递而来，只有辅助变量是算法运行过程中临时占用的存储空间，与空间复杂度相关。

通常来说，只要算法不涉及到动态分配的空间以及递归、栈所需的空间，空间复杂度通常为 O(1)。

算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。