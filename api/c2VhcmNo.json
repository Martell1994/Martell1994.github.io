[{"title":"终于抢到 HPV 啦！！！","date":"2019-11-20T15:42:11.000Z","date_formatted":{"ll":"Nov 20, 2019","L":"11/20/2019","MM-DD":"11-20"},"updated":"2019-12-05T03:36:01.796Z","content":"年初时候了解到了 HPV，几个月里，经历了若干次失败的尝试，功夫不负有心人，今天终于如愿抢到了疫苗。我决定将我期间的经历和尝试记录下来，如果你也有需要，不妨看一看。\n\n\n什么是 HPVHPV 英文名称 Human papillomavirus，西医学名“人乳头瘤病毒”，是一个拥有一百多种型号的家族。在女性恶性肿瘤中，宫颈癌的发病率仅次于乳腺癌，超过90%的宫颈癌病例都与 HPV 感染有关。HPV 有三种类型：二价、四价、九价，下面是简单的对比表：\n\n\n\n疫苗种类\n二价\n四价\n九价\n\n\n\n有效预防的 HPV 型号\n6，18\n6，11，16，18\n6，11，16，18，31，33，45，52，58\n\n\n国内规定的接种年龄\n9-45周岁\n20-45周岁\n16-26周岁\n\n\n接种时间\n0，1，6个月\n0，2，6个月\n0，2，6个月\n\n\n参考价格（3针）\n1740元\n2394元\n3894元\n\n\n主要功能\n预防84.5%的宫颈癌\n预防84.5%的宫颈癌金和90%的生殖器疣\n预防92.1%的宫颈癌和90%的生殖器疣\n\n\n杭州及周边疫苗预约信息从2019年2月27日至今，我吐血整理了微信公众号“杭州本地宝”中发布过的四价和九价的疫苗预约点，若几次开放的数据不一致，以最近的为准，具体信息如下：\n\n\n\n预约点\nHPV 类型（价）\n预约方式\n预约条件\n开放人数/次\n\n\n\n杭州东新\n四/九\n问卷星\n不限户籍\n100\n\n\n杭州湖滨\n九\n问卷星\n不限户籍\n100\n\n\n杭州凯旋\n九\n支付宝\n不限户籍\n230/350\n\n\n杭州凯旋\n四\n现场\n不限户籍\n100\n\n\n杭州朝晖\n四\n电话/问卷星\n不限户籍\n50～60\n\n\n杭州西溪\n四\n问卷星\n不限户籍\n不明\n\n\n杭州米市巷\n四\n问卷星\n不限户籍\n40\n\n\n杭州灵隐\n九\n问卷星\n不限户籍\n100～300\n\n\n杭州清波\n九\n问卷星\n不限户籍\n100\n\n\n杭州半山\n九\n问卷星\n不限户籍\n20\n\n\n杭州钱塘新区\n九\n网络登记\n不限户籍\n120\n\n\n杭州余杭\n九\n问卷星\n余杭户籍/参保人员/辖区内学生/持居住证\n2000\n\n\n杭州萧山\n九\n摇号\n萧山户籍/参保地在萧山\n100+\n\n\n杭州滨江\n九\n摇号\n滨江户籍/参保地在滨江\n200\n\n\n杭州大江东\n九\n摇号\n大江东范围户籍/住大江东范围满3个月\n100+\n\n\n杭州建德新安江\n九\n现场\n建德户籍/住建德满3个月\n100\n\n\n杭州富阳\n九\n网络预约\n富阳户籍/住富阳满3个月\n120\n\n\n绍兴新昌\n九\n官方微信\n新昌户籍/住新昌满3个月\n200\n\n\n绍兴上虞\n九\n现场\n上虞户籍/住上虞满3个月\n不明\n\n\n绍兴诸暨\n九\n电话\n不限户籍\n不明\n\n\n绍兴越城\n九\n现场\n不限户籍\n150～200\n\n\n绍兴柯桥/市区\n九\n官方微信\n不限户籍，但需先到医院门诊激活就诊卡\n10～100\n\n\n金华\n四/九\n微信小程序\n金华市各区户籍或持金华市社会保障市民卡\n90～225\n\n\n舟山\n九\n电话、现场\n不限户籍、本辖区优先\n不明\n\n\n衢州\n九\n现场\n不限户籍\n800\n\n\n嘉兴\n九\n电话\n户籍地或居住地在南湖（经开）区范围内\n200\n\n\n海宁\n九\n网址\n海宁户籍\n150\n\n\n临海\n九\n网络预约\n不限户籍\n30\n\n\n台州\n九\n问卷星\n不限户籍\n41\n\n\n宁波海曙\n九\n现场\n不限户籍\n不明\n\n\n宁波各区\n九\n金苗宝 App\n不限户籍\n不明\n\n\n…\n四/九\n…\n…\n…\n\n\n这里我要先吐槽一下几个小坑的预约经历：\n\n金苗宝 App，它的使用率在宁波各大医院和社区服务中心的使用率还是蛮高的，尤其是 HPV 疫苗和流感疫苗基本上都是通过这个 App 预约，但是我试过两次，都是接近预约时间，预约功能就处于瘫痪状态，估计服务器内存不够，大量请求同时访问，高并发导致服务器处于超负荷状态（我猜的）。\n杭州钱塘新区7个公众号的疫苗预约，这次预约消息是很早就放出来的，总结了前几次憨憨的失败经验，我决定借助一点技术手段，这次很容易就从页面中抓出了7个POST请求的 Request URL 和 body，查阅网上资料现学写了一个 sh 脚本，摩拳擦掌跃跃欲试，只待良辰一到，可是现实再一次打击了我，居然还是没有抢到？！！后面再 Review 了一下我的脚本，发现应该把七个请求做定时任务，进行异步执行。\n\n现在言归正传，杭州周边地区的预约地点对户籍和居住条件有限制，且多为现场或电话预约。近来疫苗供应有多起来的趋势，如果不是想打九价的女生即将超过26周岁或者有其它急迫的理由，不太建议大家离开自己的所在地区打疫苗，一来是无法刷医保，二来来回交通和时间成本也比较高。因此我建议：\n浙江省内（非杭州）户籍的女生：关注自己户籍所在地的疾控中心微信公众号，如富阳疾控、嘉兴疾控等，及时跟进公众号发布的信息。\n萧山、余杭、大江东、滨江户籍或参保地在这四地的女生：不要错过摇号的时间，毕竟其他区的女生都得不到这个机会。\n其他女生：能尝试的都可以试一下，尤其是江干凯旋中心的支付宝预约和杭州主城区各街道提供的的问卷星预约。输入问卷时，可以事先在输入法里设置快捷键，输入简单的字符串就能弹出个人信息，这样速度又快，也不担心填错。如果还是不行，下面介绍的小技巧，也许对你有帮助。\n支付宝抢疫苗攻略支付宝预约页面和微信不一样，他允许提早填好信息，非本人也可以帮忙预约，且页面上有倒计时，你只需要掐好提交按钮 enable 的时间，就看谁手速更快，网速更好了。\n根据成功人士的建议：一定要提早十多分钟进页面填好信息，千万不要中途退出！！！亲测在有次手贱退出去了，然后就一直在页面上欣赏蚂蚁了（手动微笑）。\n问卷星抢疫苗攻略问卷星是我成功抢到疫苗的渠道，之前几个预约点在微信公众号里提供的问卷星链接是可以在电脑网页里打开的，当时我查看了一下它的前端代码，大概是这样：\n\n\n这令我们发现问卷星的几个输入框其实是有明显规律的，输入的值会成为 id 分别为 q1、q2、q3、q4 的元素的value，哪怕问卷中的问题顺序发生了调整，我们也只需要通过模糊匹配，找到对应的 div id 和 input id 即可。\n基本上预约信息上需要填写的不外乎姓名、联系方式、身份证、年龄等，这样你就可以引用下面这串 js。\n1javascript: void((function() &#123;2    if ($(\"div1\") == null) &#123;3        setTimeout(function() &#123;4            location.reload()5        &#125;,6        100);7        return;8    &#125;9    var hash = [[\"这里换成你的真实姓名\", /(姓名)|(名字)/], [\"这里换成你的手机号\", /(手机)|(联系方式)/], [\"这里换成你的年龄（周岁）\", /(年龄)/], [\"这里换成你的身份证\", /(身份证)|(证件)/], ];10    function $(a) &#123;11        return document.getElementById(a)12    &#125;13    for (var i = 1;; i++) &#123;14        if ($(\"div\" + i) == null) break;15        if (!$(\"q\" + i)) continue;16        var title = $(\"div\" + i).innerHTML;17        for (var j = 0; j &lt; hash.length; j++) &#123;18            if (hash[j][1].test(title)) &#123;19                $(\"q\" + i).value = hash[j][0];20                break;21            &#125;22        &#125;23    &#125;24&#125;)());25function validate() &#123;26    return true;27&#125;\n\n打开浏览器的开发者模式，在控制台中粘贴这串 js，回车，网页上就会自动注入信息。\n\n\n10月30日这一天，因为写好了这个“外挂”，我对抢疫苗非常信心满满，不料这次他们设置了“只允许从微信中填写” 和“获取微信用户昵称、性别等（需登录）”，可见问卷设计者也在和我们在斗智斗勇啊🤦‍♀️。\n\n\n第一个解决起来也很简单，只需要用微信开发者工具打开网址即可。但是第二种我暂时没有找到解决方案，因为按照微信官方文档中所说，微信开发者工具只能调试自己绑定过的公众号，不过好在这次下城区东新街道社区卫生服务中心没有强制要求微信登录，建议你们也可以多关注这家社区医院。\n最后，再感叹一下技术改变生活，nice～\n","plink":"https://fiteen.top/oh-hpv/"},{"title":"如何提升 Flutter 项目的开发效率","date":"2019-09-14T17:43:27.000Z","date_formatted":{"ll":"Sep 15, 2019","L":"09/15/2019","MM-DD":"09-15"},"updated":"2019-12-04T12:24:09.610Z","content":"最近参与了一个 Flutter 项目的开发，总结了一些提升开发效率的工具和方法。\n\n\nUI 可视化工具纯客户端开发者一开始可能会对写 Flutter 的界面布局会不太适应，那么这个 https://flutterstudio.app 网站可以帮助你更快熟悉 Flutter 的常用组件，在这个工具上，你可以通过简单的拖拽直接实现布局。\n\n\n代码模版我们发现在开发时，IDE 自带的代码快捷提示都不太丰富，比如要创建一个包含所有生命周期相关方法的完整的 StatefulWidget，如果能一键导入就能快速很多，这时候就可以借助代码模版。我事先在网上找到一份比较全面的模版，有需要的可以参考 code plugins，有时间我会按照自己习惯的风格再整理一份。\n如果你使用的是 VSCode，打开路径：\n\nView → Command Palette… → 输入 &gt;Preferences: Configure User Snippets\n\n\n\n然后输入 dart，这时会打开一个 dart.json 文件，把上面的内容替换进来即可。\n如果你使用的是 Android Studio，依次打开路径：\n\nPreferences → Editor → File and Code Templates\n\n在 Files 下找到 Dart File,将 json 文件里的内容粘贴进去即可。\n\n\n这样我们只需要输入简单的前缀就能直接联想出整个代码块了。 \n布局调试在实现 UI 模块的时候，经常会出现布局错乱的情况，VSCode 也为此提供了界面调试工具，在 Flutter App 调试过程中，打开路径：\n\nView → Command Palette… → 输入 &gt;Flutter: Toggle Debug Painting\n\n\n\n上面的辅助线可以帮助开发者检查布局。\n\n注意：通过 flutter run 方式启动的模拟器/真机是没法开启布局调试的。\n\n不过如果遇到难以定位的问题，建议还是使用 Androidio Studio 进行调试，它提供了下面这两个可视化工具：\nFlutter Inspector\n\n理解和查看现有布局\n诊断布局的问题\n\nFlutter Outline\n\n视图预览\n调整 widget\n\n\n\n巧用快捷键借助 IDE 中的快捷键也是我们提高开发效率的关键之一。以 Android Studio 为例：\n\noption+enter：对 widget 进行特定的操作\n\n\n\n\ncommand+option+L：格式化代码，同时，也建议你在方法尾部尽量加逗号，这有助于自动格式化程序为 Flutter 样式代码插入适当的换行符\n\ncontrol+option+O：一键清除多余的 imports\n\n……\n\n\n常用插件常用的插件基本上都可以在Dart 开源包的网站里找到，选用合适的 package 可以帮你节省不少重复实现的时间。网上的 Coder 朋友们也总结了很多不错的插件，本文里就不一一记录了。\n","plink":"https://fiteen.top/how-to-develop-flutter-projects-more-efficiently/"},{"title":"【译】Fucking SwiftUI","date":"2019-07-17T18:31:57.000Z","date_formatted":{"ll":"Jul 18, 2019","L":"07/18/2019","MM-DD":"07-18"},"updated":"2019-12-04T12:24:39.813Z","content":"\n原文：Fucking Swift UI - Cheat Sheet译者的话：翻译过程中，发现了原文中的几个错误，我向作者@sarunw提出意见后，直接在译文中改掉了，如果您发现文中内容有误，欢迎与我联系。\n\n\n\n关于 SwiftUI，您在下文中看到的所有答案并不是完整详细的，它只能充当一份备忘单，或是检索表。\n常见问题关于 SwiftUI 的常见问题：\n是否需要学 SwiftUI？\n是\n是否有必要现在就学 SwiftUI？\n看情况，因为 SwiftUI 目前只能在 iOS 13、macOS 10.15、tvOS 13和 watchOS 6 上运行。如果您要开发的新应用计划仅针对前面提到的 OS 系统，我会说是。 但是，如果您打算找工作或是无法确保会在此 OS 版本的客户端项目上工作，则可能要等一两年，再考虑迁移成 SwiftUI，毕竟大多数客户端工作都希望支持尽可能多的用户，这意味着您的应用必须兼容多个 OS 系统。 因此，一年后再去体验优雅的 SwiftUI 也许是最好的时机。\n是否需要学 UIKit/AppKit/WatchKit？\n是的，就长时间来看，UIKit 仍将是 iOS 架构的重要组成部分。现在的 SwiftUI 并不成熟完善，我认为即使您打算用 SwiftUI 来开发，仍然不时需要用到 UIKit。\nSwiftUI 能代替 UIKit/AppKit/WatchKit 吗?\n现在不行，但将来也许会。SwiftUI 虽然是刚刚推出的，它看起来已经很不错。我希望两者能长期共存，SwiftUI 还很年轻，它还需要几年的打磨成长才能去代替 UIKit/AppKit/WatchKit。\n如果我现在只能学习一种，那么应该选择 UIKit/AppKit/WatchKit 还是 SwiftUI？\nUIKit。 您始终可以依赖 UIKit，它用起来一直不错，且未来一段时间仍然可用。如果您直接从 SwiftUI 开始学习，可能会遗漏了解一些功能。\nSwiftUI 的控制器在哪里？\n没有了。 如今页面间直接通过响应式编程框架 Combine 交互。Combine 也作为新的通信方式替代了 UIViewController。\n要求\nXcode 11 Beta（从 Apple 官网下载）\niOS 13 / macOS 10.15 / tvOS 13 / watchOS 6\nmacOS Catalina，以便在画布上呈现 SwiftUI（从 Apple 官网下载）\n\n\n想要体验 SwiftUI 画布，但不想在您的电脑上安装 macOS Catalina beta 系统您可以与当前的 macOS 版本并行安装 Catalina。这里介绍了如何在单独的 APFS 卷上安装 macOS\n\nSwiftUI 中等效的 UIKit视图控制器\n\n\nUIKit\nSwiftUI\n备注\n\n\n\nUIViewController\nView\n-\n\n\nUITableViewController\nList\n-\n\n\nUICollectionViewController\n-\n目前，还没有 SwiftUI 的替代品，但是您可以像Composing Complex Interfaces’s tutorial里那样，使用 List 的组成来模拟布局\n\n\nUISplitViewController\nNavigationView\nBeta 5中有部分支持，但仍然无法使用。\n\n\nUINavigationController\nNavigationView\n-\n\n\nUIPageViewController\n-\n-\n\n\nUITabBarController\nTabView\n-\n\n\nUISearchController\n-\n-\n\n\nUIImagePickerController\n-\n-\n\n\nUIVideoEditorController\n-\n-\n\n\nUIActivityViewController\n-\n-\n\n\nUIAlertController\nAlert\n-\n\n\n视图和控件\n\n\nUIKit\nSwiftUI\n备注\n\n\n\nUILabel\nText\n-\n\n\nUITabBar\nTabView\n-\n\n\nUITabBarItem\nTabView\nTabView  里的 .tabItem\n\n\nUITextField\nTextField\nBeta 5中有部分支持，但仍然无法使用。\n\n\nUITableView\nList\nVStack 和 Form 也可以\n\n\nUINavigationBar\nNavigationView\nNavigationView 的一部分\n\n\nUIBarButtonItem\nNavigationView\nNavigationView 里的 .navigationBarItems\n\n\nUICollectionView\n-\n-\n\n\nUIStackView\nHStack\n.axis == .Horizontal\n\n\nUIStackView\nVStack\n.axis == .Vertical\n\n\nUIScrollView\nScrollView\n-\n\n\nUIActivityIndicatorView\n-\n-\n\n\nUIImageView\nImage\n-\n\n\nUIPickerView\nPicker\n-\n\n\nUIButton\nButton\n-\n\n\nUIDatePicker\nDatePicker\n-\n\n\nUIPageControl\n-\n-\n\n\nUISegmentedControl\nPicker\nPicker 中的一种样式 SegmentedPickerStyle\n\n\nUISlider\nSlider\n-\n\n\nUIStepper\nStepper\n-\n\n\nUISwitch\nToggle\n-\n\n\nUIToolBar\n-\n-\n\n\n框架集成 - SwiftUI 中的 UIKit将 SwiftUI 视图集成到现有应用程序中，并将 UIKit 视图和控制器嵌入 SwiftUI 视图层次结构中。\n\n\n\nUIKit\nSwiftUI\n备注\n\n\n\nUIView\nUIViewRepresentable\n-\n\n\nUIViewController\nUIViewControllerRepresentable\n-\n\n\n框架集成 - UIKit 中的 SwiftUI将 SwiftUI 视图集成到现有应用程序中，并将 UIKit 视图和控制器嵌入 SwiftUI 视图层次结构中。\n\n\n\nUIKit\nSwiftUI\n备注\n\n\n\nUIView (UIHostingController)\nView\n没有直接转换为 UIView 的方法，但是您可以使用容器视图将 UIViewController 中的视图添加到视图层次结构中\n\n\nUIViewController (UIHostingController)\nView\n-\n\n\nSwiftUI - 视图和控件Text显示一行或多行只读文本的视图。\n1Text(\"Hello World\")\n\n样式:\n1Text(\"Hello World\")2  .bold()3  .italic()4  .underline()5  .lineLimit(2)\n\nText 中填入的字符串也用作 LocalizedStringKey，因此也会直接获得 NSLocalizedString 的特性。\n1Text(\"This text used as localized key\")\n\n直接在文本视图里格式化文本。 实际上，这不是 SwiftUI 的功能，而是 Swift 5的字符串插入特性。\n1static let dateFormatter: DateFormatter = &#123;2    let formatter = DateFormatter()3    formatter.dateStyle = .long4    return formatter5&#125;()67var now = Date()8var body: some View &#123;9    Text(\"What time is it?: \\(now, formatter: Self.dateFormatter)\")10&#125;\n\n可以直接用 + 拼接 Text 文本:\n1Text(\"Hello \") + Text(\"World!\").bold()\n\n文字对齐方式：\n1Text(\"Hello\\nWorld!\").multilineTextAlignment(.center)\n\n文档\nTextField显示可编辑文本界面的控件。\n1@State var name: String = \"John\"    2var body: some View &#123;3    TextField(\"Name's placeholder\", text: $name)4        .textFieldStyle(RoundedBorderTextFieldStyle())5        .padding()6&#125;\n\n文档\nSecureField用户安全地输入私人文本的控件。\n1@State var password: String = \"1234\"    2var body: some View &#123;3    SecureField($password)4        .textFieldStyle(RoundedBorderTextFieldStyle())5        .padding()6&#125;\n\n文档\nImage显示图像的视图。\n1Image(\"foo\") //图像名字为 foo\n\n我们可以使用新的 SF Symbols：\n1Image(systemName: \"clock.fill\")\n\n您可以通过为系统图标添加样式，来匹配您使用的字体：\n1Image(systemName: \"cloud.heavyrain.fill\")2    .foregroundColor(.red)3    .font(.title)4Image(systemName: \"clock\")5    .foregroundColor(.red)6    .font(Font.system(.largeTitle).bold())\n\n为图片增加样式：\n1Image(\"foo\")2    .resizable() // 调整大小，以便填充所有可用空间3    .aspectRatio(contentMode: .fit)\n\n文档\nButton在触发时执行操作的控件。\n1Button(2    action: &#123;3        // 点击事件4    &#125;,5    label: &#123; Text(\"Click Me\") &#125;6)\n\n如果按钮的标签只有 Text，则可以通过下面这种简单的方式进行初始化：\n1Button(\"Click Me\") &#123;2    // 点击事件3&#125;\n\n您可以像这样给按钮添加属性：\n1Button(action: &#123;2                3&#125;, label: &#123;4    Image(systemName: \"clock\")5    Text(\"Click Me\")6    Text(\"Subtitle\")7&#125;)8.foregroundColor(Color.white)9.padding()10.background(Color.blue)11.cornerRadius(5)\n\n文档\nNavigationLink按下时会触发导航演示的按钮。它用作代替 pushViewController。\n1NavigationView &#123;2    NavigationLink(destination:3        Text(\"Detail\")4        .navigationBarTitle(Text(\"Detail\"))5    ) &#123;6        Text(\"Push\")7    &#125;.navigationBarTitle(Text(\"Master\"))8&#125;\n\n为了增强可读性，可以把 destination 包装成自定义视图 DetailView 的方式：\n1NavigationView &#123;2    NavigationLink(destination: DetailView()) &#123;3        Text(\"Push\")4    &#125;.navigationBarTitle(Text(\"Master\"))5&#125;\n\n\n但不确定是 Bug 还是设计使然，上述代码 在 Beta 5 中的无法正常执行。尝试像这样把 NavigationLink 包装进列表中试一下：\n1NavigationView &#123;2   List &#123;3       NavigationLink(destination: Text(\"Detail\")) &#123;4           Text(\"Push\")5       &#125;.navigationBarTitle(Text(\"Master\"))6   &#125;7&#125; \n\n如果 NavigationLink 的标签只有 Text ，则可以用这样更简单的方式初始化：\n1NavigationLink(\"Detail\", destination: Text(\"Detail\").navigationBarTitle(Text(\"Detail\")))\n\n文档\nToggle在开/关状态之间切换的控件。\n1@State var isShowing = true // toggle 状态值23Toggle(isOn: $isShowing) &#123;4    Text(\"Hello World\")5&#125;\n\n如果 Toggle 的标签只有 Text，则可以用这样更简单的方式初始化：\n1Toggle(\"Hello World\", isOn: $isShowing)\n\n文档\nPicker从一组互斥值中进行选择的控件。\n选择器样式根据其被父视图进行更改，在表单或列表下作为一个列表行显示，点击可以推出新界面展示所有的选项卡。\n1NavigationView &#123;2    Form &#123;3        Section &#123;4            Picker(selection: $selection, label:5                Text(\"Picker Name\")6                , content: &#123;7                    Text(\"Value 1\").tag(0)8                    Text(\"Value 2\").tag(1)9                    Text(\"Value 3\").tag(2)10                    Text(\"Value 4\").tag(3)11            &#125;)12        &#125;13    &#125;14&#125;\n\n您可以使用 .pickerStyle(WheelPickerStyle())覆盖样式。\n在 iOS 13 中， UISegmentedControl 也只是 Picker 的一种样式。\n1@State var mapChoioce = 02var settings = [\"Map\", \"Transit\", \"Satellite\"]3Picker(\"Options\", selection: $mapChoioce) &#123;4    ForEach(0 ..&lt; settings.count) &#123; index in5        Text(self.settings[index])6            .tag(index)7    &#125;89&#125;.pickerStyle(SegmentedPickerStyle())\n\n\n分段控制器在iOS 13中也焕然一新了。\n\n文档\nDatePicker选择日期的控件。\n日期选择器样式也会根据其父视图进行更改，在表单或列表下作为一个列表行显示，点击可以扩展到日期选择器（就像日历 App 一样）。\n1@State var selectedDate = Date()23var dateClosedRange: ClosedRange&lt;Date&gt; &#123;4    let min = Calendar.current.date(byAdding: .day, value: -1, to: Date())!5    let max = Calendar.current.date(byAdding: .day, value: 1, to: Date())!6    return min...max7&#125;89NavigationView &#123;10    Form &#123;11        Section &#123;12            DatePicker(13                selection: $selectedDate,14                in: dateClosedRange,15                displayedComponents: .date,16                label: &#123; Text(\"Due Date\") &#125;17            )18        &#125;19    &#125;20&#125;\n\n不在表单或列表里，它就可以作为普通的旋转选择器。\n1@State var selectedDate = Date()23var dateClosedRange: ClosedRange&lt;Date&gt; &#123;4    let min = Calendar.current.date(byAdding: .day, value: -1, to: Date())!5    let max = Calendar.current.date(byAdding: .day, value: 1, to: Date())!6    return min...max7&#125;89DatePicker(10    selection: $selectedDate,11    in: dateClosedRange,12    displayedComponents: [.hourAndMinute, .date],13    label: &#123; Text(\"Due Date\") &#125;14)\n\n如果 DatePicker 的标签只有 Text，则可以用这样更简单的方式初始化：\n1DatePicker(\"Due Date\",2            selection: $selectedDate,3            in: dateClosedRange,4            displayedComponents: [.hourAndMinute, .date])\n\n可以使用 ClosedRange、PartialRangeThrough 和 PartialRangeFrom 来设置 minimumDate 和 maximumDate 。\n1DatePicker(\"Minimum Date\",2    selection: $selectedDate,3    in: Date()...,4    displayedComponents: [.date])5DatePicker(\"Maximum Date\",6    selection: $selectedDate,7    in: ...Date(),8    displayedComponents: [.date])\n\n文档\nSlider从有界的线性范围中选择一个值的控件。\n1@State var progress: Float = 023Slider(value: $progress, from: 0.0, through: 100.0, by: 5.0)\n\nSlider 虽然没有 minimumValueImage 和 maximumValueImage 属性， 但可以借助 HStack实现。\n1@State var progress: Float = 02HStack &#123;3    Image(systemName: \"sun.min\")4    Slider(value: $progress, from: 0.0, through: 100.0, by: 5.0)5    Image(systemName: \"sun.max.fill\")6&#125;.padding()\n\n文档\nStepper用于执行语义上递增和递减动作的控件。\n1@State var quantity: Int = 02Stepper(value: $quantity, in: 0...10, label: &#123; Text(\"Quantity \\(quantity)\")&#125;)\n\n如果您的 Stepper 的标签只有 Text，则可以用这样更简单的方式初始化：\n1Stepper(\"Quantity \\(quantity)\", value: $quantity, in: 0...10)\n\n如果您要一个自己管理的数据源的控件，可以这样写：\n1@State var quantity: Int = 02Stepper(onIncrement: &#123;3    self.quantity += 14&#125;, onDecrement: &#123;5    self.quantity -= 16&#125;, label: &#123; Text(\"Quantity \\(quantity)\") &#125;)\n\n文档\nSwiftUI - 页面布局与演示HStack水平排列子元素的视图。\n创建一个水平排列的静态列表：\n1HStack (alignment: .center, spacing: 20)&#123;2    Text(\"Hello\")3    Divider()4    Text(\"World\")5&#125;\n\n文档\nVStack垂直排列子元素的视图。\n创建一个垂直排列的静态列表：\n1VStack (alignment: .center, spacing: 20)&#123;2    Text(\"Hello\")3    Divider()4    Text(\"World\")5&#125;\n\n文档\nZStack子元素会在 z轴方向上叠加，同时在垂直/水平轴上对齐的视图。\n1ZStack &#123;2    Text(\"Hello\")3        .padding(10)4        .background(Color.red)5        .opacity(0.8)6    Text(\"World\")7        .padding(20)8        .background(Color.red)9        .offset(x: 0, y: 40)10&#125;\n\n文档\nList用于显示排列一系列数据行的容器。\n创建一个静态可滚动列表：\n1List &#123;2    Text(\"Hello world\")3    Text(\"Hello world\")4    Text(\"Hello world\")5&#125;\n\n表单里的内容可以混搭：\n1List &#123;2    Text(\"Hello world\")3    Image(systemName: \"clock\")4&#125;\n\n创建一个动态列表：\n1let names = [\"John\", \"Apple\", \"Seed\"]2List(names) &#123; name in3    Text(name)4&#125;\n\n加入分区：\n1List &#123;2    Section(header: Text(\"UIKit\"), footer: Text(\"We will miss you\")) &#123;3        Text(\"UITableView\")4    &#125;56    Section(header: Text(\"SwiftUI\"), footer: Text(\"A lot to learn\")) &#123;7        Text(\"List\")8    &#125;9&#125;\n\n要使其成为分组列表，请添加 .listStyle(GroupedListStyle())：\n1List &#123;2    Section(header: Text(\"UIKit\"), footer: Text(\"We will miss you\")) &#123;3        Text(\"UITableView\")4    &#125;56    Section(header: Text(\"SwiftUI\"), footer: Text(\"A lot to learn\")) &#123;7        Text(\"List\")8    &#125;9&#125;.listStyle(GroupedListStyle())\n\n文档\nScrollView滚动视图。\n1ScrollView(alwaysBounceVertical: true) &#123;2    Image(\"foo\")3    Text(\"Hello World\")4&#125;\n\n文档\nForm对数据输入的控件进行分组的容器，例如在设置或检查器中。\n您可以往表单中插入任何内容，它将为表单渲染适当的样式。\n1NavigationView &#123;2    Form &#123;3        Section &#123;4            Text(\"Plain Text\")5            Stepper(value: $quantity, in: 0...10, label: &#123; Text(\"Quantity\") &#125;)6        &#125;7        Section &#123;8            DatePicker($date, label: &#123; Text(\"Due Date\") &#125;)9            Picker(selection: $selection, label:10                Text(\"Picker Name\")11                , content: &#123;12                    Text(\"Value 1\").tag(0)13                    Text(\"Value 2\").tag(1)14                    Text(\"Value 3\").tag(2)15                    Text(\"Value 4\").tag(3)16            &#125;)17        &#125;18    &#125;19&#125;\n\n文档\nSpacer一块既能在包含栈布局时沿主轴伸展，也能在不包含栈时沿两个轴展开的灵活空间。\n1HStack &#123;2    Image(systemName: \"clock\")3    Spacer()4    Text(\"Time\")5&#125;\n\n文档\nDivider用于分隔其它内容的可视化元素。\n1HStack &#123;2    Image(systemName: \"clock\")3    Divider()4    Text(\"Time\")5&#125;.fixedSize()\n\n文档\nNavigationView用于渲染视图堆栈的视图，这些视图会展示导航层次结构中的可见路径。\n1NavigationView &#123;            2    List &#123;3        Text(\"Hello World\")4    &#125;5    .navigationBarTitle(Text(\"Navigation Title\")) // 默认使用大标题样式6&#125;\n\n对于旧样式标题：\n1NavigationView &#123;            2    List &#123;3        Text(\"Hello World\")4    &#125;5    .navigationBarTitle(Text(\"Navigation Title\"), displayMode: .inline)6&#125;\n\n增加 UIBarButtonItem\n1NavigationView &#123;2    List &#123;3        Text(\"Hello World\")4    &#125;5    .navigationBarItems(trailing:6        Button(action: &#123;7            // Add action8        &#125;, label: &#123;9            Text(\"Add\")10        &#125;)11    )12    .navigationBarTitle(Text(\"Navigation Title\"))13&#125;\n\n用 NavigationLink 添加 show/push 功能。\n作为 UISplitViewController：\n1NavigationView &#123;2    List &#123;3        NavigationLink(\"Go to detail\", destination: Text(\"New Detail\"))4    &#125;.navigationBarTitle(\"Master\")5    Text(\"Placeholder for Detail\")6&#125;\n\n您可以使用两种新的样式属性：stack 和 doubleColumn 为 NavigationView 设置样式。默认情况下，iPhone 和 Apple TV 上的导航栏上显示导航堆栈，而在 iPad 和 Mac 上，显示的是拆分样式的导航视图。\n您可以通过 .navigationViewStyle 重写样式：\n1NavigationView &#123;2    MyMasterView()3    MyDetailView()4&#125;5.navigationViewStyle(StackNavigationViewStyle())\n\n在 beta 3中，NavigationView 支持拆分视图，但它仅支持非常基本的结构，其中主视图为列表，详细视图为叶视图，我期待在下一个 release 版本中能有优化补充。\n文档\nTabView使用交互式用户界面元素在多个子视图之间切换的视图。\n1TabView &#123;2    Text(\"First View\")3        .font(.title)4        .tabItem(&#123; Text(\"First\") &#125;)5        .tag(0)6    Text(\"Second View\")7        .font(.title)8        .tabItem(&#123; Text(\"Second\") &#125;)9        .tag(1)10&#125;\n\n标签元素支持同时显示图像和文本， 您也可以使用 SF Symbols。\n1TabView &#123;2    Text(\"First View\")3        .font(.title)4        .tabItem(&#123;5            Image(systemName: \"circle\")6            Text(\"First\")7        &#125;)8        .tag(0)9    Text(\"Second View\")10        .font(.title)11        .tabItem(VStack &#123;12            Image(\"second\")13            Text(\"Second\")14        &#125;)15        .tag(1)16&#125;\n\n您也可以省略 VStack：\n1TabView &#123;2    Text(\"First View\")3        .font(.title)4        .tabItem(&#123;5            Image(systemName: \"circle\")6            Text(\"First\")7        &#125;)8        .tag(0)9    Text(\"Second View\")10        .font(.title)11        .tabItem(&#123;12            Image(\"second\")13            Text(\"Second\")14        &#125;)15        .tag(1)16&#125;\n\n文档\nAlert一个展示警告信息的容器。\n我们可以根据布尔值显示 Alert 。\n1@State var isError: Bool = false23Button(\"Alert\") &#123;4    self.isError = true5&#125;.alert(isPresented: $isError, content: &#123;6    Alert(title: Text(\"Error\"), message: Text(\"Error Reason\"), dismissButton: .default(Text(\"OK\")))7&#125;)\n\n它也可与 Identifiable 项目绑定。\n1@State var error: AlertError?23var body: some View &#123;4    Button(\"Alert Error\") &#123;5        self.error = AlertError(reason: \"Reason\")6    &#125;.alert(item: $error, content: &#123; error in7        alert(reason: error.reason)8    &#125;)    9&#125;1011func alert(reason: String) -&gt; Alert &#123;12    Alert(title: Text(\"Error\"),13            message: Text(reason),14            dismissButton: .default(Text(\"OK\"))15    )16&#125;1718struct AlertError: Identifiable &#123;19    var id: String &#123;20        return reason21    &#125;22    23    let reason: String24&#125;\n\n文档\nModal模态视图的存储类型。\n我们可以根据布尔值显示 Modal 。\n1@State var isModal: Bool = false23var modal: some View &#123;4    Text(\"Modal\")5&#125;67Button(\"Modal\") &#123;8    self.isModal = true9&#125;.sheet(isPresented: $isModal, content: &#123;10    self.modal11&#125;)\n\n文档\n它也可与 Identifiable 项目绑定。\n1@State var detail: ModalDetail?23var body: some View &#123;4    Button(\"Modal\") &#123;5        self.detail = ModalDetail(body: \"Detail\")6    &#125;.sheet(item: $detail, content: &#123; detail in7        self.modal(detail: detail.body)8    &#125;)    9&#125;1011func modal(detail: String) -&gt; some View &#123;12    Text(detail)13&#125;1415struct ModalDetail: Identifiable &#123;16    var id: String &#123;17        return body18    &#125;19    20    let body: String21&#125;\n\n文档\nActionSheet操作表视图的存储类型。\n我们可以根据布尔值显示 ActionSheet 。\n1@State var isSheet: Bool = false23var actionSheet: ActionSheet &#123;4    ActionSheet(title: Text(\"Action\"),5                message: Text(\"Description\"),6                buttons: [7                    .default(Text(\"OK\"), action: &#123;8                        9                    &#125;),10                    .destructive(Text(\"Delete\"), action: &#123;11                        12                    &#125;)13                ]14    )15&#125;1617Button(\"Action Sheet\") &#123;18    self.isSheet = true19&#125;.actionSheet(isPresented: $isSheet, content: &#123;20    self.actionSheet21&#125;)\n\n它也可与 Identifiable 项目绑定。\n1@State var sheetDetail: SheetDetail?23var body: some View &#123;4    Button(\"Action Sheet\") &#123;5        self.sheetDetail = ModSheetDetail(body: \"Detail\")6    &#125;.actionSheet(item: $sheetDetail, content: &#123; detail in7        self.sheet(detail: detail.body)8    &#125;)9&#125;1011func sheet(detail: String) -&gt; ActionSheet &#123;12    ActionSheet(title: Text(\"Action\"),13                message: Text(detail),14                buttons: [15                    .default(Text(\"OK\"), action: &#123;16                        17                    &#125;),18                    .destructive(Text(\"Delete\"), action: &#123;19                        20                    &#125;)21                ]22    )23&#125;2425struct SheetDetail: Identifiable &#123;26    var id: String &#123;27        return body28    &#125;29    30    let body: String31&#125;\n\n文档\n框架集成 - SwiftUI 中的 UIKitUIViewRepresentable表示 UIKit 视图的视图，当您想在 SwiftUI 中使用 UIView 时，请使用它。\n要使任何 UIView 在 SwiftUI 中可用，请创建一个符合 UIViewRepresentable 的包装器视图。\n1import UIKit2import SwiftUI34struct ActivityIndicator: UIViewRepresentable &#123;5    @Binding var isAnimating: Bool6    7    func makeUIView(context: Context) -&gt; UIActivityIndicatorView &#123;8        let v = UIActivityIndicatorView()9        10        return v11    &#125;12    13    func updateUIView(_ uiView: UIActivityIndicatorView, context: Context) &#123;14        if isAnimating &#123;15            uiView.startAnimating()16        &#125; else &#123;17            uiView.stopAnimating()18        &#125;19    &#125;20&#125;\n\n如果您想要桥接 UIKit 里的数据绑定 (delegate, target/action) 就使用 Coordinator， 具体见 SwiftUI 教程。\n1import SwiftUI2import UIKit34struct PageControl: UIViewRepresentable &#123;5    var numberOfPages: Int6    @Binding var currentPage: Int78    func makeUIView(context: Context) -&gt; UIPageControl &#123;9        let control = UIPageControl()10        control.numberOfPages = numberOfPages11        control.addTarget(12            context.coordinator,13            action: #selector(Coordinator.updateCurrentPage(sender:)),14            for: .valueChanged)1516        return control17    &#125;1819    func updateUIView(_ uiView: UIPageControl, context: Context) &#123;20        uiView.currentPage = currentPage21    &#125;2223    func makeCoordinator() -&gt; Coordinator &#123;24        Coordinator(self)25    &#125;2627    // This is where old paradigm located28    class Coordinator: NSObject &#123;29        var control: PageControl3031        init(_ control: PageControl) &#123;32            self.control = control33        &#125;3435        @objc func updateCurrentPage(sender: UIPageControl) &#123;36            control.currentPage = sender.currentPage37        &#125;38    &#125;39&#125;\n\n文档\nUIViewControllerRepresentable表示 UIKit 视图控制器的视图。当您想在 SwiftUI 中使用 UIViewController 时，请使用它。\n要使任何 UIViewController 在 SwiftUI 中可用，请创建一个符合 UIViewControllerRepresentable 的包装器视图，具体见 SwiftUI 教程。\n1import SwiftUI2import UIKit34struct PageViewController: UIViewControllerRepresentable &#123;5    var controllers: [UIViewController]67    func makeUIViewController(context: Context) -&gt; UIPageViewController &#123;8        let pageViewController = UIPageViewController(9            transitionStyle: .scroll,10            navigationOrientation: .horizontal)1112        return pageViewController13    &#125;1415    func updateUIViewController(_ pageViewController: UIPageViewController, context: Context) &#123;16        pageViewController.setViewControllers(17            [controllers[0]], direction: .forward, animated: true)18    &#125;19&#125;\n\n文档\n框架集成 - UIKit 中的 SwiftUIUIHostingController表示 SwiftUI 视图的 UIViewController。\n1let vc = UIHostingController(rootView: Text(\"Hello World\"))2let vc = UIHostingController(rootView: ContentView())\n\n文档\n来源\nAPI 文档\n官方教程\nWWDC 2019\n介绍 SwiftUI: 创建您的第一个 App\nSwiftUI 基础\nSwiftUI 数据流\n使用 SwiftUI 构建自定义视图\n集成 SwiftUI\nSwiftUI 中的可访问性\n所有设备上的 SwiftUI\nwatchOS 上的 SwiftUI\n掌握 Xcode 预览\n\n\n\n","plink":"https://fiteen.top/fucking-swiftUI/"},{"title":"海外开发者账号上架总结","date":"2019-02-17T09:59:18.000Z","date_formatted":{"ll":"Feb 17, 2019","L":"02/17/2019","MM-DD":"02-17"},"updated":"2019-12-04T12:31:27.902Z","content":"\n⚠️⚠️⚠️ 声明：本文仅供技术交流，勿企图上架违法 App，否则后果自负，谢谢！\n\n\n\n背景众所周知，国内的 App 上架形势愈发严峻。尤其是金融、医疗、博彩类的 App，审核非常严格，只要开发者缺少相关资质，想通过正常流程上架基本不可能；游戏方面，新政策又要求游戏版号需要广电审批，向大批游戏公司泼了一盆冷水；随着苹果机审算法的优化，苹果爸爸可以不费人力轻松看穿你的马甲包；甚至一些不存在任何违反审核规则的应用，也有可能因为开发者账号是新号被审核人员怀疑。\n\n\n相信不少开发者对上面的“四大酷刑”都不陌生，最怕苹果爸爸深夜邮件的关心，最怕上包率要写上 kpi。\n\n\n于是，为了很多开发者将目光抛向企业包，但是企业包成本来说比较高，根据企业签的稳定性，收费从每月几百到几千不等，遇到苹果封号密集的时期，甚至会出现每日掉签的情况。一个独立的企业签名，稳定周期基本也只能保持在2-3个月左右。因此企业包的方案仅适用于一些不受限于用户留存的 App，想要一款稳定运营的 App，依然需要上架 AppStore，下面介绍的就是使用海外开发者账号上架的方案。\n如何申请账号海外个人账号的申请方式和国内的大同小异：\n\n外国人身份证信息\n国外地区的信用卡一张\n国外的联系方式（手机号码）\n海外邮箱（gmail、hotmail、Yeah等邮箱均可）\n\n申请时候记得挂海外 VPN，且在后续登录开发者中心时也是用这个 IP，频繁更换 IP 尤其是用国内的很容易被封。\n如果没有渠道获得海外个人开发者的身份信息，可以直接找第三方（某宝）购买，大约1100元人民币，对方会告知你最近哪个地区的账号比较容易上架。\n\n注意：现在使用开发者账号都强制要求进行双重验证，用自己国内的手机号是没问题的。\n\n如果你的应用涉及到内购，需要关注一下账户所属国家。因为一些国家（美国，加拿大，澳大利亚）需要去税务局报税，没法用内购，其他国家是可以正常收款的。建议使用招行的储蓄卡，其次是建行的。满$150以后苹果就会汇款给你。\n还有一个非常值得注意的问题——如何避免被封号：\n\n登录开发者账号时关闭你的 Mac/iPhone 上的 iCloud 功能和系统定位服务\n使用海外区域的 VPN，勤换 IP\n最好不要在同一台电脑，同一个IP登录多个开发者账号\n\nApp 设计主题App 设计的方案很简单，就是“挂羊头卖狗肉”，你需要先设计一个对审核人员显示的壳，它要符合苹果爸爸心中“核心价值”的主题，尽量避讳直接表现一些敏感功能（如支付、教育、用户隐私权限等）。以下主题可供参考:\n\n记录类（记账（不太推荐，市面上用得比较多，容易被怀疑）、行程/心情/车票/电影票记录等）\n提醒类（备忘录、提醒事项、番茄ToDo）\n创意类（发挥你的 idea 做一些小工具之类）\n\n这些主题的特点就是可以做成单机类，但如果不得不涉及到网络请求数据，最好搞一台国外的服务器，不容易引起怀疑。\n如果你的 App 不可避免地要涉及要一些权限，比如联网、推送、通讯录、麦克风、相册、相机、定位、运动与健身等，需要将权限自然地设计进去。\nUI相比于主题来说，UI 的优劣可能更能影响审核人员的判断。千万不要认为只是一个壳而粗制滥造，优美的视觉真的可以在很大程度上帮助你过审。\n\n\n如上所示，海外 App 的风格和国内还是有比较大的差异，相对更简约，且海外 App 更看重动效的丰富性，如果你的 App 能令审核人员得到视觉上的愉悦感，就成功了一半。\n语言App 语言的选择需要得到重视，大部分情况下选择英文是没问题的，毕竟是全球通用的语言，但也要考虑上架地区的母语。我在第一次提审海外版 App 时就犯了一个错误，我将 App 语言设定为英文，为了避开中国审核，将面向上架地区时指定了墨西哥，结果收到了苹果的拒审邮件，他认定 App 违反了 Guideline 1.1.6，即存在虚假内容。为了不露馅，我通过找了在国外的朋友与苹果电话沟通，费了一番周折才确定原因在于“墨西哥的母语是西班牙语”。\n \n\n由于 App 上架后是要面向国内推广的，基本上都要做国际化（例如 App 名称、权限文案等），这一步建议在顺利过审2个版本后再加入。\nApp 上架与迭代前面做的一切准备当然只是为了让我们想要的 App 上架，因为选择合适的时机做审核切换是非常关键的。假如你的 App 本身包体积比较大，千万不要在某一次迭代中一次性加入所有代码，容易引起审核人员的怀疑。在 App 稳定更新2～3次后（这里的稳定指的是审核速度较快，一次通过，未卡审），你可以在 App 中加入审核开关，这个开关可以在接口里检测 ip 所属地。但假如是单机类的壳，用网络请求来判断就会很明显，这里也推荐了一种方案——借助时间戳延迟打开开关。\n根据前几次的审核经验，设定一个保险的时间节点，在那个时间点打开审核开关请求，尽量确保苹果在审核时候拦截不到任何可疑内容。同时为了防止苹果复审发现问题，可以再加一层判断，就是本地语言。因为国外工作人员的测试机基本上不会将中文设为默认语言，因此如下图所示，只要满足国内IP+默认中文两个条件的，才允许打开切换开关。\n\n\n\n以上就是我海外版 App 上架的经验，欢迎给我 E-mail 留言交流，最后祝大家都过包顺利！\n\n","plink":"https://fiteen.top/how-to-use-an-overseas-developer-account-to-upload-an-iOS-app/"},{"title":"『2018』勿忘初心","date":"2018-12-31T10:01:19.000Z","date_formatted":{"ll":"Dec 31, 2018","L":"12/31/2018","MM-DD":"12-31"},"updated":"2019-12-05T03:41:32.532Z","content":"时间飞逝，又到了写小作文的时候。2018 年用一个词语概括，就是“忙碌”。\n\n\n工作关键词——“尝试”。\n受到整个金融大环境的影响，公司里的大量移动端产品（尤其是 iOS 端）遇到了上架难的问题，和公司里很多的iOSer 一样，开始转型大前端，参与Android、h5、小程序的产品开发。由于没有完整的学习周期来过渡，基本上都是被直接排期启动开发，这段时间的压力还是比较大。为了保证开发进度，只能通过模仿项目里原有的代码的风格和写法去进行快速迭代，期间一度出现“我能实现这个功能，但我不清楚为什么这么做”的情况，很没有成就感。不过经历了三四个月的适应和学习，也慢慢弄清楚各种技术的框架和逻辑，也能独立完成项目并解决一些棘手的遗留问题。\n因为资质、监管的影响，产品的设计受到了极大的限制，团队也一直在找寻合适的方向。希望接下来的时间，我可以利用自己的专业为产品的进步提一些建设性的意见。\n最近和领导聊了一写东西，他说公司有的时候更愿意招聘1-3年经验的开发，因为这些人脑子灵活，开发速度快，“性价比”高，能够被提拔，给予高薪的，一定不只是因为他能够开发。本身女性在行业里会处于劣势一些，曾经的同学、幼年的伙伴，很多也已经迈入婚姻和家庭。学无止尽，我希望自己对工作和生活的热爱还能持续下去，也相信能为自己创造一片天地。\n投资关键词——“惨烈”。\n基金跌、股票跌、p2p暴雷，吃一堑、长一智。磨难让人成长，打不倒我们的才会令我们更强大！\n买房关键词——“迷茫”。\n杭州的房价在 G20 前后开始呈现节节攀升的态势，虽然政府一再提出限价，还是抑不住房价放飞的趋势。今天杭州开始实行摇号买房政策，身边一些朋友，也在万人摇中分到一杯羹。不过我参与了好几个红盘的摇号，也并没有摇到，但其实有的红盘位置并不是我目前以及未来很长一段时间的生活和工作情况，回过头来想一想，我为什么要摇这个房子呢？不了解楼面价、容积率、得房率，甚至连样板房都没有看过，就登记报名了，仅仅为了所谓的差价，为了实现买房的目标，为了凑个热闹，看看自己运气好不好？也许也有很多人像我这样，也许这个社会就是这样，人性就是这样，模仿是人类的本能，但是我想我真的要知道自己是什么样，想要的到底是什么，自我认知是一辈子长久的修行，但愿我们都能修好这门课。\n","plink":"https://fiteen.top/annual-summary-2018/"},{"title":"手把手教你免费搭建 Shadowsocks 服务","date":"2018-12-27T13:43:02.000Z","date_formatted":{"ll":"Dec 27, 2018","L":"12/27/2018","MM-DD":"12-27"},"updated":"2019-12-05T03:38:38.355Z","content":"一、申请免费试用GCP每位新注册的用户可以在谷歌云平台 GCP (Google Cloud Platform)获得第一年$300 的免费赠送额度。一年后若不主动选择继续使用不会扣费的。\n\n\n注册账户的准备工作：\n1、可用的 VPN，用于正常访问 GCP；\n2、具有 VISA、MasterCard 等海外支付功能的信用卡一张；\n有账户的可以直接登录，没有的就创建一个。\n \n\n如果阅读英文不习惯，可以将左下方的语言改成简体中文。登录成功后进入 GCP 试用申请：\n第1步 - 同意条款：注意选择国家/地区时避免选择“中国”，因为根据 Google Cloud 的政策，不支持中国使用，直接使用默认的“美国”即可。\n \n\n第2步 - 填写客户信息和付款方式\n客户信息的账户类型选择“个人”，通过虚拟美国人信息生成工具，补充完成“姓名和地址”信息。\n \n\n填写付款方式时，务必填入正确真实的信用卡信息，不能再使用生成工具里的虚拟信息。可以取消“信用卡或借记卡账单邮寄地址与上述地址相同”的勾选，输入真实的地址。\n \n\n申请成功会扣除$1，验证后将返回。至此，试用 GCP 免费申请完成。\n二、部署虚拟机1、修改防火墙在菜单中依次点击 【网络】 –&gt;【VPC 网络】 –&gt;【防火墙规则】–&gt;【创建防火墙规则】，如下图创建一条入站规则：\n \n\n注意点：\n\n目标：网络中的所有实例；如果选择指定标签，需要在后续的配置中输入标签\n\nIP地址范围： 0.0.0.0/0\n\n协议和端口：全部允许\n\n\n2、保留静态地址在菜单中依次点击 【网络】 –&gt;【VPC 网络】 –&gt;【外部 IP 地址】–&gt;【保留静态 IP】\n \n\n静态 IP 只能申请一个。区域可以选择亚洲东部、欧洲、美国等地，推荐使用 asia-east1，对应台湾地区，访问速度较快。\n3、创建计算引擎在菜单中依次点击 【计算】 –&gt;【Compute Engine】 –&gt;【VM 实例】–&gt;【创建实例】\n \n\n注意点：\n\n区域：与创建静态地址时一致\n\n机器类型：最便宜的“微型”即可\n\n启动磁盘：Ubuntu 16.04 LTS Minimal\n\n\n展开“管理、安全、磁盘、网络、单独租用”，外部 IP 选择第2步的静态 IP。到这里，虚拟机部署完成。\n \n\n\n\n三、搭建 SSR + BBR在 VM 实例列表中找到刚才创建好的实例，点击上图红框内的 SSH，会弹出终端，如下图所示。如果用的是谷歌浏览器可以使用 SSH 插件\n \n\n\n获得 root 权限\n\n1sudo -i\n\n\n检查内核版本\n\n1uname –sr\n\n正常情况下，当前的内核版本都是超过 4.9，无需升级，可以直接进入下一步；如果需要升级，按照以下步骤进行\n1// 更新系统2apt update3apt upgrade4// 安装指定的新内核5apt install linux-image-4.10.0-206// 卸载旧内核7apt autoremove8// 启用新内核9update-grub10// 重启11reboot12// 获得 root 权限13sudo -i14// 验证内核版本15uname –r\n\n\n写入配置\n\n1echo &quot;net.core.default_qdisc&#x3D;fq&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf2echo &quot;net.ipv4.tcp_congestion_control&#x3D;bbr&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf\n\n\n配置生效\n\n1sysctl -p\n\n\n检验是否开启成功\n\n1lsmod | grep bbr\n\n如果看到回显tcp_bbr 20480说明已经成功开启 BBR。\n四、搭建 Shadowsocks Server\n更新 apt-get 软件包\n\n1sudo apt-get update\n\n\n通过 apt-get 安装 python-pip\n\n1sudo apt-get install python-pip\n\n\n使用 pip 安装 shadowsocks 服务\n\n1sudo pip install shadowsocks\n\n如果出现类似 Successfullying installed shadowsocks - x.x.x的提示说明安装成功。\n\n创建  Shadowsocks Server 配置文件\n\n1sudo vim /etc/ss-conf.json\n\n回车之后会进入这个创建的文件，windows 下点击键盘上的 insert 键进入编辑，mac 系统则随便输入一个字母可以进入编辑。输入以下内容：\n1&#123;2&quot;server&quot;:&quot;0.0.0.0&quot;,3&quot;server_port&quot;:8838,4&quot;local_address&quot;:&quot;127.0.0.1&quot;,5&quot;local_port&quot;:1080,6&quot;password&quot;:&quot;fiteen&quot;,7&quot;timeout&quot;:600,8&quot;method&quot;:&quot;aes-256-cfb&quot;9&#125;1011&#x2F;&#x2F; server_port 与 password 分别对应 Shadowsocks 客户端上配置使用的端口和密码，内容请自定义\n\n点击 ESC 键，左下角的 insert 标志消失，同时按下”shift” 和”:”键，左下角出现”:” 标志，输入”wq”，接着回车即保存退出文件。\n\n用配置文件启动 Shadowsocks Server\n\n1sudo ssserver -c /etc/ss-conf.json -d start\n\n如果要设置开机启动，可以参考这篇文章。\n服务搭建已经完成了，以 Mac 客户端为例，输入上面配置的内容，确定后开启服务便可以科学上网了。\n \n\n","plink":"https://fiteen.top/teach-you-to-build-a-free-Shadowsocks-service/"},{"title":"Git 手册之 Mac 上给 Git 设置 SOCKS5/HTTP 代理","date":"2018-09-02T10:59:02.000Z","date_formatted":{"ll":"Sep 2, 2018","L":"09/02/2018","MM-DD":"09-02"},"updated":"2019-12-05T03:36:30.787Z","content":"我们常会遇到从 GitHub 上 clone 代码的时候龟速的情况，这时如果手上有不错的代理，可以借助代理来获取更快下载/上传资源的速度。\n\n\n通常我们 clone 代码时有以下两种方式：\n1&#x2F;&#x2F; HTTPS 方式2https:&#x2F;&#x2F;github.com&#x2F;accountname&#x2F;projectname.git3&#x2F;&#x2F; SSH 方式4git@github.com:accountname&#x2F;projectname.git\n\n设置 HTTP 方式的代理由于 Shadowsocks 客户端就提供一个本地的 SOCKS5 代理，代理地址是 127.0.0.1:1080。在终端输入以下配置：\n1git config --global http.proxy \"socks5://127.0.0.1:1080\"2git config --global https.proxy \"socks5://127.0.0.1:1080\"\n\n取消代理则：\n1git config --global --unset http.proxy2git config --global --unset https.proxy\n\n也可以直接修改用户主目录下的  .gitconfig 文件，插入如下内容：\n1[http]2        proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:10803[https]4        proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1080\n\n如果你用的不是 SOCKS5，而是 HTTP 代理，就把上面命令中的 socks5 换成 http ，同时改成正确的端口号。\n设置 SSH 方式的代理修改用户目录下文件  ~/.ssh/config 里的内容，对 GitHub 域名作单独处理：\n1Host github.com2    # 若使用的是默认端口，设置如下3    HostName           github.com4    # 如果想用443端口，设置如下5    # Hostname         ssh.github.com6    # Port             4437    User               git8    # 如果是 SOCKS5 代理，取消下面这行注释，并把 1080 改成自己 SOCKS5 代理的端口9    # ProxyCommand     nc -x localhost:1080 %h %p10    # 如果是 HTTP 代理，取消下面这行注释，并把 6666 改成自己 HTTP 代理的端口11    # ProxyCommand     socat - PROXY:127.0.0.1:%h:%p,proxyport&#x3D;6666\n\n直接在终端设置临时代理或者我们可以在 ~/.bashrc文件中，直接写入以下内容并保存：\n1alias setproxy&#x3D;&quot;export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;2alias unsetproxy&#x3D;&quot;unset ALL_PROXY&quot;3alias ip&#x3D;&quot;curl -i http:&#x2F;&#x2F;ip.cn&quot;\n\nclone 之前先在终端执行  setproxy 命令，结束后执行  unsetproxy 命令如果终端提示 command not found: setproxy，说明配置没有生效，执行一下  source ~/.bashrc 即可。\n","plink":"https://fiteen.top/set-up-SOCKS5-or-HTTP-proxy-for-Git-on-Mac/"},{"title":"借助 Safari 调试苹果手机上的 webView","date":"2018-07-25T07:21:07.000Z","date_formatted":{"ll":"Jul 25, 2018","L":"07/25/2018","MM-DD":"07-25"},"updated":"2019-12-04T12:06:24.695Z","content":"iPhone 真机/模拟器设置需要如下图所示，点击“设置” → 点击 “Safari 浏览器” → 点击“高级” → 打开“Web 检查器”。\n\n\n\n\n若模拟器中无“Web 检查器”选项，无需设置。\nSafari 设置打开 Mac 电脑中的 Safari 浏览器，打开偏好设置，点击菜单中的“高级”选项卡，勾选“在菜单栏中显示“开发”菜单”\n\n\n进入检查器在手机/模拟器中打开浏览器/App中的某个网页，在 Mac 中打开 Safari，在“开发”中找到目标设备。\n\n\n\n如果你选择的是模拟器，但是开发列表中未出现，重启 Safari 即可。因为必须确保先打开模拟器，再打开 Safari。\n\n点击目标设备中需要查看的网址，便会弹出这个页面对应的检查器。\n","plink":"https://fiteen.top/debug-webView-on-your-iPhone-with-Safari/"},{"title":"App Store 审核经验","date":"2018-06-14T07:56:22.000Z","date_formatted":{"ll":"Jun 14, 2018","L":"06/14/2018","MM-DD":"06-14"},"updated":"2019-12-04T12:31:48.115Z","content":"相关资料审核指南\n《App Store 审核指南》 \n《苹果开发者计划许可协议》\n\n\n\n苹果官方会不定期更新 Guidelines 和 PLA，请及时关注。\n关键概念\niTunes Connect\niTunes Connect 是一套以网页为基础的工具，用于管理在 App Store 上销售的面向 iPhone、iPad、Mac、Apple Watch、Apple TV 和 iMessage 的 app；同时也用于管理 iTunes Store 和 iBooks Store 上的内容。开发者通过 iTunes Connect 提交和管理 app，邀请用户使用 TestFlight 进行测试，添加税务和银行信息，以及访问销售报告等。\n\n元数据\n元数据指的是 iTunes Connect 中输入的 App 信息和平台版本信息——例如，App 名称、描述、关键词和屏幕快照。此信息的部分显示在 App Store 产品页面，并且可以被本地化。\n\n二进制文件\n包含在 ipa 包中的一个可执行文件，提审时需重点检查包括但不限于 info.plist、包／文件大小、icon 规格、私有 API、第三方 SDK、64位等内容。\n\n\n审核状态开发者在审核过程中需要特别关注的两个 App 状态为：\n\n正在等待审核（Waiting For Review）\n您已经提交了一个新的 App 或者更新了一个版本。Apple 已经收到了您的 App 但还没有开始审核。在该状态下可以： \n\n将构建版本从审核中移除\n编辑某些 App 信息\n\n\n正在审核（In Review）\nApple 正在审核您的 App。您可以将构建版本从审核中移除。\n\n\n一般这两个过程都会在24-48小时内完成，即从你提交到审核完成正常应在2天内结束，App 首次提交除外。\n当 App 被拒超过三次，“正在等待审核”过程会延长，极有可能持续一周；若未按照苹果的要求操作，可能被拉入黑名单，“正在审核”过程无限延长。\n近期被拒案例及应对措施账号资质问题对于监管敏感的行业和应用，App Store 的审核会更为苛刻。这类案例主要体现在理财、借贷、医疗类的 App，相关的应对方法有：\n\n证明你的公司，有提供相关资质。\n如果 App 的公司主体具备资质，直接讲资质证明（如营业执照、政府背书）发给苹果审核团队；若不具备，需要将 App 放在有资质的公司主体的账号下提交。\n如果苹果审核团队方面对 App 的性质存在误解，提供相关证明并及时沟通。\n\n如果是个人开发者账号提交的应用，须升级为企业开发者账号后再提交。\n\n如果是其他开发者账号（比如外包）替你开发，须将其他开发账号添加到你的苹果开发者账号下（在“用户和职能-添加iTunes Connect用户”操作）。\n\n尽可能体现 App 产品与公司品牌的关联性，包括但不限于以下几点：\n\nApp 名称的择定\n在 App 的“关于我们”中，中英文介绍公司\n提交“软件著作权登记证书”，或者“商标证书”\n向苹果审核团队阐述 App 功能的运营主体、技术支持网站等\n\n\n设置开关，将敏感内容在审核期间隐藏，审核过后再显示。但近期苹果已经发现这一现象，会不定期抽查过审应用。这种做法也有被竞争对手举报的可能，一旦被查到可能面临被直接下架的风险。\n\n\n元数据不规范2018年伊始，苹果爸爸就抛出了重磅炸弹——苹果2.1狗年大礼包。我们需要对照元数据规范对本地信息进行修改和调整。\n如果不需要更新 ipa 包，可以直接在被拒信息下面回复，明确告知对方：App 不存在这些问题或者我们已经对相关资源和功能作出了调整，请重新审核。切勿不沟通，直接重新提包，会被苹果认定默认存在大礼包中提及的问题。\niTC 中在上传屏幕快照时，以 5.5 寸为基准，条件允许时，为不同机型定制不同的屏幕快照更佳。\n内购订阅、游戏内货币、游戏关卡、课程、会员等非实物交换类的虚拟物品，必须且只允许走内购渠道。此外，需要注意以下几点：\n\n支付页面不能使用网页作为载体，苹果会认为存在变更支付方式的可能\n类别（如消耗型/非消耗性、自动续订/非续订）需要选择正确\n提高产品审核通过率，iTC 中信息尽可能补充完整\n\n隐私在 Apple 生态体系中，保护用户隐私总是第一要务。当需要访问用户的相册、相机、通讯录、位置、日历等，App 描述中应当注明 app 会要求访问哪些内容类型 (例如，位置、通讯录和日历等)，并说明当用户不授予许可时，app 的哪些功能会无法正常工作。\n如何提高过审速度沟通原则\n尊重\n回复时称对方为审核员，沟通过程中保持严肃、友好、认同的态度，对给出任何审核结果表示感谢。\n\n积极\n及时主动告知审核员我方的处理进度。中英文表达皆可，面对积极回复且礼貌的开发者，审核人员更愿意给出直接的意见。\n\n\n以往经验\nIn Review 状态不要手动撤回，可能会导致后续审核速度变慢。\n对被拒原因不认可，可以直接在被拒消息后申诉。即使回复后直接重新提交新版本，审核员也会看到消息，可以在消息中告知，已经按照要求进行修改，这种情况下苹果的处理效率会高一些。\n处理当前的审核结果一般是同一个审核员，提审后及时查看审核状态，一旦被拒及时回复，可以得到尽可能快对回应和处理。\n提审之前，请先反复检查，避免低级问题或常见问题遗漏到苹果审核人员手中。若连续审核通过，后续审核速度会越来越快，反之，若连续被拒极有可能进入黑名单，审核速度越来越慢。\n遇到竞争对手侵权可以向苹果投诉，但不要多人重复投诉，不然可能会拉长处理时间。\n\n","plink":"https://fiteen.top/App-Store-review-experience/"},{"title":"Mac 下避免 rm 引发的血案","date":"2018-04-12T13:53:11.000Z","date_formatted":{"ll":"Apr 12, 2018","L":"04/12/2018","MM-DD":"04-12"},"updated":"2019-12-05T03:27:54.029Z","content":"习惯使用终端的用户，常会用 rm -fr 命令执行删除操作，但是这种删除的方式不会出现在废纸篓中，一旦误删，要想找回就比较麻烦。近期听说的此类血案也比较多，为了避免造成悲剧，推荐使用 trash 命令来执行删除。\n\n\n安装 trash通过 Homebrew 安装 Trash\n1$ brew install trash\n\n安装成功后，可以通过 trash -fr filename命令删除文件，且文件会移到废纸篓中。\n用 trash 替换 rm 命令打开 ~/.bash_profile 文件\n1$ vim ~/.bash_profile\n\n在文件中加入以下代码后保存文件：\n1alias rm&#x3D;&quot;trash&quot;\n\n使命令生效：\n1$ source ~/.bash_profile\n\n这时执行 rm 命令，被删除的文件就会存放在废纸篓中了，废纸篓里的文件虽无法执行“放回原处”的方法，但可以通过鼠标拖拽恢复。\n","plink":"https://fiteen.top/avoid-rm-induced-bloody-cases-under-Mac/"},{"title":"iOS 中 framework 和 bundle 的制作","date":"2018-01-05T05:57:10.000Z","date_formatted":{"ll":"Jan 5, 2018","L":"01/05/2018","MM-DD":"01-05"},"updated":"2019-12-05T03:39:33.626Z","content":"FrameworkFramework 是资源的集合，将静态库和其头文件包含到一个结构中，让 Xcode 可以方便地把它纳入到你的项目中。\n\n\n在运行时，库中按你的想法暴露需要的头文件，整个工程都可以调用暴露出来的接口和参数，这样减少了内存消耗，提高了系统的性能。\n为什么使用 framework与别人分享自己开发的组件，有两种方式。\n\n直接提供源代码。\n将组件代码编译成静态库，供他人调用。\n\n第一种方式容易被人看到具体实现的细节，这些可能是你不想暴露出来的。此外，开发者也可能并不想看到你的所有代码，而仅仅是希望将功能的一部分植入到自己的应用中。\n因此很多组件的封装采用第二种方式，这也是下文介绍的主要内容。\n配置静态库工程步骤1：打开 Xcode ，Create a new Xcode project →  iOS →  Cocoa Touch Framework，在 Product Name 中填写名称。（注：这就是最后 framework 的名称。）\n步骤2：假如你的项目依赖某些系统库，那么需要通过点击 Targets → Build Phases →  Link Binary with Libraries ，点击 + 号将它们添加到工程中。\n步骤3：修改 Project 中的 iOS Deployment Target 版本号，选择你的框架最低支持的 iOS 版本。\n步骤4：如果组件中存在 xib 文件，请确保 TARGETS→  Build Phases →  Copy Bundle Resources 下存在该 xib 文件。\n步骤5：将封装好的组件文件夹拖入到项目目录下，选择你要公开的头文件。\n步骤6：点击 TARGETS →  Build Phases →  Headers，目录下有：\n\nPublic : 存放公开的头文件，给外部调用。\nPrivate : 存放私有的 Header，但头文件在编译之后还会存在。一般用来存放项目中需要调用但又不想给别人看到其内部实现的文件。\nProject : 隐藏的文件。\n\n导出 framework选中 Scheme 选择当前项目，然后右边设备依次选中 Generic iOS Device（通用真机版本）和任一模拟器，分别编译（command + B），成功将会自动跳转到打出的 .framework 文件相应的目录下。\n合成 framework为了让用户能统一调用一个 framework ，还需要将二者合成为一个 framework 。这里介绍一种简单的方法：\n\n新建一个 target，依次点击TARGETS 左下角的加号按钮 → Cross-platform →  Other 下的 Aggregate。\n\n点击工程文件，选 TARGETS →  刚才创建的 Aggregate →  Build Phases →  + →  New Run Script Phases。在当前栏目里会多出一个 Run Script ，在里面输入以下脚本：\n\n\n1#!/bin/sh2#要build的target名3TARGET_NAME=$&#123;PROJECT_NAME&#125;4if [[ $1 ]]5then6TARGET_NAME=$17fi8UNIVERSAL_OUTPUT_FOLDER=\"$&#123;SRCROOT&#125;/$&#123;PROJECT_NAME&#125;/\"910#创建输出目录，并删除之前的 framework 文件11mkdir -p \"$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;\"12rm -rf \"$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework\"1314#分别编译模拟器和真机的 framework15xcodebuild -target \"$&#123;TARGET_NAME&#125;\" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphoneos BUILD_DIR=\"$&#123;BUILD_DIR&#125;\" BUILD_ROOT=\"$&#123;BUILD_ROOT&#125;\" clean build16xcodebuild -target \"$&#123;TARGET_NAME&#125;\" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphonesimulator BUILD_DIR=\"$&#123;BUILD_DIR&#125;\" BUILD_ROOT=\"$&#123;BUILD_ROOT&#125;\" clean build1718#拷贝 framework 到 univer 目录19cp -R \"$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework\" \"$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;\"2021#合并 framework，输出最终的 framework 到 build 目录22lipo -create -output \"$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;\" \"$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;\" \"$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;\"2324#删除编译之后生成的无关的配置文件25dir_path=\"$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/\"26for file in ls $dir_path27do28if [[ $&#123;file&#125; =~ \".xcconfig\" ]]29then30rm -f \"$&#123;dir_path&#125;/$&#123;file&#125;\"31fi32done33#判断 build 文件夹是否存在，存在则删除34if [ -d \"$&#123;SRCROOT&#125;/build\" ]35then36rm -rf \"$&#123;SRCROOT&#125;/build\"37fi38rm -rf \"$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator\" \"$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos\"39#打开合并后的文件夹40open \"$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;\"\n然后使用脚本进行编译 (command + B)，成功后将会自动跳转到打出的 .framework 文件相应的目录下。\n查看是否成功步骤1：打开终端，进入到你的 framework \n1cd $&#123;yourFrameworkName&#125;.framework文件所在的目录\n\n步骤2：查看架构支持\n1lipo -info $&#123;yourFrameworkName&#125;.framework/$&#123;yourFrameworkName&#125;\n\n于是可以看到输出：\n1Architectures in the fat file: $&#123;yourFrameworkName&#125; are: i386 x86_64 armv7 arm64 (支持的架构显示在这)\n\n*设备的CPU架构(指令集) *\n\n模拟器\ni386: 针对 intel 通用微处理器32架构，如 iPhone 4s-5:\nx86_64: 针对 x86 架构的64位处理器\n\n\n真机\narmv6: iPhone、iPhone 2、iPhone 3G、iPod 1G/2G（Xcode4.5起已不再支持armv6）\narmv7: iPhone 3Gs、iPhone 4、iPhone 4s、iPod 3G/4G/5G、iPad、iPad 2、iPad 3、iPad Mini\narmv7s: iPhone 5、iPhone 5c、iPad 4\narm64: iPhone 5s、iPhone 6(Plus)、iPhone 6s(Plus)、iPad Air(2)、Retina iPad Mini(2,3)\narm64e:  iPhone XS\\XR\\XS Max\n\n\n\n引入 framework 的注意事项引入的 framework 里存在分类的话，编译运行项目会报形如 xxx unrecognized selector sent to class xxx 的错误。\n*解决办法： *\n选中左边栏的项目文件，然后依次点击 Targets →  Build Settings →  Linking →  Other Linker Flags，在里面添加 -ObjC 再次编译就能正常运行。\n补充知识：\n从 C 代码到可执行文件经历编译步骤是：源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件。\n在最后一步需要把 .o 文件和 C 语言运行库链接起来，这时需要用到 ld 命令。源文件经过一系列处理后，会生成对应的 .obj 文件，一个项目必然会有多个 .obj 文件，并且这些文件之间存在各种联系，如函数调用等。链接器做的事就是把目标文件和所用的一些库链接在一起形成一个完整的可执行文件。Other Linker Flags 设置的值实际上就是 ld 命令执行时后面所加的参数。下面介绍3个常用参数：\n\n\n\n参数\n描述\n\n\n\n-ObjC\n链接器会把静态库中所有的 Objective-C 类和分类都加载到最后的可执行文件中\n\n\n-all_load\n链接器会让所有找到的目标文件都加载到可执行文件中\n\n\n-force_load\n需要指定要进行全部加载的库文件的路径\n\n\n注意：千万不要随便使用 -all_load 这个参数！假如你使用了不止一个静态库，然后又使用了这个参数，那么很有可能会遇到 ld: duplicate symbol 错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到 -ObjC 失效的情况下使用 -force_load 参数。\nBundle什么是 bundleBundle 可以理解为一个目录，并包含了程序中会用到的资源，如图像、声音、编译好的代码或 nib 文件等。\n创建 bundleBundle 创建有两种方式：\n\n简单的创建 bundle\n创建一个文件夹，强制重命名该文件夹为 yourBundleName.bundle。\n\n通过 Xcode 创建 bundle\n\n新建一个项目，依次 TARGETS →  + →  mac OS → Framework &amp; Library →  Bundle，输入 Product Name 即建立出 bundle 工程；\n\n在 bundle 目录下添加需要的资源文件，编译之后在整个项目工程的 Products 文件夹下得到资源文件 bundle 。\n这样做默认情况下 bundle 里面的 png 图片会被转为 tiff 的格式。因此在编译前需要做一步设置：找到 bundle 的工程，修改：Build Settings →  COMBINE_HIDPI_IMAGES，设置为 NO 之后再编译运行。\n\n\n\n\n","plink":"https://fiteen.top/making-frameworks-and-bundles-in-iOS/"},{"title":"『2017』去年今日此门中","date":"2017-12-31T03:59:02.000Z","date_formatted":{"ll":"Dec 31, 2017","L":"12/31/2017","MM-DD":"12-31"},"updated":"2019-12-04T12:27:40.149Z","content":"步入职场的第二年，做一个简单的总结：\n\n\n工作2017年在职业成长上的几点收获：\n\n年初，获得年度优秀员工\n年中，考出《系统集成项目管理工程师》证书\n年底，入职挖财\n\n考证准备了两三个月，看了好久教学视频，刷了厚厚的一沓题，感觉当初可以直接尝试一下高级证书的考试，怕准备时间不够就报了中级，也许对自己要求高一点，会得到更好的结果。\n接触地更多，才会发现外面的世界越精彩，进步的空间越大。无论什么年纪，都不能停止学习的脚步。每次看到小区外浙大的孩子们意气风发充满朝气的脸，越后悔自己当初没有更用功一点。因为原公司放弃了互联网医疗的项目，顺其自然地换了个工作环境，新公司的大佬很多，从分享会上会发现自己更多不足，我应该更努力地充实自己，无论是技术上还是性格上。\n生活这一年，在生活中遇到了一次严重的打击，堪称价值观的崩塌——朋友 L 插足了别人的家庭，成了一名第三者。我们做了大学四年的同寝室友，毕业后又合租了一年。这件事情确实令我相当震惊和难以接受，L 在我的认知里，是一个非常“神奇”的女孩：\n她家里条件不好，领助学补助。但她很大方，她会拿钱给五保户爷爷买水果，买东西也不还价，别人向她借钱也无二话，自己骑破烂二手自行车，却给初恋男友买死飞；\n她长相白皙清秀，也爱漂亮，对护肤品的消费意识比我们都超前，但头发总是油油腻腻，不怎么讲究卫生，还不愿换掉那件紧巴巴的起球毛呢外套和脏兮兮的发卡；\n她朋友很多，对谁都热情似火，助人为乐，甚至愿意牺牲自己和朋友的利益去成全一个刚认识不久的人的无理请求；\n她很信任别人，几乎无条件的信任，哪怕知道对方可能在骗人，依然说自己愿意相信一切是好的那面。\n也许这是她说服自己接受这个男人的理由，明知对方在老婆孕期出轨跟她交往，愿意相信他前言不搭后语的说辞。\n我很生气，也很难过，朝夕相处的人成为了第三者，她还有千万个理由说自己没有错。也许她真的是个善良的好姑娘，只是过于纯真，也许一切只是她手段高明的伪装。也许真的如她所说的那般，对方的妻子无比的坏，她是在拯救那个男人脱离苦海……\n也许是她变了，也许她一直没变，但无论怎样，我想我们再也做不了朋友了，几年的相识最后化作一抹悲凉。想起那句人们常说的话——愿你出走半生，归来仍是少年。可是去年今日此门中，已是回不去的记忆了。\n","plink":"https://fiteen.top/annual-summary-2017/"},{"title":"iOS 逆向分析之 class-dump","date":"2017-10-04T16:13:05.000Z","date_formatted":{"ll":"Oct 5, 2017","L":"10/05/2017","MM-DD":"10-05"},"updated":"2019-12-05T03:29:17.420Z","content":"class-dumpclass-dump 是一个命令行工具，通过利用 Objective-C 语言的 runtime 特性，提取存储在 Mach-O 文件中的类文件、协议、分类等信息，并统一表现在 .h 头文件中。\n\n\n安装\n下载 class-dump-3.5.dmg（若链接无效，请戳官方网址）\n\n打开终端，输入\n1open /usr/local/bin\n\n将下载拿到的 class-dump 拷贝到 /usr/local/bin 目录下\n\n赋予其可执行权限，终端输入:\n1sudo chmod 777 /usr/local/bin/class-dump\n\n至此安装成功，并可以通过 class-dump --help 查看用法和版本\n\n\n使用\n下载一个 ipa 文件，先将文件改为 zip 格式，解压后得到 .app 的目标文件\n终端输入命令，格式为 class-dump -H [.app文件路径] -o [输出文件夹路径]\n假如此时输出的文件中未得到目标的 .h，结果中什么都没有或者只有一个 CDStructures.h，说明需要砸壳\n\ndumpdecrypted从 AppStore 下载安装的 App 被苹果默认加了一层壳，需要通过砸壳进行逆向分析。\n工具\ndumpdecrypted.dylib\n\n下载\n\n编译安装\n1、在终端进入下载的解压文件的目录：\n1cd [dumpdecrypted-master's filePath]\n\n2、执行 ls 里面存在三个文件：Makefile、README、dumpdecrypted.c\n3、执行 make ，在当前目录下会多出 dumpdecrypted.dylib 和 dumpdecrypted.o，前者就是我们需要的工具\n\n\n\n一台越狱手机\n\n\n操作步骤使用越狱手机前往 AppStore 下载目标 App 并打开。\n1. 使用 ssh 连接手机1.1 越狱手机和电脑连同一个 wifi，查看手机所处当前网络的 IP 地址，打开终端 A，输入指令：\n1ssh root@[手机当前网络的 IP 地址]\n\n1.2 通过命令ps -e找到目标 App 对应的进程，如果该 App 为当前打开的应用，可以关注最下面的几条进程，形如：\n1[进程号] ??         [时间] [目标 App 在手机中路径]\n\n路径形如 \n/var/mobile/Containers/Bundle/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xx.app/xx\n将其记录下来备用。\n1.3 附加进程指令：cycript -p [进程号]\n获取 App 在沙盒 Documents 的路径：\n1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]\n\n路径形如：/var/mobile/Containers/Data/Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents\n将其记录下来备用。\n2. 注入 dumpdecrypted.dylib2.1 新开终端 B（可使用快捷键 command + T）\n2.2 使用 scp 指令将 dumpdecrypted.dylib 拷贝到目标 App 的 Documents 目录下。\n指令为：\n1scp [dumpdecrypted.dylib 所在的完整路径] root@[手机当前网络的 IP 地址]:[目标 App 在手机中路径]\n\n终端会提示输入密码，默认为 alpine。\n3. 砸壳3.1 回到终端 A，cd  进入步骤 1.3 中 App 在沙盒 Documents 的路径\n3.2 执行如下指令：\n1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib [步骤 1.2 中目标 App 在手机中路径]\n\n3.3 执行 ls 指令查看当前目录下是否有 .decrypted 的文件来确定砸壳是否成功\n4. class-dump 导出 App 头文件4.1 回到终端 B，将.decrypted 文件拷贝到电脑目录下，指令为：\n1scp root@[手机当前网络的 IP 地址]:[步骤 1.3 中App 在沙盒 Documents 的路径]/WeChat.decrypted [自定义的电脑目录]\n\n终端会提示输入密码，默认为 alpine。\n4.2 通过如下指令获取目标 App 的所有头文件\n1class-dump -s -S -H --arch [指令集] [步骤 4.1 中的.decrypted 文件路径] -o [自定义的输出目录]\n\n指令集需对应当前越狱手机的型号，参考下表：\n1armv6：iPhone | iPhone2 | iPhone3G2armv7：iPhone3GS | iPhone4 | iPhone4S3armv7s：iPhone5 | iPhone5C4arm64：iPhone5S | iPhone6 | iPhone6Plus | iPhone6S  | iPhone6SPlus | iPhone7 | iPhone7Plus | iPhone8 | iPhone8Plus | iPhoneX\n","plink":"https://fiteen.top/class-dump/"},{"title":"iOS 自动布局进阶之巧用 IBInspectable 和 IB_DESIGNABLE","date":"2017-08-24T02:33:20.000Z","date_formatted":{"ll":"Aug 24, 2017","L":"08/24/2017","MM-DD":"08-24"},"updated":"2019-12-05T03:34:34.331Z","content":"交互设计和 UI 设计水准很大程度影响着用户对应用的评价，iOS 开发发展至今已逾10年，开发者对于界面 UI 编码的习惯逐渐分化成三大流派：\n\n\n\ncode - 易追踪、可复用、便于版本控制，但不直观\nxib - 简单便捷、直观、一一对应，但易冲突\nstoryboard - 逻辑清晰、简单易用、直观高效，虽易冲突、复用性不佳，但仍是未来趋势\n\nxib 和 storyboard 均采用了 Interface Builder（IB）来生成 GUI，通过面板上简单的拖拽替代繁琐冗余的 code 来构建页面。但我们经常发现，既有的功能并不能完全满足布局的需要，那么，我们可以通过在特定的位置定义可视化属性 IBInspectable、定义宏 IB_DESIGNABLE 来精简代码。\n下文具体介绍一下如何使用。\n\n【场景】设置按钮：圆角cornerRadius：8pt、边框颜色borderWidth：1pt、边框宽度borderColor：系统蓝色\n\n\n巧用 IBInspectable【IBInspectable】 这一属性提供了访问功能的新方式：用户自定义的运行时属性，让支持 KVC 的属性能够在身份检查器（Identity Inspector）的 User Defined Runtime Attributes 中配置。\n它支持修饰的属性类型有：\nBOOL、NSNumber、CGPoint、CGSize、CGRect、UIColor、NSString、NSLocalizedString、NSRange、UIImage、NSNull。\n如果想让特定类型的控件设置某个属性，可以为对应的 UIKit 添加分类，为定义该属性时加上 IBInspectable，示例：\n1#import &lt;UIKit&#x2F;UIKit.h&gt;23@interface UIButton (HTAdditions)45@property (nonatomic) IBInspectable CGFloat kCornerRadius;6@property (nonatomic) IBInspectable CGFloat kBorderWidth;7@property (nonatomic,copy) IBInspectable UIColor *gBorderColor;89@end\n\n这时 Xcode 的 Attributes Inspector 栏中就会出现三个新的可编辑属性。\n\n\nIdentity Inspector 下的 User Defined Runtime Attributes 也会出现相应的 key path 和 value 值。\n\n\n设置好后 run 一下工程就能看到场景中要求的效果，但通常开发者不需要所有的按钮都设置圆角、边框，更多的是采用自定义视图的形式统一处理相似风格的 control。为了更高效地开发，接下来介绍宏定义 IB_DESIGNABLE。\n\n巧用 IB_DESIGNABLE【IB_DESIGNABLE】 在类名前加上此宏定义，初始化、布置和绘制方法将被用来在画布上渲染该类的自定义视图。\n操作步骤：\n\nstoryboard 中拖拽一个 UIButton；\n创建父类是 UIButton 的 HTCustomButton 类文件，并在 .h 的 interface 前定义 IB_DESIGNABLE；\n给步骤1按钮的 Custom Class 关联上 HTCustomButton。\n\n这时我们就可以直接在 User Defined Runtime Attributes 中加入想要的属性，例如圆角、边框宽度等。边框颜色由于 UIColor 类型的特殊性，需要重新定义。\nHTCustomButton.h：\n1#import &lt;UIKit&#x2F;UIKit.h&gt;23IB_DESIGNABLE45@interface HTCustomButton : UIButton67&#x2F;** 设置边框颜色可视化 *&#x2F;8@property (nonatomic, strong)IBInspectable UIColor *customBorderColor;910@end\nHTCustomButton.m：\n1#import &quot;HTCustomButton.h&quot;23@implementation HTCustomButton45&#x2F;**6 *  设置边框颜色7 *8 *  @param customBorderColor 可视化视图传入的值9 *&#x2F;10- (void)setCustomBorderColor:(UIColor *)customBorderColor &#123;11    self.layer.borderColor &#x3D; customBorderColor.CGColor;12&#125;1314@end\n设置好后就可以直接添加或修改相应的属性动态刷新控件，如下图：\n\n\n\n纯代码开发流派如何借助 IB_DESIGNABLE动态查看布局效果对于很多被强制勒令用纯代码 coding 的开发者来说，下面介绍的干货绝对会大大提升开发效率。\n举个例子：创建基于 UIView 的 HTMasonryView，以及同名的 .xib 文件，并在 Custom Class 中关联好。接下来在 HTMasonryView.m 中创建并布局 masonryButton，注意添加 IB_DESIGNABLE，代码如下：\n1#import &quot;HTMasonryView.h&quot;2#import &lt;Masonry.h&gt;3#import &quot;UIButton+HTAdditions.h&quot;45IB_DESIGNABLE67@interface HTMasonryView ()89@property (nonatomic, strong) UIButton *masonryButton;1011@end1213@implementation HTMasonryView1415- (instancetype)initWithFrame:(CGRect)frame &#123;16    if (self &#x3D; [super initWithFrame:frame]) &#123;17        [self setupView];18    &#125;19    return self;20&#125;2122-(instancetype)initWithCoder:(NSCoder *)aDecoder &#123;23    if (self &#x3D; [super initWithCoder:aDecoder]) &#123;24        [self setupView];25    &#125;26    return self;27&#125;2829- (void)setupView &#123;30    _masonryButton &#x3D; (&#123;31        UIButton *btn &#x3D; [UIButton buttonWithType:UIButtonTypeSystem];32        btn.kCornerRadius &#x3D; 8.0f;33        btn.kBorderWidth &#x3D; 1.0f;34        btn.gBorderColor &#x3D; btn.ht_normalTitleColor;35        btn.ht_normalTitle &#x3D; @&quot;code创建-Masonry布局的按钮&quot;;36        btn.titleLabel.font &#x3D; [UIFont systemFontOfSize:14.0f];37        [self addSubview:btn];38        btn;39    &#125;);40    [self layout];41&#125;4243- (void)layout &#123;44    __weak __typeof(self) weakSelf &#x3D; self;45    [_masonryButton mas_makeConstraints:^(MASConstraintMaker *make) &#123;46        make.left.mas_equalTo(30);47        make.right.mas_equalTo(-30);48        make.top.bottom.mas_equalTo(weakSelf);49    &#125;];50&#125;5152@end\n点开 HTMasonryView.xib 查看会发现已经渲染出了 Masonry 的布局效果。\n\n\nps：如果渲染失败，查看 Editor -&gt; Automatically Refresh Views 是否勾选，尝试重启 Xcode。\n开启成功的特点就是 Show the Identity inspector-&gt;Custom Class-&gt;Designables:Up to date(更新完毕)/Updating(更新中)，如果显示 Build failed 建议检查布局代码。\n\n欢迎评论，最后-&gt; Demo传送门\n","plink":"https://fiteen.top/how-to-use-IBInspectable-and-IB-DESIGNABLE/"},{"title":"iOS 购物车设计模式浅析及代码实现","date":"2017-08-17T01:03:04.000Z","date_formatted":{"ll":"Aug 17, 2017","L":"08/17/2017","MM-DD":"08-17"},"updated":"2019-12-05T03:35:26.329Z","content":"前言早期以淘宝为代表的C2C网站以“入驻店铺”模式强势打破了纯线下的商品交易格局，而近年来，通过不断的尝试与改进，各大电商平台也趋于成熟并自成体系。以京东、聚美优品、网易考拉海购、唯品会、小红书为代表B2C平台也以“自营+入驻店铺”的垂直销售模式进入消费者的视野。但也有不少企业和商家为了避免缴纳高额的入驻保证金和平台年费等，选择开发自己的商城App产品，也就是“自营”模式。\n\n\n购物车作为大多数商城中不可或缺的部分，其逻辑和设计往往也取决于商城本身的交易模式与商品的性质。以美团外卖、饿了么为例，作为一个主张快捷消费产品，加上配送的问题，跨店购物的模式显然不适用它，因此购物车的入口并不在一级菜单下，而是在每家店铺商品列表底部。其购物车显示的内容也相对简单，只需包括已选商品信息（名称、价格、数量、增减按钮）、餐盒费、配送费、总价即可。而对于一个功能完善的商城来说，购物车的逻辑显然会复杂许多，下文中将模仿淘宝购物车的需求，对逻辑功能进行整理和编码。\n基本需求设计1、购物车入口\na）点击App底部菜单的购物车TabbarItem进入\n\n\nb）从商品详情页的购物车按钮进入\n\n这里要注意区分购物车列表高度的问题。\n2、店铺分区当商城支持跨店购物，那么购物车内的所有商品需要按照不同的店铺分区显示，这个分类逻辑的步骤通常由后端完成，我们iOS端只需获取输出的数据在tableView中展示即可。店铺信息在section的headerView中展示，另外还会显示一个店铺选择按钮。\n3、商品cell中展示的信息我们通常将商品cell分为normal、edit两类状态，当然商品信息比较简单的情况下，也可以选择只有Edit状态。购物车中显示的商品信息包括：\n\n1）商品基本信息（展示图片、名称、规格、选择数量、价格（或现价、原价））\n\n\n2）限购信息/降价信息\n\n\n3）购物券满减信息、凑单按钮、活动标志（如狂欢节等）\n\n\n4）选择按钮\n\n\n5）其他\n\n以上信息在显示的时候遵从一定上下顺序，cell的布局会根据以上信息的有无适当调整。\n4、底部核算界面底部界面上功能比较明确——全选按钮、合计标签、结算按钮。\n这部分的关键在于，合计价格和全选按钮的状态都会表单上面的商品选中情况变化。下文中将会分析一下其中的逻辑。\n5、商品的增删改\n商品的添加：1）从商城中添加；2）在购物车列表中增加。添加时需要考虑购物车列表是否已有相同的或是相同店铺的商品。\n\n\n商品的删除：1）normal 状态下侧滑删除；2）点击编辑按钮进入edit 状态，点击删除按钮；3）点击右下角的批量删除。\n\n\n商品的修改：1）批量编辑修改；2）店铺编辑修改。修改内容包括商品数量和规格。\n\n以上五条涵盖了购物车的基本的功能需求，根据业务需要自行拓展。\n\n\n解决思路1、单选/店铺选择/全选联动模式解决思路：\ni）将全选按钮标记为A；\nii）购物车中m个店铺的选中按钮一次标记为A(0),A(1),...,A(m-1)；\niii）第x家店铺（x∈(0,m-1)）下的n个商品的选中按钮依次标记为A(x,0),A(x,1),...,A(x,n-1)。\n那么：\nA(x,0),A(x,1),...,A(x,n-1)全部选中可推导出A(x)选中；\nA(0),A(1),...,A(m-1)全部选中可以推导出A选中。\n点击某商品选择按钮A(m,n)的伪代码如下：\n12A(m,n).selected &#x3D; !A(m,n).selected;34BOOL shopAllChoose &#x3D; YES;56for (int i &#x3D; 0; i &lt; n; i++) &#123;78        shopAllChoose &amp;&#x3D; A(m,i).selected;910&#125;1112A(m).selected &#x3D; shopAllChoose;1314BOOL allChoose &#x3D; YES;1516for (int j &#x3D; 0; j &lt; m; j++) &#123;1718        allChoose &amp;&#x3D; A(j).selected;1920&#125;2122A.selected &#x3D; allChoose;\n\n点击某店铺全选和所有商品全选的代码原理相似。\n2、编辑模式购物车设计中，出现两类编辑按钮：\n\n① 导航栏上的全选编辑\n\n\n② 每个section右上角的批量编辑\n\n点击①类按钮，①文本变为“完成”，同时②类按钮隐藏，所有的cell进入edit 状态；\n点击②类按钮，当前按钮文本变为“完成”，该section下所有cell进入edit 状态。\n修改商品数量可以通过加减按钮，也可以通过手动输入修改。当然，修改前需要对当前的数量做出判断，是否还能进行加减，或是输入的数据是否合理，如出现限购信息等。\n由于整个购物车的逻辑关系比较多，我们可以考虑将这部分功能单独放在一个UIView中处理，数量变化的具体实现可借鉴PPNumberButton。\n3、删除模式除了上文提到的edit 状态下点击删除按钮以外，还有一种就是在normal 状态左滑删除。\n\n\n\n\ncell在normal 状态时可以左滑删除，而在edit 状态下点击删除，要在下面方法中做出return YES/NO;的判断和区分。\n1- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath &#123;&#125;\n假如要自定义删除键，可以在UITableViewRowAction初始化时在title的定义部分，使用多个空格作为占位符，然后在layoutSubviews中找到cell图层上的UITableViewCellDeleteConfirmationView层添加上新定义的删除键。\n点击navigationItem上的“编辑”后，结算按钮变成删除按钮，可以对选中的商品进行删除，由于是店铺模式的存储形式，需要对模型的更新时机进行区分。\n4、总价计算总价计算公式很简单： 总价=Σ选中的商品的数量 * 选中的商品的单价\n但这个公式中存在两个变化量，一个是“是否选中”，一个是“数量”，也就是说总价刷新出现在以下场景：\n\n有商品的选中状态发生了改变： 点击了单选/店铺选择/全选按钮\n\n\n有选中的商品的数量发生改变：点击了增加/减少或者编辑了数量文本\n\n\n欢迎评论，最后-&gt; Demo传送门\n","plink":"https://fiteen.top/iOS-shopping-cart-design-pattern-analysis-and-code-implementation/"},{"title":"阿里云直播鉴权算法","date":"2017-06-29T02:30:49.000Z","date_formatted":{"ll":"Jun 29, 2017","L":"06/29/2017","MM-DD":"06-29"},"updated":"2019-12-05T03:40:41.130Z","content":"\n阿里云官方给出的文档：用户指南-直播鉴权\n\n\n\n参数描述要配置出正确的鉴权，需要明确以下几个参数：\n推流地址\n完整的推流地址，形如：\nrtmp://video-center.alivecdn.com/{AppName}/{StreamName}?vhost={yourdomain}\n鉴权类型\n阿里云CDN 兼容并支持 A、B、C 三种鉴权方式，具体见 URL 鉴权方式。这里选择的是 A 类型\n鉴权KEY\nprivatekey 字段用户可以自行设置\n时间戳\n时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。\n有效时间\n以秒为单位的整数时间，用来控制直播推流时效\n鉴权方法 用户访问加密 URL ：\n\nrtmp://video-center.alivecdn.com/{AppName}/{StreamName}?vhost={yourdomain}&amp;auth_key={timestamp}-{rand}-{uid}-{hashvalue}\n\n\n\n\nauth_key字段\n描述\n\n\n\ntimestamp\n失效时间=时间戳+有效时间，CDN 服务器拿到请求后，首先会判断请求中的失效时间是否小于当前时间，如果小于，则认为过期失效并返回 HTTP 403 错误。\n\n\nrand\n随机数，一般设成0\n\n\nuid\n暂未使用（设置成0)\n\n\nhashvalue\n通过 md5 加密算法计算出的32位验证串\n\n\nhashvalue 计算方式如下：\n\nsstring = /{AppName}/{StreamName}-{timestamp}-{rand}-{uid}-{privatekey}hashvalue = md5(sstring)\n\n输入OBS中的鉴权内容如下：\n\nrtmpURL：rtmp://video-center.alivecdn.com/{AppName}流密钥：{StreamName}?vhost={yourdomain}&amp;auth_key={timestamp}-{rand}-{uid}-{hashvalue}\n\n","plink":"https://fiteen.top/algorithm-of-Ali-cloud-live-authentication/"},{"title":"iOS 中 atomic 和 nonatomic 的区别","date":"2017-04-08T14:51:03.000Z","date_formatted":{"ll":"Apr 8, 2017","L":"04/08/2017","MM-DD":"04-08"},"updated":"2019-12-04T12:17:23.490Z","content":"nonatomic（非原子性） 和 atomic（原子性） 是 iOS 开发中用 @property 声明属性时，常用的两个关键字。\n\n\n看下面三种属性的声明方式：\n1@property(nonatomic, retain) UITextField *name;2@property(atomic, retain) UITextField *name;3@property(retain) UITextField *name;\n\n2、3 的意思是一样的，不写的时候默认声明成 atomic。\n内部实现如苹果官方文档中描述的那样，它们系统生成的存取方法是不一样的：\nnonatomic 对象的存取方法实现如下：\n1- (UITextField *) name &#123;2    return _name;3&#125;45- (void) setName:(UITextField *)name &#123;6    if (_name !&#x3D; name) &#123;7    \t[_name release];8    \t_name &#x3D; [name retain];9    &#125;10&#125;\n\n而系统为 atomic 对象生成的存取方法会进行加锁：\n1- (UITextField *) name &#123;2    UITextField *res &#x3D; nil;3    @synchronized(self) &#123;4        res &#x3D; [[_name retain] autorelease];5    &#125;6    return res;7&#125;89- (void) setName:(UITextField *)name &#123;10    @synchronized(self) &#123;11    \tif (_name !&#x3D; name) &#123;12      \t    [_name release];13      \t    _name &#x3D; [name retain];14    \t&#125;15    &#125;16&#125;\n\n线程安全atomic 可以保证 setter 和 getter 操作不受其它线程影响，因为锁的缘故，能够优先执行完当前操作：\n\n线程 A 的 setter 进行到一半，线程 B 调用了 getter，那么会执行完 setter 再执行 getter，线程 B 还是能得到线程 A setter 后完好无损的对象。\n\n那么它能保证整个对象就是线程安全的吗？\n答案是并不能，当几个线程同时调用 setter/getter 时，能得到一个完整的值，但这个值无法确定，举个例子：\n\n线程 A 调了 getter，与此同时线程 B、C 调了 setter，那么 A 最后 getter到的值，可能是\n\nB、C 未 setter 之前的原始值\nB setter 后的值\nC setter 后的值\n\n\n除了存取之外，线程安全还有其它的操作，比如：\n\n线程 A 正在 getter/setter 时，线程 B 同时进行 release，可能会直接 crash。\n\n因此，我们只能认定 atomic 是存取过程中的线程安全，并不是完全线程安全，别的线程也可以进行存取之外的操作，真正的线程安全需要开发者自己来保证。\n而 nonatomic 明显就是线程不安全的，如果有两个线程访问同一个属性，会出现无法预料的结果。因此 nonatomic 耗费的资源少，速度要比 atomic 快，性能也更好。\n使用在 iOS 应用中，大多数情况都是用在主线程上，不存在并发的问题，出于性能考虑，更倾向于用 nonatomic。\n而在 OSX 中，需要考虑多线程通讯，更适合用相对安全的 atomic 处理。\n总结综上，两者的区别可以总结如下：\n\n\n\n\natomic\nnonatomic\n\n\n\n是否默认\n√\n×\n\n\n内部实现\n存取过程中加锁\n存取过程中不加锁\n\n\n是否线程安全\n存取过程中线程安全\n线程不安全\n\n\n性能\n一般\n好\n\n\n适用于\nOSX 系统\niOS 系统\n\n\n","plink":"https://fiteen.top/the-difference-between-the-atomic-and-nonatomic-attributes/"},{"title":"你应该了解的 IDFA","date":"2017-02-07T06:26:10.000Z","date_formatted":{"ll":"Feb 7, 2017","L":"02/07/2017","MM-DD":"02-07"},"updated":"2019-12-05T03:34:44.473Z","content":"何为 IDFA苹果 iOS6 开始新增的广告标识符（IDFA）， 全称 Identifier For Advertising，是每台 iOS 设备的唯一 ID，是投放定向广告的唯一方法。\n\n\n在苹果禁用 UDID 后，IDFA 成为了标识 iPhone 用户的标准。通常用于广告追踪，在同一设备的不同 App 间进行信息共享。\nIDFA 是一段16进制的32位字符串，例如D7DFA3F1-0E1C-49CD-AFBC-75601390FEA2。可以通过以下代码获取：\n1#import &lt;AdSupport&#x2F;ASIdentifierManager.h&gt;23NSString *idfa &#x3D; [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];\n\n这个标识符虽然是唯一的，但并不是固定不变的，用户可以通过以下两种方式进行重置：\n\n设置→隐私→广告→还原广告标识符\n设置→通用→还原→还原所有设置/还原位置与信息\n\niOS10 之后，还新增了“限制广告追踪” 的设置，所以在获取 IDFA 之前，最好优先判断一下 [[ASIdentifierManager sharedManager] isAdvertisingTrackingEnabled] 返回的 BOOL 值，假如返回的是 YES，则能获取正确的 IDFA，否则获取到的字符串就会变成 00000000-0000-0000-0000-000000000000。\n因此，IDFA 并不能成为精确标识用户唯一性的符号。如果要确保唯一且固定，建议采用 UUID+Keychain 的方式，或者借助 iOS 系统可以获取的参数自定义一套算法去生成标志符。\n检查是否使用 IDFA当 App 提交应用市场审核的时候，苹果会询问“此 App 是否使用广告标识符号（IDFA）”。这里除了本地代码以外，还需要鉴别导入的任何第三方库中，是否使用了 IDFA。检查的方法很简单：\n\n打开终端 cd 到要检查的文件根目录\n执行语句 grep -r advertisingIdentifier .\n\n以含 IDFA 的友盟 SDK 为例，会出现 matches 的记录。\n\n\n\n审核时关于 IDFA 选项的选择那么如果选择了 “是”，就会提示你选择勾选4个选项框：\n\n在 App 内投放广告\n服务应用中的广告。如果你的应用中集成了广告的时候，你需要勾选这一项。\n\n标明此 App 安装来自先前投放的特定广告\n跟踪广告带来的安装。如果你使用了第三方的工具来跟踪广告带来的激活以及一些其他事件，但是应用里并没有展示广告你需要勾选这一项。\n\n标明此 App 中发生的操作来自先前投放的广告\n跟踪广告带来的用户的后续行为。如果你使用了第三方的工具来跟踪广告带来的激活以及一些其他事件，你需要勾选这一项。\n\niOS 中的“限制广告跟踪”设置\n对您的应用使用 IDFA 的目的做下确认，只要您获取了 IDFA，那么这一项都是需要勾选的。\n\n\n\n总结\n\n如果你的应用里只是集成了广告，不追踪广告带来的激活行为，那么选择 1 和 4；\n如果你的应用没有广告，而又获取了 IDFA，选择 2 和 4；\n如果你的应用没有广告，但是需要追踪广告带来的激活行为，那么选择2、3和4；\n如果你的应用里集成了广告，而且使用了sdk等用来追踪广告带来的激活行为，需要选择1,2,3和4 。\n\n\n如果还是无法确定如何选择，可以参考第三方的官方文档，基本上都会在开发文档中体现。\n","plink":"https://fiteen.top/IDFA/"},{"title":"一次搞懂时间复杂度和空间复杂度","date":"2017-01-07T18:17:34.000Z","date_formatted":{"ll":"Jan 8, 2017","L":"01/08/2017","MM-DD":"01-08"},"updated":"2019-12-11T07:19:57.165Z","content":"学习数据结构和算法时，难免提到时间复杂度（asymptotic time complexity）和空间复杂度（space complexity）的概念。\n时间复杂度概念：描述一个算法执行时间与数据规模的增长关系，记作：$T(n) = O(f(n))$。\n计算时间复杂度时，需要遵循这一条原则：如果一个算法的执行次数是 $T(n)$，那么只保留最高次项，同时忽略最高项的系数后得到函数 $f(n)$，此时时间复杂度就是 $O(f(n))$。\n比如：\n$T(n)=n+5$，时间复杂度为 $O(n)$；\n$T(n)=n^3+n^2+1$，时间复杂度为 $O(n^3)$；\n$T(n)=4n^3$，时间复杂度为 $O(n^3)$。\n下面举几个例子：\n常数阶我们知道常数项对函数的增长速度影响并不大，所以当 $T(n) = c$，$c$ 为一个常数时，我们说这个算法的时间复杂度为 $ O(1)$。 哈希算法就是典型的 $O(1)$ 时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）。\n1int n = 100;2int sum = n * (n + 1) / 2;3printf(\"%i\\n\", sum);\n\n像上面这段代码，无论 $n$ 是多少，运行步骤都一样，所以时间复杂度是 $O(1)$。\n线性阶$O(n)$ 代表数据量增大 $n$ 倍，耗时也增大 $n$ 倍，比如常见的遍历算法。\n对于一个循环，假设循环体的时间复杂度为  $O(m)$，循环次数为 $n$，那么循环的时间复杂度为 $O(m×n)$；\n1for(int i = 0; i &lt; n; i++) &#123;        // 循环次数为 n2    printf(\"Hello, World!\\n\");      // 循环体时间复杂度为 O(1)3&#125;\n\n此时时间复杂度为  $O(1×n)$，即  $O(n)$。\n平方阶$Ο(n^2)$：代表数据量增大 $n$ 倍，时间复杂度就是 $n^2$ ，比如冒泡排序。\n对于下面这个多循环，循环次数为 $n×n$，那么时间复杂度为 $O(n × n × 1)$，即 $O(n^2)$。\n1for(int i = 0; i &lt; n; i++) &#123;2    for(int j = 0; j &lt; n; j++) &#123;3        printf(\"Hello, World!\\n\");4    &#125;5&#125;\n\n对数阶$O(log_2n)$：当数据增大 $n$ 倍时，耗时增大 $log_2n$ 倍。比如下面这段代码，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度。\n1for (int i = 1; i &lt;= n; i++) &#123;2  i *= 2;3  printf(\"%i\\n\", i);4&#125;\n\n二分查找的时间复杂度就是 $O(log_2n)$。\n对数阶乘以 $n$$O(nlog_2n)$：当数据增大 $n$ 倍时，耗时增大 $nlog_2n$ 倍，比如。比如下面这段代码，当数据增大256倍时，耗时增大256*8=2048倍，这个复杂度高于线性阶低于平方阶。\n1for(int i = 0; i &lt; n; i++) &#123;2  for (int i = 2; i &lt; n; i++) &#123;3    i *= 2;4    printf(\"%i\\n\", i);5  &#125;6&#125;\n\n归并排序的时间复杂度就是 $O(nlog_2n)$。\n指数阶$O(2^n)$：当数据增大 $n$ 倍时，耗时增大 $2^n$ 倍，比如斐波那契数列：\n1long aFunc(int n) &#123;2  if (n &lt;= 1) &#123;3    return 1;4  &#125; else &#123;5    return aFunc(n - 1) + aFunc(n - 2);6  &#125;7&#125;\n\n常见的算法时间复杂度由小到大依次为：\n$Ο(1)＜Ο(log_2n)＜Ο(n)＜Ο(nlog_2n)＜Ο(n^2)＜Ο(2^n)$\n空间复杂度概念：描述一个算法占用空间与数据规模的增长关系，记作：$S(n) = O(f(n))$。\n一个算法在计算机上占用的内存包括：程序代码所占用的空间、输入输出数据所占用的空间、辅助变量所占用的空间这三个方面。程序代码所占用的空间取决于算法本身的长短，输入输出数据所占用的空间取决于要解决的问题，是通过参数表调用函数传递而来，只有辅助变量是算法运行过程中临时占用的存储空间，与空间复杂度相关。\n通常来说，只要算法不涉及到动态分配的空间以及递归、栈所需的空间，空间复杂度通常为 $O(1)$。\n算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。\n(function(){\n  if (!window.MathJax || !MathJax.Hub) {\n    const script = document.createElement('script'); \n    script.src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';\n    document.head.appendChild(script);\n  } else MathJax.Hub.Queue(['Typeset', MathJax.Hub, document.querySelector('main')]);\n})();","plink":"https://fiteen.top/asymptotic-time-complexity-and-space-complexity /"},{"title":"『2016』莫愁前路无知己","date":"2016-12-31T15:59:01.000Z","date_formatted":{"ll":"Dec 31, 2016","L":"12/31/2016","MM-DD":"12-31"},"updated":"2019-12-04T12:16:50.959Z","content":"城西银泰喧闹的跨年倒计时还在进行，明晃晃的照灯和兴奋的人群。\n\n\n往日不可追2016，我终于向四年的大学生活告别，同时也为十六年的学生生涯画上了句点。高考失利后我放弃了复读，又在父母的声声抗议中坚持填报了数学类。我知道自己表面上文静顺从，骨子里却住着一颗叛逆的灵魂。我敏感又骄傲，低调却好强，正义还心软，别扭的性格也使我前行的道路上真的走了许多弯路。\n并不喜欢指挥和领导，却意外接任了校报负责人；\n因为是学院文艺部部长的室友拜托着凑名额参加的校运会，竟也拿到了奖牌；\n毫无数学建模经验，第一次参加美赛，却成为了当年唯一的获奖队伍；\n在学科竞赛、学生工作、志愿者活动之间连轴忙碌依然保持专业第一;\n……\n看起来幸运的人生，自己却知道到底有很辛苦，数不清多少个凌晨，一遍遍修改文案、校正排版、调整样式，不厌其烦地翻遍资料去接触理解陌生的领域。我不喜欢投机取巧，想到坚持自己的初心。\n大学的第一张奖状是军训优秀学员，最后一本证书是浙江省优秀毕业生，某种意义上也算完成了善始善终。感恩每段经历，感恩遇到过的人。我不够左右逢源，也不情愿为了迎合别人的眼光停滞自己的脚步。这个世界上优秀的人数不胜数，有人说强者都是孤独的，弱者才需要成群结队，但我想，强者也总能找到自己的队伍吧。\n来日犹可期得不到的永远在骚动，被偏爱的都有恃无恐。\n还在考研的好友说，好羡慕你，都工作赚钱了。我却对她说，还是读书时候好啊。我当然知道这世界，不会完美无瑕，可我们无法阻止时光的流转，长大了就需要去纠结工资开销、租房买房、柴米油盐、婚姻家庭，也需要足够强大去抵挡诱惑。\n人生很漫长，起码现在的我还热爱着敲击键盘的感觉，热爱每次 run 出美丽图案的惊叹，热爱每个 warning 和 error 被消除的喜悦，那就享受此刻的热爱。\n人生也很短暂，感谢所有的 exception 和 not found，感恩让我选择今天的每一次 switch 和 if。前进的路上，难免孤独，但请记得莫愁前路无知己，天下谁人不识君。\n","plink":"https://fiteen.top/annual-summary-2016/"},{"title":"如何在 Xcode8上安装插件","date":"2016-11-30T04:02:20.000Z","date_formatted":{"ll":"Nov 30, 2016","L":"11/30/2016","MM-DD":"11-30"},"updated":"2019-12-04T12:04:58.978Z","content":"正式推出 Xcode8 已有两个多月，也有不少朋友分享了安装插件的方法，笔者在这里整理了一个亲测有效的方法。\n\n更新 Xcode，目前最新版本是8.1；\n\n由于安装插件会影响原来的 Xcode 打包上传，我们在应用程序里复制一个 Xcode，并重命名为 XcodeSigner；\n\n\n\n\n打开钥匙串，创建新证书，名称填 XcodeSigner，证书类型选择代码签名（Code Signing）；\n\n\n\n\n在终端命令中输入：sudo codesign -f -s XcodeSigner /Applications/XcodeSigner.app耐心等待命令执行完毕；\n\n获得 XcodeSigner 的 UUID；通过在终端命令行输入：defaults read /Applications/XcodeSigner.app/Contents/Info DVTPlugInCompatibilityUUID \n\n在 GitHub 上下载好想安装的插件，以 ESJsonFormat 为例，打开方式选择 XcodeSigner；\n\n\n检查 info.plist 中是否已经添加了第5步获得的 UUID ，未添加可能会造成 XcodeSigner 闪退。若文件中已经存在，直接运行项目即可；\n\n\n运行成功后，关闭 XcodeSigner ，重新启动，这时会弹出如下两类提示框，分别选择“ Load Bundle ”和“允许”（或“始终允许”），这时点击 Window 就能看到列表中多了 ESJsonFormat 了。\n\n\n\n\n\n","plink":"https://fiteen.top/how-to-install-plugins-on-Xcode8/"},{"title":"Git 手册之用 .gitignore 忽略文件","date":"2016-11-21T17:34:57.000Z","date_formatted":{"ll":"Nov 22, 2016","L":"11/22/2016","MM-DD":"11-22"},"updated":"2019-12-05T03:33:40.688Z","content":"提交代码后我们经常发现，即使没有任何代码修改，有一些文件也会提示更新，例如：UserInterfaceState.xcuserstate、.DS_Store 等。\n这种情况可以通过添加 .gitignore 文件解决。\n\n\n如何在项目中添加 .gitignore具体步骤如下：\n\n打开终端 进入项目中 .git 同目录下\n1cd &lt;path&gt;\n\n创建 .gitignore 文件\n1touch .gitignore\n\n打开 .gitignore 文件\n1open .gitignore\n\n参照 .gitignore 模版，找到对应的开发语言，将模版文本粘贴到自己的 .gitignore 中\n\n更新项目\n1git add .gitignore2git commit -m \"feat: add .gitignore file\"3git push\n删除 .DS_Store\n\n.DS_Store 是Mac OS 保存文件夹的自定义属性的隐藏文件。如果项目中还没有自动生成 .DS_Store，把它加入到 .gitignore 中即可；但如果项目中已经有了，先从项目中将其删除，再把它加入到 .gitignore 里。步骤如下：\n\n删除项目中的所有 .DS_Store\n1find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch\n\n将 .DS_Store 加入到 .gitignore 文件中\n1echo .DS_Store &gt;&gt; ~/.gitignore\n\n更新项目\n1git add --all2git commit -m \"feat: ignore .DS_Store\"3git push\n\n\n\n如果只需要删除磁盘上的 .DS_Store，用下面的命令来删除当前目录及其子目录下的所有 .DS_Store 文件：\n1find . -name '*.DS_Store' -type f -delete\n\n你也可以通过输入这串命令直接禁止生成 .DS_store，重启Mac即可生效：\n1defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE\n\n恢复 .DS_store 生成的命令为：\n1defaults delete com.apple.desktopservices DSDontWriteNetworkStores","plink":"https://fiteen.top/git-ignore/"},{"title":"《Effective Objective-C 2.0》整理（四）：协议与分类","date":"2016-09-28T12:21:06.000Z","date_formatted":{"ll":"Sep 28, 2016","L":"09/28/2016","MM-DD":"09-28"},"updated":"2019-12-05T03:29:58.204Z","content":"第23条：通过委托与数据源协议进行对象间通信Objective-C 开发中广泛使用“委托模式”来实现对象间的通信，该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”（delegate）。而“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。\n\n\n此模式可将数据和业务逻辑解耦。例如，用户界面有个显示一系列数据所用的视图，视图对象的属性中，可以包含负责数据和事件处理的对象。这两种对象分别称为“数据源”（data source）与“委托”（delegate）。\n委托（代理模式）（Delegate）：委托别人办事，自己不处理，交给别人处理；\n协议（Protocol）：使用了这个协议就要按照协议办事\n下面总结一下委托模式的实现，委托方：\n1&#x2F;&#x2F; .h 文件中2&#x2F;&#x2F; 定义协议3@protocol ClassADelegate4&#x2F;&#x2F; 协议中不标注，默认为 @required 类型，必须实现5- (void)methodA;6@optional7&#x2F;&#x2F; 特别标注了 @optional 类型，表示可以不实现8- (void)methodB;9@end1011@interface ClassA : NSObject12&#x2F;&#x2F; 引用，存代理方13@property (nonatomic, weak) id &lt;ClassADelegate&gt; delegate;14@end1516&#x2F;&#x2F; .m 中在合适的时机给代理方发消息17@implementation ClassB18- (void)rightTimeMethod &#123;19    &#x2F;&#x2F; 实现 @requiered 方法 methodA20    [self.delegate methodA];21    &#x2F;&#x2F; 实现 @optional 方法 methodB22    if ([self.delegate respondsToSelector:@selector(methodB)]) &#123;23        [self.delegate methodB];24    &#125;25&#125;26@end\n\n在这里需要注意的是：delegate 属性需要定义成 weak，而非 strong。因为两者之间必须为“非拥有关系”，否则会造成循环引用，从而导致内存泄漏。\n而代理方则需要：\n1&#x2F;&#x2F; 遵守协议2@interface ClassB() &lt;ClassADelegate&gt;3@end45@implementation ClassB6&#x2F;&#x2F; 实现方法7#pragma mark - ClassADelegate8- (void)methodA &#123;9    &#x2F;&#x2F; how to implementation methodA10&#125;11&#x2F;&#x2F; 将自己设置为代理方12- (void)rightTimeMethod &#123;13\tClassA classA &#x3D; [ClassA new];14\tclassA.delegate &#x3D; self;15&#125;16@end\n\n\n\n第24条：将类的实现代码分散到便于管理的数个分类之中当一个类中充斥了大量的方法实现时，可以通过分类这种模式将这个庞大的类打散，例如：\n\nEOCPerson+Friendship(.h/.m)\nEOCPerson+Work(.h/.m)\nEOCPerson+Play(.h/.m)\n\n通过分类机制，可以把类的代码分成多个易于管理的小块，归入不同的“功能区”，以便单独检视，也便于调试。\n在编写准备分享给其他开发者使用的程序库时，可以考虑创建 Private 分类，如果程序库中的某个地方要用到这些方法，那就引入此分类的头文件。而分类的头文件并不随程序库一并公开，于是该库的使用者也就不知道库里还有这些私有方法了。\n第25条：总是为第三方类的分类名称加前缀如果分类中有何原有类同名的方法，会优先调用分类中的方法，同名方法调用的优先级为分类 &gt; 本类 &gt; 父类。如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定，编译器会执行最后一个参与编译的分类中的方法。\n为了避免分类覆盖，可以通过给类名和方法名都加专属前缀的方式解决。\n例如：\n1@interface NSString (ABC_HTTP)2&#x2F;&#x2F; Encode a string with URL encoding3- (NSString *)abc_urlEncodedString;4&#x2F;&#x2F; Decode a URL encode string5- (NSString *)abc_urlDecodedString;6@end\n\n\n\n第26条：勿在分类中声明属性除了“class-continuation 分类”之外，其他分类都无法向类中新增实例变量。原因是分类无法合成与属性相关的实例变量。分类中可以写 @property，但不会生成 setter/getter 方法，也不会生成实现以及私有的成员变量，会编译通过，但是引用变量会报错。\n简单地说，分类是运行期决议的，在运行期，对象的内存布局已经确定了，如果此时添加实例变量会破坏类的内部结构。\n但是如果一定要添加，也是可以通过分类中为该属性实现存取方法来实现。如下：\n1#import &lt;objc&#x2F;runtime.h&gt;23static const char *kFriendsPropertyKey &#x3D; &quot;kFriendsPropertyKey&quot;;45@implementation EOCPerson (Friends)6- (NSArray *)friends &#123;7    return objc_getAssociatedObject(self, kFriendsPropertyKey);8&#125;9- (void)setFriends:(NSArray *)friends &#123;10    objc_setAssociatedObject(self,11                             kFriendsPropertyKey,12                             friends,13                             OBJC_ASSCIATIOM_RETAIN_NONATOMIC);14&#125;15@end\n\n但是这种做法并不推荐。分类机制，应该理解为一种手段，目标在于拓展类的功能，而非封装数据。最好的做法，就是将封装数据所用的全部属性都定义在主接口里。\n第27条：使用“class-continuation 分类”隐藏实现细节分类的主要作用是为已经存在的类添加方法，因为分类的结构体指针中，没有属性列表，只有方法列表。本章介绍的是一种特殊的分类“class-continuation”，用于定义一些无需对外公布的方法及实例变量。形如：\n1#import &quot;ClassA.h&quot;2@interface ClassA ()3&#x2F;&#x2F; 定义你所需要的私有变量或方法4@end56@implementation ClassA7&#x2F;&#x2F; 实现8@end\n\n若想使类所遵循的协议不为人所知，也可以在“class-continuation 分类”中声明。\n第28条：通过协议提供匿名对象协议定义了一系列方法，遵从此协议的对象应该实现它们。于是，我们可以用协议把自己所写的 API 之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯 id 类型，这样，想隐藏的类型就不会出现在 API 之中了。例如 ClassA、ClassB 都会遵循某个协议 EOCDelegate，假如指定类型，就会这样约定：\n1@property (nonatomic ,weak) ClassA &lt;EOCDelegate&gt; delegate;2@property (nonatomic ,weak) ClassB &lt;EOCDelegate&gt; delegate;\n\n如果不想指明具体使用哪个类，就可以将 delegate 对象约定成 纯 id 类型，这个对象也可以称之为“匿名对象”。\n1@property (nonatomic ,weak) id &lt;EOCDelegate&gt; delegate;\n\n总结一下：\n\n协议可以在某种程度上提供匿名对象，具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。\n使用匿名对象来隐藏类型名称（或类名）。\n如果具体类型不重要，重要的是对象能否处理好一些特定的方法，那么就可以使用这种协议匿名对象来完成。\n\n\n参考资料：《Effective Objective-C 2.0》编写高质量iOS与OS X代码的52个有效方法\n","plink":"https://fiteen.top/EOC2.0-Chapter-4/"},{"title":"《Effective Objective-C 2.0》整理（三）：接口与 API 设计","date":"2016-09-22T09:55:21.000Z","date_formatted":{"ll":"Sep 22, 2016","L":"09/22/2016","MM-DD":"09-22"},"updated":"2019-11-18T13:17:40.000Z","content":"第15条：用前缀避免命名空间冲突Objective-C 没有其他语言那种内置的命名空间（namespace）机制，我们需要变相实现命名空间。\n而 Apple 宣称其保留使用所有“两字母前缀”的权利，因此我们选用的前缀应该是三个字母的，一般选用与公司、应用程序或与二者有关联之名称作为类名的前缀，并在所有代码中均只用这一前缀。\n\n\n第16条：提供“全能初始化方法”所有对象均要初始化。我们将可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”。\n以某个矩形类为例，它的全能初始化方法为：\n1- (id)initWithWidth:(float)width andHeight:(float)height&#123;2    if ((self &#x3D; [super init])) &#123;3        _width &#x3D; width;4        _height &#x3D; height;5    &#125;6    return self; 7&#125;\n\n若全能初始化方法与超类不同，则需覆写超类中的对应方法。如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。\n举例，某个正方形类作为矩形类的子类，它需要满足 width 和 height 一致的条件，\n那么它的初始化方法为：\n1- (id)initWithDimension:(float)dimension&#123;2    return [super initWithWidth:dimension andHeight:dimension];3&#125;\n\n然后覆写矩形类的全能初始化：\n1- (id)initWithWidth:(float)width andHeight:(float)height&#123;2    float dimension &#x3D; MAX(width, height);3    return [self initWithDimension:dimension];4&#125;\n\n并抛出异常：\n1- (id)initWithWidth:(float)width andHeight:(float)height&#123;2    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instead.&quot; userInfo:nil];3&#125;\n\n第17条：实现 description 方法调试程序时，经常需要打印并查看对象信息。我们通常会使用下面的方法打印：\n1NSLog(@&quot;object &#x3D; %@&quot;, object);\n\n假如 object 是个自定义类，输出的信息形如：\n1object &#x3D; &lt;CustomClass: 0x7fd9a1600600&gt;\n\n想要看到类中完整的信息，需要在类中覆写 description 方法。建议在该方法中打印出类的名字和指针地址。\n1- (NSString*)description&#123;2    return [NSString stringWithFormat:@&quot;&lt;%@:%p,\\&quot;%@ %@\\&quot;&gt;&quot;,[self class],self,_parm1,_parm2];3&#125;\n\nNSObject 协议中有一个 debugDescription 方法，它是开发者在调试器中以控制台命令打印对象时才调用的。Foundation 框架的 NSArray 类就是实现了 debugDescription。\n第18条：尽量使用不可变对象设计类时，应充分运用属性来封装数据。默认情况下，属性是 read-write，这样设计出来的类都是“可变的”。\n如果把可变对象放入 collection 之后又修改其内容，那么很容易破坏 set 的内部数据结构，使其失去固有的语义，因此应该尽量减少对象中的可变内容，即定义为 readonly 属性。\n不要把可变的 collection 作为属性公开，而应提供相关方法，一次修改对象中的可变collection。例如，某个 EOCPerson 类，假如要改变 friends 数据集，可通过 addFriend 和 removeFriend 实现：\n1#import &lt;Foundation&#x2F;Foundation.h&gt;23@interface EOCPerson : NSObject45@property(nonatomic,copy,readonly)NSString *firstName;6@property(nonatomic,copy,readonly)NSString *lastName;7@property(nonatomic,strong,readonly)NSSet *friends;89- (id)initWithFirstNmae:(NSString *)firstName10               lastName:(NSString *)lastName;11- (void)addFriend:(EOCPerson*)person;12- (void)removeFriend:(EOCPerson*)person;1314@end\n\n第19条：使用清晰而协调的命名方式方法命名规则：\n\n如果方法的返回值是新创建的，那么方法名的首个词应是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象。\n应该把表示参数类型的名词放在次参数前面。\n如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。\n不要使用 str 这种简称，应该用 string 这样的全称。\n如果某方法返回非属性的Boolean值，那么应该根据其功能，选用 has 或 is 当前缀。\n将 get 整个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C语言数组”里的那种方法就可以使用这个词做前缀。\n\n类与协议的命名\n\n给方法起名时的第一要务就是确保其风格与你自己的代码所要继承的框架相符。\n\n\n最重要的一点就是，命名方式要协调一致。如果要从其他框架中集成子类，那么务必遵循其命名惯例。\n\n第20条：为私有方法名加前缀编写类的实现代码时，经常要写一些只在内部使用的方法。为这种方法的名称加上某些前缀，这就可以轻易将公共方法和私有方法区分开，有助于调试。\n例如，使用 _p 作为前缀，p 表示 “private”，而下划线可以把这个字母和真正的方法名区隔开：\n1@interface EOCObject : NSObject2- (void)publicMethod;3@end45@implementation EOCObject6- (void)publicMethod &#123;&#125;7- (void)p_privateMethod &#123;&#125;8@end\n\n但是，需要注意的是，不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司的。\n第21条：理解 Objective-C 错误模型不同于 Java 等编程语言，面对异常处理，Objective-C 现在采用的方法是：只有在极其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。\n而出现“不那么严重的错误”时，Objective-C 语言所使用的编程范式为：令方法返回 nil/0，或是使用 NSError，以表明其中有错误发生。\nNSError 的用法更加灵活，因为经由此对象，我们可以把导致错误的原因反馈给调用者。NSError 对象里封装了三条信息：\n\nError domain（错误范围，类型为字符串）\nError code（错误码，类型为整数）\nUser info（用户信息/有关此错误的额外信息，类型为字典）\n\nNSError 经常由“输出参数”返回给调用者，例如：\n1- (BOOL)doSomething:(NSError**)error &#123;2    &#x2F;&#x2F; Do something that may cause an error3    4    if ( &#x2F;* there was an error*&#x2F; ) &#123;5        if (error) &#123;6            &#x2F;&#x2F; Pass the &#39;error&#39; through the out-parameter7            *error &#x3D; [NSError errorWithDomain:domain code:code userInfo:userInfo];8        &#125;9        return NO; &#x2F;&#x2F;&#x2F;&lt; Indicate failure10    &#125; else &#123;11        return YES; &#x2F;&#x2F;&#x2F;&lt; Indicate success12    &#125;13&#125;\n\n调用者可以根据错误类型分别处理各种错误，错误范围应该定义成 NSString 型的全局常量，而错误码则定义成枚举类型为佳，如：\n 1&#x2F;&#x2F; EOCErrors.h2extern NSString *const EocErrorDomain;34typedef NS_ENUM(NSUInteger,EOCError) &#123;5    EOCErrorUnknown              &#x3D; -1;6    EOCErrorInternalInconsistency&#x3D; 100;7    EOCErrorGeneralFault         &#x3D; 105;8    EOCErrorBadInput             &#x3D; 500;9&#125;;10&#x2F;&#x2F; EOCErrors.m11NSString *const EOCErrorDomain &#x3D; @&quot;EOCErrorDomain&quot;;\n\n第22条：理解 NSCopying 协议在 Objective-C 中，对象的拷贝通过 copy 完成。如果想要自定义的类支持拷贝，那就要实现 NSCopying 协议，该协议只有一个方法：\n1- (id)copyWithZone:(NSZone *)zone;\n\n如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。\n1- (id)mutableCopyWithZone:(NSZone *)zone;\n\n复制对象时需决定采用浅拷贝和深拷贝。\n深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去；\n浅拷贝：只拷贝容器对象本身，而不复制其中数据。\n一般情况下应该尽量执行浅拷贝，如：\n1- (void)copyWithZone:(NSZone *)zone &#123;2    EOCPerson *copy &#x3D; [[[self class] allocWithZone:zone] initWithFirstNmae:_firstName lastName:_lastName];3    copy-&gt;_friends &#x3D; [_friends mutableCopy];4    return copy;5&#125;\n\n如果你写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法，如下：。\n1- (void)deepCopy &#123;2    EOCPerson *copy &#x3D; [[[self class] alloc]initWithFirstNmae:_firstName lastName:_lastName];3    copy-&gt;_friends &#x3D; [[NSMutableSet alloc]initWithSet:_friends copyItems:YES];4    return copy;5&#125;\n\n\n\n参考资料：《Effective Objective-C 2.0》编写高质量iOS与OS X代码的52个有效方法\n","plink":"https://fiteen.top/EOC2.0-Chapter-3/"},{"title":"《Effective Objective-C 2.0》整理（二）：对象、消息、运行时","date":"2016-09-19T05:20:00.000Z","date_formatted":{"ll":"Sep 19, 2016","L":"09/19/2016","MM-DD":"09-19"},"updated":"2019-12-05T03:32:19.931Z","content":"第6条：理解“属性”这一概念实例变量一般通过“存取方法”来访问。\n\n获取方法（getter）：读取变量值\n设置方法（setter）：写入变量值\n\n\n\n属性能够访问封装在对象里的数据，意味着编译器会自动写出一套存取方法。\n1@property NSString *firstName; &#x2F;&#x2F; Same as:2- (NSString *)firstName;3- (void)setFirstName:(NSString *)firstName;\n\n也可以用“点语法”访问属性。\n1aPerson.firstName &#x3D; @&quot;Bob&quot;; &#x2F;&#x2F; Same as:2[aPerson setFirstName:@&quot;Bob&quot;];34NSString *lastName &#x3D; aPerson.lastName; &#x2F;&#x2F; Same as:5NSString *lastName &#x3D; [aPerson lastName];\n\n下面区分一下3种声明类型：\n\n\n\n声明类型\n描述\n\n\n\n@property\n在头文件中声明 getter 和 setter 方法\n\n\n@synthesize\n在实现文件中生成相应的 getter 和 setter 方法\n\n\n@dynamic\n告诉编译器开发者会自己实现 getter 和 setter 方法。若未实现，编译通过但程序运行时会崩溃\n\n\n属性各种特质设定会影响编译器所生成的存取方法，介绍以下特质：\n原子性\n\natomic：原子性，不声明即默认。存取过程中线程安全，系统会自动的创建 lock 锁，锁定变量。\nnonatomic：非原子性的。线程不安全，性能更好。开发时应使用 nonatomic。\n\n读/写权限\n\nreadwrite： 属性拥有 getter 和 setter，若该属性由 @synthesize 实现，则编译器会自动生成这两个方法。\nreadonly：一种“拥有关系”，设置新值时，设置方法会保留新值，并释放旧值，再将新值设置上去。\n\n内存管理语义\n\nassign： “设置方法”只针对“纯量类型”（CGFloat、NSInteger等）的简单赋值操作。不进行任何 retain 操作。\nstrong：一种“拥有关系”，设置新值时，设置方法会保留新值，并释放旧值，再将新值设置上去。\nweak： 一种“非拥有关系”，设置新值时，既不保留新值，也不释放旧值。在属性所指的对象遭到摧毁时，属性值也会清空。\nunsafe_unretained：语义和 assign 相同，适用于“对象类型”。非拥有（“不保留”，unretained），当属性所指的对象遭到摧毁时，属性值不会自动清空（“不安全”，unsafe）。\ncopy：所属关系与 strong 类似，但设置方法并不保留新值，而是将其 copy。\n\n问题：为什么NSString *要用copy 修饰？答案：因为传递给setter的新值有可能指向一个 NSMutableString 类的实例，它是 NSString 的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性后，字符串的值就可能会在对象不知情的情况下遭人更改。\n方法名\n\ngetter=指定“获取方法”的方法名。1&#x2F;&#x2F; UISwitch类中表示“开关”是否打开的属性如下定义：2@property (nonatomic, getter&#x3D;isOn) BOOL on;\nsetter=指定“设置方法”的方法名，用法不常见。\n\n通过上述特质，可以微调由编译器所合成的存取方法。但若是自己实现存取方法，应该保证其具备相关属性所声明的特质。\n第7条：在对象内部尽量直接访问实例变量在对象之外访问实例变量时，总是通过属性来做，但在对象内部访问实例变量一直存在争议。\n笔者建议在读取实例变量时采用直接访问的形式，设置实例变量的时候通过属性来做。\n举例：\n1@interface EOCPerson : NSObject2@property (nonatomic, copy) NSString *firstName;3@property (nonatomic, copy) NSString *lastName;4&#x2F;&#x2F; Convenience for firstName + &quot; &quot; + lastName;5- (NSString *)fullName;6- (void)setFullName:(NSString *)fullName;7@end\n\nfullName 和 setFullName 可以这样实现：\n1&#x2F;&#x2F; 使用点语法2- (NSString *)fullName &#123;3    return [NSString stringWithFormat:@&quot;%@ %@&quot;,self.firstName,self.lastName];4&#125;5- (void)setFullName:(NSString *)fullName &#123;6    NSArray *components &#x3D; [fullName componentsSeparatedByString:@&quot; &quot;];7    self.firstName &#x3D; [components objectAtIndex:0];8    self.lastName &#x3D; [components objectAtIndex:1];9&#125;10&#x2F;&#x2F; 直接访问实例变量11- (NSString *)fullName &#123;12    return [NSString stringWithFormat:@&quot;%@ %@&quot;,_firstName,_lastName];13&#125;14- (void)setFullName:(NSString *)fullName &#123;15    NSArray *components &#x3D; [fullName componentsSeparatedByString:@&quot; &quot;];16    _firstName &#x3D; [components objectAtIndex:0];17    _lastName &#x3D; [components objectAtIndex:1];18&#125;\n这两种写法有以下区别：\n\n由于不经过“方法派发”（详见第11条），直接访问实力变量的速度比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。\n直接访问实例变量时，不会调用 setter 方法，那就绕过了第6条所提及的“内存管理语义”，比如：在 ARC 下直接访问一个声明为 copy 的属性，不会拷贝属性，只会保留新值并释放旧值。\n直接访问实例变量，不会触发 KVO 通知。\n通过属性来访问有助于排查与之相关的错误，因为可以给 getter/setter 方法新增断点，监控该属性的调用者及其访问时机。\n\n由此衍生一种折中方案：写入实例变量时，通过其“设置方法”来做，读取时直接访问之。此方法既能提高读取操作的速度，又能控制对属性的写入操作。\n注意：如果使用懒加载，必须通过存取方法来访问属性，否则实例变量永远不会初始化。\n第8条：理解“对象等同性”这一概念NSObject 协议中有两个用于判断等同性的关键方法：\n1- (BOOL)isEqual:(id)object;2- (NSUInteger)hash;\nNSObject 类对这两个方法的默认实现是：当且仅当其“指针值”完全相等时，这两个对象才相等。若想在自定义的对象中正确覆写这些方法，就必须先理解其约定。\n如果 “isEqual:” 方法判定两个对象相等，那么其 hash 方法也必须返回同一个值。但是，如果两个对象的 hash 方法返回同一个值，那么 “isEqual:” 方法未必会认为两者相等。\n比如下面这个类：\n1@interface EOCPerson : NSObject2@property (nonatomic, copy) NSString *firstName;3@property (nonatomic, copy) NSString *lastName;4@property (nonatomic, assign) NSUInteger age;5@end6 7&#x2F;&#x2F; 我们认为，如果两个 EOCPerson 的所有字段都相等，那么两个对象就相等。89- (BOOL)isEqual:(id)object &#123;10    if (self &#x3D;&#x3D; object) return YES;11    if ([self class] !&#x3D; [object class]) return NO;12    13    EOCPerson *otherPerson &#x3D; (EOCPerson *)object;14    if (![_firstName isEqualToString:otherPerson.firstName])15        return NO;16    if (![_lastName isEqualToString:otherPerson.lastName])17        return NO;18    if (_age !&#x3D; otherPerson.age)19        return NO;20    return YES;21&#125;2223- (NSUInteger)hash &#123;24    NSUInteger firstNameHash &#x3D; [_firstName hash];25    NSUInteger lastNameHash &#x3D; [_lastName hash];26    NSUInteger ageHash &#x3D; _age;27    return firstNameHash ^ lastNameHash ^ ageHash;28&#125;\nisEqual 检测规则：只要其中有不相等的属性，就判定两对象不等，否则两对象相等。\ncollection 在检索哈希表时，会把对象的哈希码做索引。在写 hash 方法时，需要考虑性能以及减小创建字符串的开销，在减少碰撞频度与降低运算复杂程度之间做出取舍。\n特定类所具有的等同性判定方法\n由于 Objective-C 在编译器不做强类型检查，这样容易不小心传入类型错误的对象，因此做判定时应确保所传对象的类型正确性。\n以 EOCPerson 类为例：\n1- (BOOL)isEqualToPerson:(EOCPerson *)otherPerson &#123;2    if (self &#x3D;&#x3D; otherPerson) return YES;3    4    if (![_firstName isEqualToString:otherPerson.firstName])5        return NO;6    if (![_lastName isEqualToString:otherPerson.lastName])7        return NO;8    if (_age !&#x3D; otherPerson.age)9        return NO;10    return YES;11&#125;1213- (BOOL)isEqual:(id)object &#123;14    &#x2F;&#x2F; 如果受测参数与接受该消息的对象都属于同一个类，那么调用自己编写的判定方法，否则交由超类来判断。15    if ([self class] !&#x3D; [object class]) &#123;16        return [self isEqualToPerson:(EOCPerson *)object];17    &#125; else &#123;18        return [super isEqual:object];19    &#125;20&#125;\n等同性判定的执行深度\n不要盲目地逐个检测每条属性，而是应该依照具体需求来制定检测方案。\n容器中可变类的等同性\n如果把某对象放入set之后又修改其内容，可能会出现容器中有相同对象的情况，要注意其隐患的发生。\n第9条：以“类族模式”隐藏实现细节“类族”是一种可以隐藏“抽象基类”背后实现细节的模式，在 Objective-C 系统框架中普遍使用。\n创建类族\n举例创建一个处理雇员的类族：\n1typedef NS_ENUM (NSUInteger, EOCEmployeeType) &#123;2    EOCEmployeeTypeDeveloper,3    EOCEmployeeTypeDesigner,4    EOCEmployeeTypeFinance,5&#125;;67@interface EOCEmployee : NSObject89@property (copy) NSString *name;10@property NSInteger salary;1112&#x2F;&#x2F; 创建雇员对象13+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;1415&#x2F;&#x2F; 雇员的日常工作16- (void)doADaysWork;1718@end1920@implementation EOCEmployee2122+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;23    switch (type) &#123;24        case EOCEmployeeTypeDeveloper:25            return [EOCEmployeeDeveloper new];26            break;27        case EOCEmployeeTypeDesigner:28            return [EOCEmployeeDesigner new];29            break;30        case EOCEmployeeTypeFinance:31            return [EOCEmployeeFinance new];32            break;33    &#125;34&#125;3536- (void)doADaysWork &#123;37    &#x2F;&#x2F; 供子类实现38&#125;3940@end4142&#x2F;&#x2F; 每个“实体子类”都从基类继承而来43@interface EOCEmployeeDeveloper:EOCEmployee44@end4546@implementation EOCEmployeeDeveloper4748- (void)doADaysWork &#123;49    [self writeCode];50&#125;5152@end\n\n本例中，基类实现了一个“类方法”，该方法根据待创建的雇员类别分配好对应的雇员类实例。这种“工厂模式”是创建类族方法之一。\nCocoa 里的类族\n系统框架中有许多类族，大部分 collection（集合）类都是类族。例如 NSArray 与其可变版本 NSMutableArray，由此可见实际上有两个抽象基类，一个用于不可变数组，另一个用于可变数组。\n抽象基类：为了给子类继承实现具体的功能，它是”残缺的类“，里面没有抽象方法的具体代码，里面的抽象方法是被子类重写的。\n在 Employee 这个例子中，若是没有“工厂方法”的源代码，就无法向其中新增雇员类别。然而对于 Cocoa 中 NSArray 这样的类族来说，还是有办法新增子类的， 但需要遵守几条规则：\n\n子类应该继承自类族的抽象基类。若要编写 NSArray 类族的子类，则需令其继承自不可变的数组和基类或可变数组的基类。\n\n子类应该定义自己的数据存储方式。NSArray 本身只不过是包在其他隐藏对象外卖的壳，它仅仅定义了所有数组都需具备的一些接口。对于这个自定义的数组子类来说，可以用 NSArray 来保存其实例。\n\n子类应当覆写超类文档中指明需要覆写的方法。在每个抽象基类中，都有一些子类必须覆写的方法。比如说，想要编写 NSArray 的子类，就需要实现 count 及 “objectAtIndex:” 方法。像 lastObject 这种方法则无须实现，因为基类可以根据前两个方法推演它。\n\n\n第10条：在既有类中使用关联对象存放自定义数据要在对象中存放相关信息，我们通常会从对象所属的类中继承一个子类，再改写子类对象。有时候类的实例可能是由某种机制所创建的，这就引入了一个强大的特性——“关联对象”。\n可以给某对象关联许多其他对象，这些对象通过“键”来区分。存储对象值的时候，可以指明“存储策略”，用以维护相应的“内存管理语义”。存储策略由名为 objc_AssociationPolicy 的枚举所定义，下表列出该枚举的取值和与之等效的 @property 属性。\n\n\n\n关联类型\n等效的 @property 属性\n\n\n\nOBJC_ASSOCIATION_ASSIGN\nassign\n\n\nOBJC_ASSOCIATION_RETAIN_NONATOMIC\nnonatomic, retain\n\n\nOBJC_ASSOCIATION_COPY_NONATOMIC\nnonatomic, copy\n\n\nOBJC_ASSOCIATION_RETAIN\nretain\n\n\nOBJC_ASSOCIATION_COPY\ncopy\n\n\n下面的方法可以管理关联对象：\n\nvoid objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)此方法以给定的键和策略为某对象设置关联对象值。\n\nid objc_getAssociatedObject(id object, const void *key)此方法根据给定的键从某对象中获取相应的关联对象值。\n\nvoid objc_removeAssociatedObjects(id object)此方法移除指定对象的全部关联对象。\n\n\n在设置关联对象值时，通常使用静态全局变量做键。\n“关联对象”缺点：常会引入难以查找的bug。\n第11条：理解 objc_msgSend 的作用在对象上调用方法又叫“传递消息”，消息有“名称”（name）或“选择子”（selector），可以接受参数，而且可能还有返回值。传递消息会使用动态绑定机制来决定需要调用的方法。\n给对象发送消息可以这样来写：\n1id returnValue &#x3D; [someObject messageName:parameter];\n\n在本例中，someObject叫做“接受者”（receiver），messageName 叫做“选择子”（selector）。选择子和参数合起来称为“消息”（message）。编译器看到消息后，将其转换为一条标准的C语言函数调用，也是消息传递机制中的核心函数，叫做 objc_msgSend，其“原型”如下：\n1void objc_msgSend(id self, SEL cmd, ...)\n\n这是个“参数个数可变的函数”，能接受两个及以上的参数。第一个参数代表接受者，第二个参数代表选择子（SEL 是选择子的类型），后续参数就是消息中的参数，其顺序不变。编译器会把刚才那个例子中的消息转换为如下函数：\n1id returnValue &#x3D; objc_msgSend(someObject,2                              @selector(messageName:),3                              parameter);\n\nobjc_msgSend 函数会依据接受者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接受者所属的类中搜寻其“方法列表”，如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，就沿着继承体系继续向上查找，找到合适的方法再跳转。如果最终还是找不到相符的方法，就执行“消息转发”操作。\n还有一些特殊情况的函数：\n\nobjc_msgSend_stret：待发送的消息要返回结构体\n\nobjc_msgSend_fpret：消息返回的是浮点数\n\nobjc_msgSendSuper：要给超类发信息，例如 [super message:parameter];\n\n\n第12条：理解消息转发机制编译器无法确定某类型对象到底能解读多少种选择子，因为运行期还可向其中动态新增。\n当对象收到无法解读的消息后，就会启动“消息转发”机制。消息转发流程：\n\n通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。\n对象可以把其无法解读的某些选择子转交给其他对象来处理。\n经过上述两步之后，如果还是没有办法处理选择子，那就启动完整的消息转发机制。\n\n动态方法解析\n对象在收到无法解读的消息后，首先将调用其所属类的这个类方法：\n1&#x2F;&#x2F; 表示这个类是否能新增一个实例方法用以处理选择子2+ (BOOL)resolveInstanceMethod:(SEL)selector3&#x2F;&#x2F; 表示这个类是否能新增一个类方法用以处理选择子4+ (BOOL)resolveClassMethod:(SEL)selector\n\n使用此方法的前提：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面。此方案常用来实现@dynamic属性。\n备援接受者\n当前接受者还有第二次处理未知选择子的机会。这一步中，运行期系统会问：能否将这条消息转给其他接受者处理，对应方法：\n1- (id)forwardingTargetForSelector:(SEL)selector\n\n若当前接受者能找到备援对象，则将其返回，若找不到，就返回nil。\n注意：我们无法操作经由这一步所转发的消息，若想在发送给备援接受者之前先修改消息内容，得通过完整的消息转发机制。\n完整的消息转发\n首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节（包括选择子、目标及参数）都封于其中。在触发 NSInvocation 对象时，“消息派发系统”将亲自出马，把消息指派给目标对象。此步骤会调用：\n1- (void)forwardInvocation:(NSInvocation)\n\n实现此方法时，若发现某调用操作不应由本类处理，则需调用超类的同名方法，直至 NSObject。如果调用了 NSObject 类，那么该方法还会继而调用“doesNotRecognizeSelector:”以抛出异常，此异常表明选择子最终未能得到处理。\n消息转发全流程\n\n\n第13条：用“方法调配技术”调试“黑盒方法”在运行期，可以向类中新增或替换选择子所对应的方法实现。\n使用另一份实现来替换原有的方法实现，这道工序叫“方法调配”，开发者常用此技术向原有实现中添加新功能。\n类的方法列表会把选择子的名称映射到相关的方法实现之上，使得“动态消息派发系统”能够根据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做IMP，其原型如下：\n1id (*IMP)(id, SEL,...)\n\n以互换NSString大小写的两个方法为例：\n1Method originalMethod &#x3D; class_getInstanceMethod([NSString class], @selector(lowercaseString));2Method swappedMethod &#x3D; class_getInstanceMethod([NSString class], @selector(uppercaseString));3method_exchangeImplementations(originalMethod, swappedMethod)\n\n一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用，否则会令代码变得不易读懂且难以维护。\n第14条：理解”类对象”的用意对象类型并非在编译器就绑定好了，而是在运行期查找。有个特殊的类型叫做 id，它能指代任意的 Objective-C 对象类型。\n“在运行期检视对象类型”这一操作也叫做“类型信息查询”（“内省”），这个强大而有用的特性内置于 Foundation 框架的 NSObject 协议里，凡事由公共根类集成而来的对象都要遵从此协议。\nObjective-C 对象的本质是什么？\n每个 Objective-C 对象实例都是指向某块内存数据的指针。\n1NSString *pointerVariable &#x3D; @&quot;Some string&quot;;\n\n对于通用的对象类型 id，由于其本身已经是指针了，所以可以这样写：\n1id genericTypeString &#x3D; @&quot;Some string&quot;;\n\n假设有个名为 SomeClass 的子类从 NSObject 中继承而来，则其继承体系如下图所示：\n\n\nsuper_class 指针确立了继承关系，而 isa 指针描述实例所属的类。\n如果对象类型无法在编译器确定，那么就应该使用类型信息查询方法来探知。“isMemberOfClass:”能够判断出对象是否为某个特定类的实例，而“isKindOfClass:” 则能够判断出对象是否为某类或其派生类的实例，例如：\n1NSMutableDictionary *dict &#x3D; [NSMutableDictionary new];2[dict isMemberOfClass:[NSDictionary class]]; &#x2F;&#x2F;&#x2F; &lt;NO3[dict isMemberOfClass:[NSMutableDictionary class]]; &#x2F;&#x2F;&#x2F; &lt;YES4[dict isKindOfClass:[NSDictionary class]]; &#x2F;&#x2F;&#x2F; &lt;YES5[dict isKindOfClass:[NSArray class]]; &#x2F;&#x2F;&#x2F; &lt;NO\n\n尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。\n\n参考资料：《Effective Objective-C 2.0》编写高质量iOS与OS X代码的52个有效方法\n","plink":"https://fiteen.top/EOC2.0-Chapter-2/"},{"title":"《Effective Objective-C 2.0》整理（一）：熟悉Objective-C","date":"2016-08-25T14:55:33.000Z","date_formatted":{"ll":"Aug 25, 2016","L":"08/25/2016","MM-DD":"08-25"},"updated":"2019-12-05T03:30:02.970Z","content":"第1条：了解 Objective-C 语言的起源Objective-C 由消息型语言的鼻祖 Smalltalk 演化而来，是一门面向对象的语言，具有封装、继承、多态的特性。它还包括三大动态特性：\n\n动态类型：id 类型，静态类型是弱类型，动态类型是强类型\n动态绑定：基于动态类型，一旦类型被确定，对象对应的属性和相应消息都被确定\n动态加载：按需加载，例如不同机型适配，加载图片（1x/2x/3x），按需加载可执行代码，而非所有组件\n\n\n\n\n\n\n语言类型\n运行时执行的代码由谁决定\n举例\n\n\n\n消息结构\n运行环境\nObjective-C\n\n\n函数调用\n编译器\nC++\n\n\n因此，Objective-C 使用动态绑定的消息结构，在运行时才会检查对象类型。接受一条消息后，究竟执行何种代码，由运行期环境而非编译器决定。\nObjective-C 的重要工作都由“运行期组件”（ runtime component ）完成，它面向对象所需的全部数据结构及函数特性都在运行期组件里。运行器组件本质上就是一种与开发者所编代码相链接的“动态库”，其代码能把开发者编写的所有程序粘连起来。\nObjective-C 是 C 的超集，因此 C 的所有功能在Objective-C代码中依然适用。理解 C 中的内存模型（ memory model ）有助于理解 Objective-C 的内存模型和“引用计数”（ reference counting ）机制的工作原理。\nObjective-C 语言中的指针是用来指示对象的，对象所占内存总是分配在“堆空间”中，而不会分配在栈上。分配在堆上的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时清理。\n第2条：在类的头文件中尽量少引入其他头文件在类的头文件中声明其他类有以下两种选择：\n11 - #import &quot;类名.h&quot; &#x2F;&#x2F; 需要知道该类的全部细节22 - @class 类名; &#x2F;&#x2F; 向前声明，不需要知道该类全部细节，能解决了两个类循环引用的问题\n除非却有必要，否则不要引入头文件。一般，在头文件中向前声明某类，并在实现文件引入某类头文件，这样做可以降低类之间的耦合，以减少编译时间。\n以下情况必须在头文件中引入其他头文件：\n\n如果类继承自某个父类，必须引入定义那个父类的头文件；\n声明的类遵循某个协议，该协议必须有完整定义，且不能使用向前声明。因此最好把协议单独放在一个头文件中。\n\n针对一些委托协议，建议在实现文件中引入头文件，在“ class-continue 分类”中遵循协议。\n第3条：多用字面语法，少用与之等价的方法字面量语法采用类C的定义方式，可以缩减源代码长度，易读性强。\n常规做法：Number *someNumber = [NSNumber numberWithInt:1]; =&gt; 字面量语法：Number * someNumber = @1;\n** 字面数值 **\n1Number *intNumber &#x3D; @1;2Number *floatNumber &#x3D; @2.5f;3Number *doubleNumber &#x3D; @3.14159;4Number *charNumber &#x3D; @&#39;a&#39;;\n** 字面量数组 **\n 1&#x2F;&#x2F; 常规做法2NSArray *animals &#x3D; [NSArray arrayWithObjects:@&quot;cat&quot;,@&quot;dog&quot;,@&quot;mouse&quot;,nil]; &#x2F;&#x2F; 发现空值nil创建结束3NSString *dog &#x3D; [animals objectAtIndex:1];45&#x2F;&#x2F; 字面量语法（更安全，出现nil对象，编译器时就会发现异常）6NSArray *animals &#x3D; @[@&quot;cat&quot;,@&quot;dog&quot;,@&quot;mouse&quot;]; &#x2F;&#x2F; 发现空值nil会抛出异常7NSString *dog &#x3D; animals[1];\n** 字面量字典 **\n 1&#x2F;&#x2F; 常规做法2NSDictionary *personData &#x3D; [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Matt&quot;,@&quot;firstName&quot;,[NSNumber numberWithInt:28],@&quot;age&quot;,nil];3NSString *firstName &#x3D; [personData objectForKey:@&quot;firstName&quot;];45&#x2F;&#x2F; 字面量语法6NSDictionary *personData &#x3D; @&#123;@&quot;firstName&quot; : @&quot;Matt&quot;, @&quot;age&quot; : @28&#125;;7NSString *firstName &#x3D; personData[@&quot;firstName&quot;];\n** 可变数组与字典 **\n1&#x2F;&#x2F; 常规做法2[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];3[mutableDictionary setObject:@&quot;Matt&quot; forKey:@&quot;firstName&quot;];45&#x2F;&#x2F; 字面量语法6mutableArray[1] &#x3D; @&quot;dog&quot;;7mutableDictionary[@&quot;firstName&quot;] &#x3D; @&quot;Matt&quot;;\n\n注意：用字面量语法创建数组或字典时，务必确保值中不含nil。\n第4条：多用类型常量，少用 #define 预处理指令定义常量时，尽量不要使用 #define 预处理指令，由于没有声明明确的类型信息，会将相同名字的常量值批量替换。取而代之的，采用static const 类型 常量名 = 常量值的形式。\n派发通知时，需要使用字符串来表示此项通知的名称，而这个名字就可以声明为一个外界可见的常值变量。此类常值变量需放在“全局符号表”中，以便在定义的编译单元之外使用，定义方式如下：\n1&#x2F;&#x2F; In the header file2extern NSString *const EOCStringConstant; &#x2F;&#x2F; 注意const修饰符在常量类型中的位置34&#x2F;&#x2F; In the implementation file5NSString *const EOCStringConstant &#x3D; @&quot;VALUE&quot;; &#x2F;&#x2F; 解读：一个常量，而这个常量是指针，指向NSString对象\nextern这个关键字就是告诉编译器无须查看常量的定义，直接允许使用。其他类型的常量也是如此：\n1&#x2F;&#x2F; 在头文件 EOCAnimatedView.h 中使用extern来声明全局常量2&#x2F;&#x2F; 这种常量要出现在全局符号表中，所以其名称通常以与之相关的类名做前缀3extern const NSTimeInterval EOCAnimationDuration;45&#x2F;&#x2F; 在实现文件 EOCAnimatedView.m 中定义其值6const NSTimeInterval EOCAnimationDuration &#x3D; 0.3;\n\n第5条：用枚举表示状态、选项、状态码枚举是一种常量命名方式，某个对象所经历的各种状态可定义为一个简单的枚举集。定义方式如下：\n1&#x2F;&#x2F; 方式一：2enum EOCConnectionState &#123;3    &#x2F;&#x2F; 编译器会为枚举分配一个独有的编号，从0开始，每个枚举递增14    EOCConnectionStateDisconnected, &#x2F;&#x2F; 05    EOCConnectionStateConnecting, &#x2F;&#x2F; 16    EOCConnectionStateConnected, &#x2F;&#x2F; 27&#125;;89enum EOCConnectionState state &#x3D; EOCConnectionStateConnected;1011&#x2F;&#x2F; 方式二：12enum EOCConnectionState &#123;13    EOCConnectionStateDisconnected &#x3D; 1, &#x2F;&#x2F; 114    EOCConnectionStateConnecting, &#x2F;&#x2F; 215    EOCConnectionStateConnected, &#x2F;&#x2F; 316&#125;;17typedef enum EOCConnectionState EOCConnectionState;1819EOCConnectionState state &#x3D; EOCConnectionStateConnected;\n\n如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，就将各选项值定义为2的幂，以便通过安位或操作将其组合。\n1typedef enum EOCPermittedDirection : int EOCPermittedDirection;2enum EOCPermittedDirection : int &#123;3    EOCPermittedDirectionUp    &#x3D; 1 &lt;&lt; 0,4    EOCPermittedDirectionDown  &#x3D; 1 &lt;&lt; 1,5    EOCPermittedDirectionLeft  &#x3D; 1 &lt;&lt; 2,6    EOCPermittedDirectionRight &#x3D; 1 &lt;&lt; 3,7&#125;;89EOCPermittedDirection *permittedDirections &#x3D; EOCPermittedDirectionLeft | EOCPermittedDirectionUp;\n\n用 NS_ENUM（不需要互相组合） 与 NS_OPTIONS（需要安位或组合） 宏来定义枚举类型，并指明其底层数据类型，这样做可以确保枚举是开发者所选的底层数据类型实现出来的。\n在处理枚举类型的switch语句中不要实现default分支。因为这样相当于加入了一种新的枚举类型。\n\n参考资料：《Effective Objective-C 2.0》编写高质量iOS与OS X代码的52个有效方法\n","plink":"https://fiteen.top/EOC2.0-Chapter-1/"},{"title":"Hello World","date":"2016-08-12T16:00:00.000Z","date_formatted":{"ll":"Aug 13, 2016","L":"08/13/2016","MM-DD":"08-13"},"updated":"2019-12-05T03:33:58.429Z","content":"标题是 Hexo 默认生成的，却没来由得契合。『Hello，World』——计算机发展史上的里程碑式的一笔，每一门编程语言的入门示例，Brian Kernighan 在《C 程序设计语言》中第一次引用的 Hello World 程序，源自他1973年编写的一部讲授B语言的编程教程：\n\n\n1main() &#123;2extrn a,b,c;3putchar(a); putchar(b); putchar(c); putchar('!*n');4&#125;56a 'hell';7b 'o, w';8c 'orld';\n\n『Hello，World』，总令我想起那高亢的一句：“这世界我来了 任凭风暴漩涡”。临世，是随机事件，可人们无法计算概率，只晓得0 | 1、false | true、fail | success。巅峰时簇拥欢呼，落寞时笑骂离开，艰难困苦大都无人问津。矛盾是事物发展的源泉和动力，这世界温情又冷漠，有人清醒有人混沌，七亿网民被快餐文化蚕食着，或又被欲望鲸吞。\n最近发生了一些事，或许吵吵嚷嚷的人其实最不舍，说出来的是情绪，分别却需要勇气。也许我也该学着接受一些人的处世手段和方式。果然戏剧来源于生活不假，毕竟这是一个弱肉强食的社会，我们都是因为互补的需要相遇，我无法理解的状态在旁人看来却只是简单的各取所需。\n尽管我不是一个偏执的人，却也有小任性，也许若干年的自己想如今只剩一句“你还是太年轻！”，可是啊，哪怕这不是一个合适的时机，人总有追求更多拥有真善美的权利吧。愿你出走半生，归来仍是少年。这样初心不改的期盼到底会不会在岁月的洪流中被侵蚀，未来谁又说得好呢？\n最近在社交平台上删除了许多青春时期敏感晦涩的字句，小女孩啊，总有那么多悲春伤秋，我还是没有足够强大去面对曾经的自己，仿佛记忆会随着删除按钮的点击一同清空。文字很奇妙，它比滔滔不绝的喜悦或怨气要安宁些，四通八达的网络，不知道会让哪个陌生的你与我在此遇见，但祝愿我们都爱世人，察世事，做不到兼济天下，也要先独善其身。\n","plink":"https://fiteen.top/hello-world/"}]