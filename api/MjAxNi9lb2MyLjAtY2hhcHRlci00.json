{"title":"《Effective Objective-C 2.0》整理（四）：协议与分类","date":"2016-09-28T12:21:06.000Z","date_formatted":{"ll":"Sep 28, 2016","L":"09/28/2016","MM-DD":"09-28"},"link":"2016/eoc2.0-chapter-4","tags":["《Effective Objective-C 2.0》"],"categories":["iOS"],"updated":"2019-12-05T03:29:58.204Z","content":"<h3 id=\"第23条：通过委托与数据源协议进行对象间通信\">第23条：通过委托与数据源协议进行对象间通信<a href=\"2016/eoc2.0-chapter-4#第23条：通过委托与数据源协议进行对象间通信\"></a></h3><p>Objective-C 开发中广泛使用“委托模式”来实现对象间的通信，该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”（delegate）。而“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。</p>\n<a id=\"more\"></a>\n\n<p>此模式可将数据和业务逻辑解耦。例如，用户界面有个显示一系列数据所用的视图，视图对象的属性中，可以包含负责数据和事件处理的对象。这两种对象分别称为“数据源”（data source）与“委托”（delegate）。</p>\n<p>委托（代理模式）（Delegate）：委托别人办事，自己不处理，交给别人处理；</p>\n<p>协议（Protocol）：使用了这个协议就要按照协议办事</p>\n<p>下面总结一下委托模式的实现，委托方：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; .h 文件中</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 定义协议</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol ClassADelegate</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 协议中不标注，默认为 @required 类型，必须实现</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)methodA;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">@optional</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 特别标注了 @optional 类型，表示可以不实现</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)methodB;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ClassA : NSObject</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 引用，存代理方</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">@property (nonatomic, weak) id &lt;ClassADelegate&gt; delegate;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; .m 中在合适的时机给代理方发消息</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ClassB</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)rightTimeMethod &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#x2F;&#x2F; 实现 @requiered 方法 methodA</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">    [self.delegate methodA];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#x2F;&#x2F; 实现 @optional 方法 methodB</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">    if ([self.delegate respondsToSelector:@selector(methodB)]) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">        [self.delegate methodB];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">24</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">25</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">26</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr></table></div></figure>\n\n<p>在这里需要注意的是：<strong>delegate 属性需要定义成 weak，而非 strong。因为两者之间必须为“非拥有关系”，否则会造成循环引用，从而导致内存泄漏</strong>。</p>\n<p>而代理方则需要：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 遵守协议</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ClassB() &lt;ClassADelegate&gt;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ClassB</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 实现方法</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - ClassADelegate</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)methodA &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#x2F;&#x2F; how to implementation methodA</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 将自己设置为代理方</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)rightTimeMethod &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tClassA classA &#x3D; [ClassA new];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tclassA.delegate &#x3D; self;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr></table></div></figure>\n\n\n\n<h3 id=\"第24条：将类的实现代码分散到便于管理的数个分类之中\">第24条：将类的实现代码分散到便于管理的数个分类之中<a href=\"2016/eoc2.0-chapter-4#第24条：将类的实现代码分散到便于管理的数个分类之中\"></a></h3><p>当一个类中充斥了大量的方法实现时，可以通过分类这种模式将这个庞大的类打散，例如：</p>\n<ul>\n<li>EOCPerson+Friendship(.h/.m)</li>\n<li>EOCPerson+Work(.h/.m)</li>\n<li>EOCPerson+Play(.h/.m)</li>\n</ul>\n<p>通过分类机制，可以把类的代码分成多个易于管理的小块，归入不同的“功能区”，以便单独检视，也便于调试。</p>\n<p>在编写准备分享给其他开发者使用的程序库时，可以考虑创建 Private 分类，如果程序库中的某个地方要用到这些方法，那就引入此分类的头文件。而分类的头文件并不随程序库一并公开，于是该库的使用者也就不知道库里还有这些私有方法了。</p>\n<h3 id=\"第25条：总是为第三方类的分类名称加前缀\">第25条：总是为第三方类的分类名称加前缀<a href=\"2016/eoc2.0-chapter-4#第25条：总是为第三方类的分类名称加前缀\"></a></h3><p>如果分类中有何原有类同名的方法，会优先调用分类中的方法，同名方法调用的优先级为<strong>分类 &gt; 本类 &gt; 父类</strong>。如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定，编译器会执行最后一个参与编译的分类中的方法。</p>\n<p>为了避免分类覆盖，可以通过给类名和方法名都加专属前缀的方式解决。</p>\n<p>例如：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">@interface NSString (ABC_HTTP)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Encode a string with URL encoding</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSString *)abc_urlEncodedString;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Decode a URL encode string</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSString *)abc_urlDecodedString;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr></table></div></figure>\n\n\n\n<h3 id=\"第26条：勿在分类中声明属性\">第26条：勿在分类中声明属性<a href=\"2016/eoc2.0-chapter-4#第26条：勿在分类中声明属性\"></a></h3><p>除了“class-continuation 分类”之外，其他分类都无法向类中新增实例变量。原因是分类无法合成与属性相关的实例变量。分类中可以写 @property，但不会生成 setter/getter 方法，也不会生成实现以及私有的成员变量，会编译通过，但是引用变量会报错。</p>\n<p>简单地说，分类是运行期决议的，在运行期，对象的内存布局已经确定了，如果此时添加实例变量会破坏类的内部结构。</p>\n<p>但是如果一定要添加，也是可以通过分类中为该属性实现存取方法来实现。如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;objc&#x2F;runtime.h&gt;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">static const char *kFriendsPropertyKey &#x3D; &quot;kFriendsPropertyKey&quot;;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation EOCPerson (Friends)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)friends &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">    return objc_getAssociatedObject(self, kFriendsPropertyKey);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setFriends:(NSArray *)friends &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">    objc_setAssociatedObject(self,</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">                             kFriendsPropertyKey,</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">                             friends,</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">                             OBJC_ASSCIATIOM_RETAIN_NONATOMIC);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr></table></div></figure>\n\n<p>但是这种做法并不推荐。分类机制，应该理解为一种手段，目标在于拓展类的功能，而非封装数据。最好的做法，就是将封装数据所用的全部属性都定义在主接口里。</p>\n<h3 id=\"第27条：使用“class-continuation-分类”隐藏实现细节\">第27条：使用“class-continuation 分类”隐藏实现细节<a href=\"2016/eoc2.0-chapter-4#第27条：使用“class-continuation-分类”隐藏实现细节\"></a></h3><p>分类的主要作用是为已经存在的类添加方法，因为分类的结构体指针中，没有属性列表，只有方法列表。本章介绍的是一种特殊的分类“class-continuation”，用于定义一些无需对外公布的方法及实例变量。形如：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ClassA.h&quot;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ClassA ()</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 定义你所需要的私有变量或方法</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ClassA</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 实现</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">@end</span></pre></td></tr></table></div></figure>\n\n<p>若想使类所遵循的协议不为人所知，也可以在“class-continuation 分类”中声明。</p>\n<h3 id=\"第28条：通过协议提供匿名对象\">第28条：通过协议提供匿名对象<a href=\"2016/eoc2.0-chapter-4#第28条：通过协议提供匿名对象\"></a></h3><p>协议定义了一系列方法，遵从此协议的对象应该实现它们。于是，我们可以用协议把自己所写的 API 之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯 id 类型，这样，想隐藏的类型就不会出现在 API 之中了。例如 ClassA、ClassB 都会遵循某个协议 EOCDelegate，假如指定类型，就会这样约定：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">@property (nonatomic ,weak) ClassA &lt;EOCDelegate&gt; delegate;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">@property (nonatomic ,weak) ClassB &lt;EOCDelegate&gt; delegate;</span></pre></td></tr></table></div></figure>\n\n<p>如果不想指明具体使用哪个类，就可以将 delegate 对象约定成 纯 id 类型，这个对象也可以称之为“匿名对象”。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">@property (nonatomic ,weak) id &lt;EOCDelegate&gt; delegate;</span></pre></td></tr></table></div></figure>\n\n<p>总结一下：</p>\n<ul>\n<li>协议可以在某种程度上提供匿名对象，具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。</li>\n<li>使用匿名对象来隐藏类型名称（或类名）。</li>\n<li>如果具体类型不重要，重要的是对象能否处理好一些特定的方法，那么就可以使用这种协议匿名对象来完成。</li>\n</ul>\n<hr>\n<p>参考资料：<a href=\"https://book.douban.com/subject/25829244/\" target=\"_blank\" rel=\"noopener\">《Effective Objective-C 2.0》编写高质量iOS与OS X代码的52个有效方法</a></p>\n","prev":{"title":"Git 手册之用 .gitignore 忽略文件","link":"2016/git-ignore"},"next":{"title":"《Effective Objective-C 2.0》整理（三）：接口与 API 设计","link":"2016/eoc2.0-chapter-3"},"plink":"https://blog.fiteen.top/2016/eoc2.0-chapter-4/","copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/2016/eoc2.0-chapter-4/\" title=\"《Effective Objective-C 2.0》整理（四）：协议与分类\">https://blog.fiteen.top/2016/eoc2.0-chapter-4/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}