{"title":"一次搞懂时间复杂度和空间复杂度","date":"2017-01-07T18:17:34.000Z","date_formatted":{"ll":"Jan 8, 2017","L":"01/08/2017","MM-DD":"01-08"},"link":"asymptotic-time-complexity-and-space-complexity","tags":["数据结构"],"categories":["算法"],"updated":"2019-12-28T12:23:23.771Z","content":"<p>学习数据结构和算法时，难免提到时间复杂度（asymptotic time complexity）和空间复杂度（space complexity）的概念。</p>\n<h2 id=\"时间复杂度\">时间复杂度<a href=\"asymptotic-time-complexity-and-space-complexity#时间复杂度\"></a></h2><p>概念：描述一个算法<strong>执行时间</strong>与数据规模的增长关系，记作：T(n) = O(f(n))。</p>\n<p>计算时间复杂度时，需要遵循这一条原则：<strong>如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时时间复杂度就是 O(f(n))。</strong></p>\n<p>比如：</p>\n<p>T(n)=n+5，时间复杂度为 O(n)；</p>\n<p>T(n)=n³+n²+1，时间复杂度为 O(n³)；</p>\n<p>T(n)=4n³，时间复杂度为 O(n³)。</p>\n<p>下面举几个例子：</p>\n<h3 id=\"常数阶\">常数阶<a href=\"asymptotic-time-complexity-and-space-complexity#常数阶\"></a></h3><p>我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c 为一个常数时，我们说这个算法的时间复杂度为 O(1)。 <strong>哈希算法就是典型的 O(1) 时间复杂度</strong>，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">100</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum = n * (n + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%i\\n\"</span>, sum);</span></pre></td></tr></table></div></figure>\n\n<p>像上面这段代码，无论 n 是多少，运行步骤都一样，所以时间复杂度是 O(1)。</p>\n<h3 id=\"线性阶\">线性阶<a href=\"asymptotic-time-complexity-and-space-complexity#线性阶\"></a></h3><p>O(n) 代表数据量增大 n 倍，耗时也增大 n 倍，比如常见的<strong>遍历算法</strong>。</p>\n<p>对于一个循环，假设循环体的时间复杂度为 O(m)，循环次数为 n，那么循环的时间复杂度为 O(m×n)；</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;        <span class=\"comment\">// 循环次数为 n</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello, World!\\n\"</span>);      <span class=\"comment\">// 循环体时间复杂度为 O(1)</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></div></figure>\n\n<p>此时时间复杂度为 O(1×n)，即 O(n)。</p>\n<h3 id=\"平方阶\">平方阶<a href=\"asymptotic-time-complexity-and-space-complexity#平方阶\"></a></h3><p>Ο(n²)：代表数据量增大 n 倍，时间复杂度就是 n² ，比如<strong>冒泡排序</strong>。</p>\n<p>对于下面这个多循环，循环次数为 n×n，那么时间复杂度为 O(n × n × 1)，即 O(n²)。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello, World!\\n\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></div></figure>\n\n<h3 id=\"对数阶\">对数阶<a href=\"asymptotic-time-complexity-and-space-complexity#对数阶\"></a></h3><p>O(logn)：当数据增大 n 倍时，耗时增大 logn 倍。比如下面这段代码，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">  i *= <span class=\"number\">2</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%i\\n\"</span>, i);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></div></figure>\n\n<p><strong>二分查找</strong>的时间复杂度就是 O(logn)。</p>\n<h3 id=\"对数阶乘以-n\">对数阶乘以 n<a href=\"asymptotic-time-complexity-and-space-complexity#对数阶乘以-n\"></a></h3><p>O(nlogn)：当数据增大 n 倍时，耗时增大 nlogn 倍，比如。比如下面这段代码，当数据增大256倍时，耗时增大256*8=2048倍，这个复杂度高于线性阶低于平方阶。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    i *= <span class=\"number\">2</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%i\\n\"</span>, i);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></div></figure>\n\n<p><strong>归并排序</strong>的时间复杂度就是 O(nlogn)。</p>\n<h3 id=\"指数阶\">指数阶<a href=\"asymptotic-time-complexity-and-space-complexity#指数阶\"></a></h3><p>O(2^n)：当数据增大 n 倍时，耗时增大 2^n 倍，比如斐波那契数列：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">aFunc</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">return</span> aFunc(n - <span class=\"number\">1</span>) + aFunc(n - <span class=\"number\">2</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">  &#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></div></figure>\n\n<p>常见的算法时间复杂度由小到大依次为：</p>\n<p>Ο(1)＜Ο(logn)＜Ο(n)＜Ο(nlogn)＜Ο(n²)＜Ο(2^n)</p>\n<h2 id=\"空间复杂度\">空间复杂度<a href=\"asymptotic-time-complexity-and-space-complexity#空间复杂度\"></a></h2><p>概念：描述一个算法<strong>占用空间</strong>与数据规模的增长关系，记作：S(n) = O(f(n))。</p>\n<p>一个算法在计算机上占用的内存包括：程序代码所占用的空间、输入输出数据所占用的空间、辅助变量所占用的空间这三个方面。程序代码所占用的空间取决于算法本身的长短，输入输出数据所占用的空间取决于要解决的问题，是通过参数表调用函数传递而来，只有辅助变量是算法运行过程中临时占用的存储空间，与空间复杂度相关。</p>\n<p>通常来说，只要算法不涉及到动态分配的空间以及递归、栈所需的空间，空间复杂度通常为 O(1)。</p>\n<p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。</p>\n","prev":{"title":"你应该了解的 IDFA","link":"IDFA"},"next":{"title":"『2016』莫愁前路无知己","link":"annual-summary-2016"},"plink":"https://blog.fiteen.top/asymptotic-time-complexity-and-space-complexity/","toc":[{"title":"时间复杂度","id":"时间复杂度","index":"1","children":[{"title":"常数阶","id":"常数阶","index":"1.1"},{"title":"线性阶","id":"线性阶","index":"1.2"},{"title":"平方阶","id":"平方阶","index":"1.3"},{"title":"对数阶","id":"对数阶","index":"1.4"},{"title":"对数阶乘以 n","id":"对数阶乘以-n","index":"1.5"},{"title":"指数阶","id":"指数阶","index":"1.6"}]},{"title":"空间复杂度","id":"空间复杂度","index":"2"}],"copyright":{"author":"FiTeen","link":"<a href=\"https://blog.fiteen.top/asymptotic-time-complexity-and-space-complexity/\" title=\"一次搞懂时间复杂度和空间复杂度\">https://blog.fiteen.top/asymptotic-time-complexity-and-space-complexity/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}