<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FiTeen&#39;s Blog</title>
  
  <subtitle>林深时见鹿,海蓝时见鲸。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.fiteen.top/"/>
  <updated>2020-02-23T08:30:44.000Z</updated>
  <id>https://blog.fiteen.top/</id>
  
  <author>
    <name>FiTeen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 内存泄漏场景与解决方案</title>
    <link href="https://blog.fiteen.top/2020/ios-memory-leak/"/>
    <id>https://blog.fiteen.top/2020/ios-memory-leak/</id>
    <published>2020-02-16T14:07:00.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>内存泄漏</strong>指的是程序中已动态分配的<strong>堆内存</strong>（程序员自己管理的空间）由于某些原因未能释放或无法释放，造成系统内存的浪费，导致程序运行速度变慢甚至系统崩溃。</p><a id="more"></a><p>在 iOS 开发中会遇到的内存泄漏场景可以分为几类：</p><h2 id="循环引用">循环引用<a href="#循环引用" title="循环引用"></a></h2><p>当对象 A 强引用对象 B，而对象 B 又强引用对象 A，或者多个对象互相强引用形成一个闭环，这就是<strong>循环引用</strong>。</p><h3 id="block">Block<a href="#block" title="Block"></a></h3><p>Block 会对其内部的对象强引用，因此使用的时候需要确保不会形成循环引用。</p><p>举个例子，看下面这段代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block();</span><br></pre></td></tr></table></figure><p><code>block</code> 是 <code>self</code> 的属性，因此 <code>self</code> 强引用了 <code>block</code>，而 <code>block</code> 内部又调用了 <code>self</code>，因此 <code>block</code> 也强引用了 <code>self</code>。要解决这个循环引用的问题，有两种思路。</p><h4 id="使用-weak-strong-dance">使用 Weak-Strong Dance<a href="#使用-weak-strong-dance" title="使用 Weak-Strong Dance"></a></h4><p>先用 <code>__weak</code> 将 <code>self</code> 置为弱引用，打破“循环”关系，但是 <code>weakSelf</code> 在 <code>block</code> 中可能被提前释放，因此还需要在 <code>block</code> 内部，用 <code>__strong</code> 对 <code>weakSelf</code> 进行强引用，这样可以确保 <code>strongSelf</code> 在 <code>block</code> 结束后才会被释放。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, strongSelf.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block();</span><br></pre></td></tr></table></figure><h4 id="断开持有关系">断开持有关系<a href="#断开持有关系" title="断开持有关系"></a></h4><p>使用 <code>__block</code> 关键字设置一个指针 <code>vc</code> 指向 <code>self</code>，重新形成一个 <code>self → block → vc → self</code> 的循环持有链。在调用结束后，将 <code>vc</code> 置为 <code>nil</code>，就能断开循环持有链，从而令 <code>self</code> 正常释放。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">UIViewController</span> *vc = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, vc.name);</span><br><span class="line">        vc = <span class="literal">nil</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block();</span><br></pre></td></tr></table></figure><p>这里还要补充一个问题，为什么要用 <code>__block</code> 修饰 <code>vc</code>？</p><p>首先，<code>block</code> 本身不允许修改外部变量的值。但被 <code>__block</code> 修饰的变量会被存在了一个栈的结构体当中，成为结构体指针。当这个对象被 <code>block</code> 持有，就将“外部变量”在栈中的内存地址放到堆中，进而可以在 <code>block</code> 内部修改外部变量的值。</p><p>还有一种方式可以断开持有关系。就是将 <code>self</code> 以传参的形式传入 <code>block</code> 内部，这样 <code>self</code> 就不会被 <code>block</code> 持用，也就不会形成循环持有链。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.block = ^(<span class="built_in">UIViewController</span> *vc)&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, vc.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block(<span class="keyword">self</span>);</span><br></pre></td></tr></table></figure><h3 id="nstimer">NSTimer<a href="#nstimer" title="NSTimer"></a></h3><p>我们知道 <code>NSTimer</code> 对象是采用 <code>target-action</code> 方式创建的，通常 <code>target</code> 就是类本身，而我们为了方便又常把 <code>NSTimer</code> 声明为属性，像这样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种创建方式，timer 默认添加进 runloop</span></span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span>f target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timeFire) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 第二种创建方式，需要手动将 timer 添加进 runloop</span></span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span>f target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timeFire) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><p>这就形成了 <code>self → timer → self(target)</code> 的循环持有链。只要 <code>self</code> 不释放，<code>dealloc</code> 就不会执行，<code>timer</code> 就无法在 <code>dealloc</code> 中销毁，<code>self</code> 始终被强引用，永远得不到释放，循环矛盾，最终造成内存泄漏。</p><p>那么如果只把 <code>timer</code> 作为局部变量，而不是属性呢？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span>f target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timeFire) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><p><code>self</code> 同样释放不了。</p><p>因为在加入 runloop 的操作中，<code>timer</code> 被强引用，这就形成了一条 <code>runloop → timer → self(target)</code> 的持有链。而 <code>timer</code> 作为局部变量，无法执行 <code>invalidate</code>，所以在 <code>timer</code> 被销毁之前，<code>self</code> 也不会被释放。</p><p>所以只要申请了 <code>timer</code>，加入了 runloop，并且 <code>target</code> 是 <code>self</code>，就算不是循环引用，也会造成内存泄漏，因为 <code>self</code> 没有释放的时机。</p><p>解决这个问题有好几种方式，开发者可以自行选择。</p><h4 id="在合适的时机销毁-nstimer">在合适的时机销毁 NSTimer<a href="#在合适的时机销毁-nstimer" title="在合适的时机销毁 NSTimer"></a></h4><p>当 <code>NSTimer</code> 初始化之后，加入 runloop 会导致被当前的页面强引用，因此不会执行 <code>dealloc</code>。所以需要在合适的时机销毁 <code>_timer</code>，断开 <code>_timer</code>、runloop 和当前页面之间的强引用关系。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_timer invalidate];</span><br><span class="line">_timer = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><p><code>ViewController</code> 中的时机可以选择 <code>didMoveToParentViewController</code>、<code>viewDidDisappear</code>，<code>View</code> 中可以选择 <code>removeFromSuperview</code> 等，但这种方案并一定是正确可行的。</p><p>比如在注册页面中加了一个倒计时，如果在 <code>viewDidDisappear</code> 中销毁了 <code>_timer</code>，当用户点击跳转到用户协议页面时，倒计时就会被提前销毁，这是不合逻辑的。因此需要结合具体业务的需求场景来考虑。</p><h4 id="使用-gcd-的定时器">使用 GCD 的定时器<a href="#使用-gcd-的定时器" title="使用 GCD 的定时器"></a></h4><p>GCD 不基于 runloop，可以用 GCD 的计时器代替 NSTimer 实现计时任务。但需要注意的是，GCD 内部 block 中的循环引用问题还是需要解决的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">dispatch_source_set_timer(_timer, DISPATCH_TIME_NOW, <span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">    [weakSelf timeFire];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开启计时器</span></span><br><span class="line">dispatch_resume(_timer);</span><br><span class="line"><span class="comment">// 销毁计时器</span></span><br><span class="line"><span class="comment">// dispatch_source_cancel(_timer);</span></span><br></pre></td></tr></table></figure><h4 id="借助中介者销毁">借助中介者销毁<a href="#借助中介者销毁" title="借助中介者销毁"></a></h4><p><strong>中介者</strong>指的是用别的对象代替 <code>target</code> 里的 <code>self</code>，中介者绑定 <code>selector</code> 之后，再在 <code>dealloc</code> 中释放 <code>timer</code>。</p><p>这里介绍两种中介者，一种是 NSObject 对象，一种是 NSProxy 的子类。它们的存在是为了断开对 <code>self</code> 的强引用，使之可以被释放。</p><h5 id="以一个-nsobject-对象作为中介者">以一个 NSObject 对象作为中介者<a href="#以一个-nsobject-对象作为中介者" title="以一个 NSObject 对象作为中介者"></a></h5><p>新建一个 NSObject 对象 <code>_target</code>，为它<strong>动态添加</strong>一个方法，方法的地址指向 <code>self</code> 方法列表中的 <code>timeFire</code> 的 IMP。这样 <code>_target</code> 与 <code>self</code> 之间没有直接的引用关系，又能引用 <code>self</code> 里的方法，就不会出现循环引用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_target = [<span class="built_in">NSObject</span> new];</span><br><span class="line">class_addMethod([_target <span class="keyword">class</span>], <span class="keyword">@selector</span>(timeFire), class_getMethodImplementation([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(timeFire)), <span class="string">"v@:"</span>);</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span>f target:_target selector:<span class="keyword">@selector</span>(timeFire) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><h5 id="以-nsproxy-的子类作为中介者">以 NSProxy 的子类作为中介者<a href="#以-nsproxy-的子类作为中介者" title="以 NSProxy 的子类作为中介者"></a></h5><p>创建一个继承自 <code>NSProxy</code> 的子类 <code>WeakProxy</code>，将 <code>timer</code> 的 <code>target</code> 设置为 <code>WeakProxy</code> 实例，利用<strong>完整的消息转发机制</strong>实现执行 <code>self</code> 中的计时方法，解决循环引用。</p><figure class="highlight objc"><figcaption><span>WeakProxy.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> weakTarget;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><figcaption><span>WeakProxy.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    _weakTarget = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    SEL sel = [invocation selector];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.weakTarget respondsToSelector:sel]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.weakTarget];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.weakTarget methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.weakTarget respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后这样创建 <code>timer</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span>f target:[WeakProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(timeFire) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>这时候的循环持有链是这样的：</p><p><img src="/2020/ios-memory-leak/timer-weak-proxy.png" class="φcy"></p><p>由于 <code>WeakProxy</code> 与 <code>self</code> 之间是弱引用关系，<code>self</code> 最终是可以被销毁的。</p><h4 id="带-block-的-timer">带 block 的 timer<a href="#带-block-的-timer" title="带 block 的 timer"></a></h4><p>iOS 10 之后，Apple 提供了一种 block 的方式来解决循环引用的问题。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br></pre></td></tr></table></figure><p>为了兼容 iOS 10 之前的方法，可以写成 NSTimer 分类的形式，将 block 作为 SEL 传入初始化方法中，统一以 block 的形式处理回调。</p><figure class="highlight objc"><figcaption><span>NSTimer+WeakTimer.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSTimer+WeakTimer.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">WeakTimer</span>)</span></span><br><span class="line"> </span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)ht_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                                       repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                                         block:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                         target:<span class="keyword">self</span></span><br><span class="line">                                       selector:<span class="keyword">@selector</span>(ht_blockInvoke:)</span><br><span class="line">                                       userInfo:[block <span class="keyword">copy</span>]</span><br><span class="line">                                        repeats:repeats];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)ht_blockInvoke:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = timer.userInfo;</span><br><span class="line">    <span class="keyword">if</span>(block) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后在需要的类中创建 <code>timer</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> ht_scheduledTimerWithTimeInterval:<span class="number">1.0</span>f repeats:<span class="literal">YES</span> block:^&#123;</span><br><span class="line">    [weakSelf timeFire];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="委托模式">委托模式<a href="#委托模式" title="委托模式"></a></h3><p>委托模式，是对象之间通信的一种设计模式。该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。</p><h4 id="uitableview-的-delegate">UITableView 的 delegate<a href="#uitableview-的-delegate" title="UITableView 的 delegate"></a></h4><p>我们常用的 <code>tableView</code> 与 <code>ViewController</code> 就是<strong>委托方</strong>和<strong>代理方</strong>的关系。</p><p>需要在控制器中加入列表时，通常我们会将 <code>tableView</code> 设为 <code>ViewController</code> 中 <code>view</code> 的子视图，<code>UIViewController</code> 的源码是这样定义 <code>view</code> 的：</p><figure class="highlight objc"><figcaption><span>UIViewController.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">null_resettable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *view;</span><br></pre></td></tr></table></figure><p>因此 <code>ViewController</code> 强引用了 <code>tableView</code>。而 <code>tableView</code> 又要委托 <code>ViewController</code> 帮它实现几个代理方法和数据源方法。如果此时 <code>dataSource</code> 和 <code>delegate</code> 属性用 <code>strong</code> 来修饰，就会出现 <code>UITableView</code> 与 <code>ViewController</code> 互相强引用，形成<strong>循环引用</strong>。</p><p>那么看一下 <code>UITableView</code> 的实现源码，我们会发现其中定义 <code>dataSource</code> 和 <code>delegate</code> 属性时是用 <code>weak</code> 修饰的。</p><figure class="highlight objc"><figcaption><span>UITableView.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> &lt;<span class="built_in">UITableViewDataSource</span>&gt; dataSource;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> &lt;<span class="built_in">UITableViewDelegate</span>&gt; delegate;</span><br></pre></td></tr></table></figure><p>所以 <code>tableView</code> 的 <code>dataSource</code> 和 <code>delegate</code> 只是 <code>weak</code> 指针，指向了 <code>ViewController</code>，它们之间的关系是这样的：</p><p><img src="/2020/ios-memory-leak/tableview-vc-relationship.png" class="φcy"></p><p>这也就避免了循环引用的发生。</p><h4 id="nsurlsession-的-delegate">NSURLSession 的 delegate<a href="#nsurlsession-的-delegate" title="NSURLSession 的 delegate"></a></h4><p>那么 <code>delegate</code> 一定被 <code>weak</code> 修饰吗？</p><p>也不一定，需要看具体的场景。比如 <code>NSURLSession</code> 类中的 <code>delegate</code> 就是用 <code>retain</code> 修饰的。</p><figure class="highlight objc"><figcaption><span>NSURLSession.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="keyword">id</span> &lt;<span class="built_in">NSURLSessionDelegate</span>&gt; delegate;</span><br></pre></td></tr></table></figure><p>它这么做，是因为了确保网络请求回调之前，<code>delegate</code> 不被释放。</p><p>这也间接引起了 <code>AFNetworking</code> 中<strong>循环引用</strong>的出现。我们看 <code>AFURLSessionManager</code> 类中声明的 <code>session</code> 是 <code>strong</code> 类型的。</p><figure class="highlight objc"><figcaption><span>AFURLSessionManager.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The managed session.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br></pre></td></tr></table></figure><p>在构造 <code>session</code> 对象时，也将 <code>delegate</code> 设为了 <code>self</code>，也就是 <code>AFURLSessionManager</code> 类。</p><figure class="highlight objc"><figcaption><span>AFURLSessionManager.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_session) &#123;</span><br><span class="line">            _session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此三者就形成了这样循环持有关系。</p><p><img src="/2020/ios-memory-leak/afn-recycle.png" class="φcy"></p><p>要解决这个问题，有两种解决思路：</p><p><strong>方式一：将 <code>AFHTTPSessionManager</code> 对象设为单例</strong></p><p>对于客户端来说，大多数情况下都是对应同一个后台服务，所以可以将 <code>AFHTTPSessionManager</code> 对象设为单例来处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (AFHTTPSessionManager *)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> AFHTTPSessionManager *_manager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _manager = [AFHTTPSessionManager manager];</span><br><span class="line">        _manager.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">        _manager.responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"application/json"</span>, <span class="string">@"text/html"</span>,<span class="string">@"text/json"</span>, <span class="string">@"text/plain"</span>, <span class="string">@"text/javascript"</span>,<span class="string">@"text/xml"</span>, <span class="literal">nil</span>];</span><br><span class="line">        _manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要设定固定请求头， 以这种 <code>key-value</code> 形式加入到 <code>dispatch_once</code> 中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_manager.requestSerializer setValue:<span class="string">@"application/json;charset=utf-8"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：因为请求的 <code>header</code> 是由 <code>AFHTTPSessionManager</code>的 <code>requestSerializer.mutableHTTPRequestHeaders</code> 字典持有的，所以这种单例模式会导致全局共享一个 <code>header</code>，如果要处理不同自定义 <code>header</code> 的请求就会变得很麻烦。</p><p><strong>方式二：在请求结束时，手动销毁 <code>session</code> 对象</strong></p><p>由于 <code>session</code> 对象对 <code>delegate</code> 强持有，要打破循环引用，需要在请求结束后手动调用 <code>AFHTTPSessionManager</code> 对象销毁的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (AFHTTPSessionManager *)getSessionManager&#123;</span><br><span class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">    manager.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    manager.responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"application/json"</span>, <span class="string">@"text/html"</span>,<span class="string">@"text/json"</span>, <span class="string">@"text/plain"</span>, <span class="string">@"text/javascript"</span>,<span class="string">@"text/xml"</span>, <span class="literal">nil</span>];</span><br><span class="line">    manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendRequest&#123;</span><br><span class="line">    AFHTTPSessionManager *manager = [<span class="keyword">self</span> getSessionManager];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(manager)weakManager = manager;</span><br><span class="line">    [manager GET:<span class="string">@"https://blog.fiteen.top"</span> parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">         __<span class="keyword">strong</span> <span class="keyword">typeof</span> (weakManager)strongManager = weakManager;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"success 回调"</span>);</span><br><span class="line">        [strongManager invalidateSessionCancelingTasks:<span class="literal">YES</span>];</span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span> (weakManager)strongManager = weakManager;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error 回调"</span>);</span><br><span class="line">        [strongManager invalidateSessionCancelingTasks:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非-oc-对象内存处理">非 OC 对象内存处理<a href="#非-oc-对象内存处理" title="非 OC 对象内存处理"></a></h2><p>虽然现在已经普及了 ARC 模式，但它仅对 OC 对象进行自动内存管理。对于非 OC 对象，比如 <code>CoreFoundation</code> 框架下的 <code>CI</code>、<code>CG</code>、<code>CF</code> 等开头的类的对象，在使用完毕后仍需我们手动释放。</p><p>比如这段获取 UUID 的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFUUIDRef</span> puuid = <span class="built_in">CFUUIDCreate</span>( kCFAllocatorDefault );</span><br><span class="line"><span class="built_in">CFStringRef</span> uuidString = <span class="built_in">CFUUIDCreateString</span>( kCFAllocatorDefault, puuid );</span><br><span class="line"><span class="built_in">NSString</span> *uuid = [(<span class="built_in">NSString</span> *)<span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFStringCreateCopy</span>(<span class="literal">NULL</span>, uuidString)) uppercaseString];</span><br><span class="line"><span class="comment">// 使用完后释放 puuid 和 uuidString 对象</span></span><br><span class="line"><span class="built_in">CFRelease</span>(puuid);</span><br><span class="line"><span class="built_in">CFRelease</span>(uuidString);</span><br></pre></td></tr></table></figure><p>还有 C 语言中，如果用 <code>malloc</code> 动态分配内存后，需要用 <code>free</code> 去释放，否则会出现内存泄漏。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">person *p = (person *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(person));</span><br><span class="line"><span class="built_in">strcpy</span>(p-&gt;name,<span class="string">"fiteen"</span>);</span><br><span class="line">p-&gt;age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 使用完释放内存</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="comment">// 防止野指针</span></span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="循环加载引起内存峰值"><span id="peak-mem-usage">循环加载引起内存峰值</span><a href="#循环加载引起内存峰值" title="循环加载引起内存峰值"></a></h2><p>先看下面这段代码，看似没有内存泄漏的问题，但是在实际运行时，for 循环内部产生了大量的临时对象，会出现 CPU 暴增。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"Abc"</span>;</span><br><span class="line">    str = [str lowercaseString];</span><br><span class="line">    str = [str stringByAppendingString:<span class="string">@"xyz"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏。</p><p><strong>解决方案</strong>：</p><p>在循环中创建自己的 <code>autoreleasepool</code>，及时释放占用内存大的临时变量，减少内存占用峰值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSString *str &#x3D; @&quot;Abc&quot;;</span><br><span class="line">        str &#x3D; [str lowercaseString];</span><br><span class="line">        str &#x3D; [str stringByAppendingString:@&quot;xyz&quot;];</span><br><span class="line">        NSLog(@&quot;%@&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有手加自动释放池的情况下，<code>autorelease</code> 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都会先销毁并重新创建自动释放池。</p><p>下面举个特殊的例子，使用<strong>容器 block 版本的枚举器</strong>时，内部会自动添加一个自动释放池，比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="comment">// 这里被一个局部 @autoreleasepool 包围着</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="野指针与僵尸对象"><span id="wild-pointer-and-zoombies">野指针与僵尸对象</span><a href="#野指针与僵尸对象" title="野指针与僵尸对象"></a></h2><p>指针指向的对象已经被释放/回收，这个指针就叫做<strong>野指针</strong>。这个被释放的对象就是<strong>僵尸对象</strong>。</p><p>如果用野指针去访问僵尸对象，或者说向野指针发送消息，会发生 <code>EXC_BAD_ACCESS</code> 崩溃，出现<strong>内存泄漏</strong>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MRC 下</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *stu = [[Student alloc] init];</span><br><span class="line">        [stu setAge:<span class="number">18</span>];</span><br><span class="line">        [stu release];      <span class="comment">// stu 在 release 之后，内存空间被释放并回收，stu 变成野指针</span></span><br><span class="line">        <span class="comment">// [stu setAge:20]; // set 再调用 setAge 就会崩溃</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：当对象释放后，应该将其置为 <code>nil</code>。</p><h2 id="内存泄漏检查工具">内存泄漏检查工具<a href="#内存泄漏检查工具" title="内存泄漏检查工具"></a></h2><h3 id="instruments">Instruments<a href="#instruments" title="Instruments"></a></h3><p>Instruments 是 Xcode 自带的工具集合，为开发者提供强大的程序性能分析和测试能力。</p><p>它打开方式为：<code>Xcode → Open Developer Tool → Instruments</code>。其中的 Allocations 和 Leaks 功能可以协助我们进行内存泄漏检查。</p><ul><li><p>Leaks：<strong>动态</strong>检查泄漏的内存，如果检查过程时出现了红色叉叉，就说明存在内存泄漏，可以定位到泄漏的位置，去解决问题。此外，Xcode 中还提供<strong>静态</strong>监测方法 Analyze，可以直接通过 <code>Product → Analyze</code> 打开，如果出现泄漏，会出现“蓝色分支图标”提示。</p></li><li><p>Allocations：用来检查内存使用/分配情况。比如出现“<a href="#peak-mem-usage">循环加载引起内存峰值</a>”的情况，就可以通过这个工具检查出来。</p></li><li><p>Zombies：检查是否访问了<a href="#wild-pointer-and-zoombies">僵尸对象</a>。</p></li></ul><p>Instruments 的使用相对来说比较复杂，你也可以通过在工程中引入一些第三方框架进行检测。</p><h3 id="mleaksfinder">MLeaksFinder<a href="#mleaksfinder" title="MLeaksFinder"></a></h3><p><a href="https://github.com/Tencent/MLeaksFinder" target="_blank">MLeaksFinder</a> 是 WeRead 团队开源的 iOS 内存泄漏检测工具。</p><p>它的使用非常简单，只要在工程引入框架，就可以在 App 运行过程中监测到内存泄漏的对象并立即提醒。MLeaksFinder 也不具备侵入性，使用时无需在 release 版本移除，因为它只会在 debug 版本生效。</p><p>不过 MLeaksFinder 的只能定位到内存泄漏的对象，如果你想要检查该对象是否存在循环引用。就结合 FBRetainCycleDetector 一起使用。</p><h3 id="fbretaincycledetector">FBRetainCycleDetector<a href="#fbretaincycledetector" title="FBRetainCycleDetector"></a></h3><p><a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank">FBRetainCycleDetector</a> 是 Facebook 开源的一个<strong>循环引用</strong>检测工具。它会递归遍历传入内存的 OC 对象的所有强引用的对象，检测以该对象为根结点的强引用树有没有出现循环引用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;指的是程序中已动态分配的&lt;strong&gt;堆内存&lt;/strong&gt;（程序员自己管理的空间）由于某些原因未能释放或无法释放，造成系统内存的浪费，导致程序运行速度变慢甚至系统崩溃。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://blog.fiteen.top/categories/iOS/"/>
    
    
      <category term="内存泄漏" scheme="https://blog.fiteen.top/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS 应用签名原理</title>
    <link href="https://blog.fiteen.top/2020/ios-app-signature/"/>
    <id>https://blog.fiteen.top/2020/ios-app-signature/</id>
    <published>2020-02-13T23:06:11.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>不少果粉对 Apple 钟情，与它的纯净、安全有很大关系，我们发现在苹果的设备上下载应用时，不会出现触发下载一系列垃圾软件的情况，而且用户可以明确 App 的来源——通过官方商店 AppStore 购买、企业证书安装还是 TestFlight 下载。为了防止盗版软禁、病毒入侵、静默安装以及屏蔽其它不可控因素，并确保每一个安装到 iOS 设备上的应用都是被官方允许的，苹果设定了一套<strong>应用签名机制</strong>。</p><a id="more"></a><h2 id="数字签名">数字签名<a href="#数字签名" title="数字签名"></a></h2><p><strong>数字签名</strong>，又称公钥数字签名，是只有信息的发送者才能产生的别人无法伪造的一段数字串，发送者对要发送的数据打上签名标记，表示这份经过认证，未被篡改的。</p><h3 id="数据传输">数据传输<a href="#数据传输" title="数据传输"></a></h3><p>下面模拟一下<strong>数据传输</strong>的过程：</p><ol><li><p>假如发送方直接将原始数据明文传输给接收方时，数据非常不安全，极易被篡改；</p></li><li><p>为了提升安全性并同时简化明文，可以对数据进行<strong>哈希算法</strong>处理，得到原始数据的<strong>摘要</strong>，然后将摘要发送给接收方。但假如哈希算法被泄漏，依然存在数据被篡改的风险；</p></li><li><p>引入<strong>非对称加密算法</strong>，对一份数据，用<strong>哈希算法</strong>计算出摘要后，再用 RSA 的<strong>私钥</strong>加密摘要，得到原始数据的数字签名，<strong>发送方将数字签名与原始数据一起发送给接收方</strong>。</p></li></ol><p>我们将<strong>原始数据进行哈希加密、非对称加密后的数据</strong>称为<strong>数字签名</strong>。</p><p>接收方拿到数据后，需要进行签名验证，来确保数据传输过程中，未被篡改。</p><h3 id="数字签名验证">数字签名验证<a href="#数字签名验证" title="数字签名验证"></a></h3><p><strong>签名验证</strong>的具体步骤如下：</p><ol><li><p>接收方拿到数据后，通过同样的<strong>哈希加密处理原始数据</strong>，得到哈希值（摘要）；</p></li><li><p>再利用<strong>非对称将数字签名中的校验哈希值（摘要）解密</strong>出来；</p></li><li><p>最后对比两个哈希值是否一致，判断出数据是否被篡改。</p></li></ol><p>用一张图还原数字签名的完整过程：</p><p><img src="/2020/ios-app-signature/digitally-signed-process.png" class="φcy"></p><p>再来看看如何利用数字签名保证每个安装到 iOS 上的 App 都被苹果认证允许。</p><h2 id="代码签名">代码签名<a href="#代码签名" title="代码签名"></a></h2><p><strong>代码签名</strong>就是对可执行文件或脚本进行数字签名，用来确认软件在签名后未被修改或损坏的措施。它的原理和数字签名类似，只不过把签名的不是数据，而是代码。</p><h3 id="简单的代码签名">简单的代码签名<a href="#简单的代码签名" title="简单的代码签名"></a></h3><p>假如 App 是只能从 App Store 上下载，那么它的验证方式就比较简单了。</p><p>由苹果官方生成一对公私钥，在 iOS 系统中内置一个公钥，私钥由苹果后台保存。</p><p>我们把 App 上传到 App Store 时，<strong>苹果后台用私钥对 App 数据进行签名</strong>，iOS 系统下载这个 App 后，<strong>用公钥验证这个签名</strong>，如果签名正确则这个 App 肯定是由苹果后台认证的，并且没有被修改或损坏。</p><p><img src="/2020/ios-app-signature/app-store-download-signed.png" class="φcy"></p><p>但 iOS 设备安装 App 并不只有 App Store 这一个渠道，比如开发者的真机调试、TestFlight 内测、In-House 企业证书分发等，此时简单的代码签名就无法满足对 App 的完全验证了。</p><p>iOS 代码签名的复杂度需要相应增加，于是双层代码签名（双重签名）产生了。</p><h3 id="双层代码签名">双层代码签名<a href="#双层代码签名" title="双层代码签名"></a></h3><p>“双层”意在用<strong>两对</strong>公私钥做加密验证，它们分别是 Mac 本地的一对和 Apple 服务提供的一对。</p><p>双层代码签名的存在是为了满足：</p><ul><li>App 需要经过苹果允许才能安装；</li><li>在 Apple 后台中注册过的设备才能安装，比如在 TestFlight 内测、真机调试模式下；</li><li>限制签名只能对应唯一的 App。</li></ul><p>为了猜测完整的签名流程，我们可以解压一个 ipa 文件，在 Payload 目录中有一个 <code>embedded.mobileprovision</code>，我们称之为<strong>描述文件</strong>，它对应的是 Apple 后台生成 <code>Provisioning Profile</code>（简称 PP）文件。文件中包括：</p><ul><li>证书（公钥、签名）</li><li>App ID</li><li>Entitlements（权限）</li><li>注册设备列表</li><li>其它关乎 App 能否正常启动的所有信息</li></ul><p>所以我们猜测签名的大概流程是这样的：</p><ol><li><p>在开发设备 Mac 上本地生成一对公私钥。</p></li><li><p>Apple 有一对公私钥，Apple 私钥在 Apple 后台，Apple 公钥在每台 iOS 设备上。</p></li><li><p>把 Mac 公钥上传到 Apple 后台，用 Apple 私钥签名 Mac 公钥，可以得到一份 Mac 公钥和签名的组合数据，我们把这份数据称为<strong>证书</strong>。</p></li><li><p>在 Apple 后台申请 App ID，配置好的 UDID（注册设备） 列表以及 App 申请的权限（Entitlements），再加上步骤3中的证书，组合起来的数据用 Apple 私钥进行签名，把数据和签名一起组成 PP 文件，下载到本地的开发设备 Mac 上。</p></li><li><p>当我们编译工程时，Mac 私钥会对 App 进行签名，同时把步骤4得到的 PP 文件打包进去，文件名为 <code>embedded.mobileprovision</code>，准备将 App 安装到手机上。</p></li><li><p>安装时，iOS 系统取得证书，通过系统内置的 Apple 公钥，去验证证书里的签名是否正确。</p></li><li><p>继续用 Apple 公钥验证描述文件是否正确。</p></li><li><p>用 Mac 公钥验证 App 签名是否被篡改。</p></li></ol><p><img src="/2020/ios-app-signature/app-download-signed.png" class="φcy"></p><p>上面的步骤对应到实际操作和概念是这样的：</p><p>第 1 步：Mac 上依次打开“钥匙串访问 → 证书助理 → 从证书颁发机构请求证书…”，做了这一步，就会在本地生成了一对公私钥，导出的 CSR 文件（<code>CertificateSigningRequest.certSigningRequest</code>）就是 Mac 公钥，Mac 私钥也是存储在本地，具体是什么文件看第 3 步。</p><p>第 2 步：每台 iOS 设备中都已经有了 Apple 公钥，至于 Apple 私钥是什么，看第 3 步。</p><p>第 3 步：在 Apple 后台的 iOS Certificates 模块，通过上传本地导出的 CSR 文件，生成 <code>.cer</code> 证书文件，也就是 Apple 私钥。将 <code>.cer</code> 证书下载到本地，安装证书，在钥匙串中找到证书，就可以导出 Mac 私钥，也就是一个 <code>.p12</code> 文件。它和第 1 步中导出的 Mac 公钥是对应的，钥匙串会把这两个证书关联起来。用<code>.cer</code> 证书去签名 CSR 文件，拿到含有签名的证书。</p><p>第 4 步：在 Apple 后台配置 App ID、Entitlements、Devices 等，然后下载 PP 文件。</p><p>第 5 步：编译 App 时，XCode 会通过第 3 步下载回来的证书（存着 Mac 公钥），在本地找到对应的 Mac 私钥，然后用 Mac 私钥去签名 App，同时打包，安装包中包含 PP 文件，在 ipa 中的文件名是 <code>embedded.mobileprovision</code>。这里 App 的签名数据被分为两部分，Mach-O 可执行文件会把签名直接写入描述文件里，而资源文件则会保存在 <code>_CodeSignature</code> 目录下，这时准备安装 App。</p><p>第 6 步：使用 Apple 公钥验证描述文件签名，对应第 4 步，签名通过，说明证书可用，进入下一步。</p><p>第 7 步：使用 Apple 公钥验证证书签名，对应第 3 步，签名通过，说明 Mac 公钥合法，进入下一步。</p><p>第 8 步：使用 Mac 公钥验证 App 签名，对应第 4 步，上述验证均通过后，还需要将描述文件中的内容与 App 本身的信息做验证对比，比如验证设备 ID 是否在 UDID 列表上，App ID 是否相同，权限开关是否与 Entitlements 一致，都验证通过，就可以开始安装 App。</p><p>前面说了，双层代码签名是针对开发测试包、In-House 企业签名、Ad-Hoc 包为例的签名和验证的流程，只是企业签名不限制安装的设备数，因此描述文件中不会有设备列表，而是一条 <code>&lt;key&gt;ProvisionsAllDevices&lt;/key&gt;&lt;true/&gt;</code> 记录。</p><p>而从 App Store 上下载的安装包，里面是没有描述文件的，但上架之前还是要配置证书、PP 文件，因为 App ID 和权限的检验还是需要做的。但 App 上传到 AppStore 以后就跟 PP 文件没有关系了，所以我们可以理解为 App Store 上包的签名验证采用就是前面说的最简单的签名方式，Apple 后台直接用私钥签名 App 就可以了。</p><hr><p>参考链接：bang - <a href="http://blog.cnbang.net/tech/3386/" target="_blank">iOS App 签名原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不少果粉对 Apple 钟情，与它的纯净、安全有很大关系，我们发现在苹果的设备上下载应用时，不会出现触发下载一系列垃圾软件的情况，而且用户可以明确 App 的来源——通过官方商店 AppStore 购买、企业证书安装还是 TestFlight 下载。为了防止盗版软禁、病毒入侵、静默安装以及屏蔽其它不可控因素，并确保每一个安装到 iOS 设备上的应用都是被官方允许的，苹果设定了一套&lt;strong&gt;应用签名机制&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://blog.fiteen.top/categories/iOS/"/>
    
    
      <category term="应用签名" scheme="https://blog.fiteen.top/tags/%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime 机制解读（结合 objc4 源码）</title>
    <link href="https://blog.fiteen.top/2020/ios-runtime/"/>
    <id>https://blog.fiteen.top/2020/ios-runtime/</id>
    <published>2020-02-10T15:11:08.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Runtime 是指将数据类型的确定由<strong>编译时</strong>推迟到了<strong>运行时</strong>。它是一套底层的纯 C 语言 API，我们平时编写的 Objective-C 代码，最终都会转换成 runtime 的 C 语言代码。</p><a id="more"></a><p>不过，runtime API 的实现是用 C++ 开发的（源码中的实现文件都是 <code>.mm</code> 文件）。</p><p>为了更全面地理解 runtime 机制，我们结合最新的<a href="https://opensource.apple.com/source/objc4/" target="_blank">objc4 源码</a>来进行解读。</p><h2 id="消息传递">消息传递<a href="#消息传递" title="消息传递"></a></h2><p>我们知道 Objective-C 是面向对象开发的，而 C 语言则是面向过程开发，这就需要<strong>将面向对象的类转变成面向过程的结构体</strong>。</p><p>在 Objective-C 中，所有的消息传递中的“消息”都会被编译器转化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend ( id self, SEL op, ... );</span><br></pre></td></tr></table></figure><p>比如执行一个对象的方法：<code>[obj foo];</code>，底层运行时会被编译器转化为：<code>objc_msgSend(obj, @selector(foo));</code>。</p><p>那么方法内部的执行流程究竟是怎么样的呢？我先来了解一些概念。</p><h3 id="概念">概念<a href="#概念" title="概念"></a></h3><h4 id="objc_object">objc_object<a href="#objc_object" title="objc_object"></a></h4><p>Objective-C 对象是由 <code>id</code> 类型表示的，它本质上是一个指向 <code>objc_object</code> 结构体的指针。</p><figure class="highlight c"><figcaption><span>objc-private.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"><span class="comment">// public &amp; private method...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 <code>objc_object</code> 的结构体中只有一个对象，就是指向其类的 <code>isa</code> 指针。</p><p>当向一个对象发送消息时，runtime 会根据实例对象的 <code>isa</code> 指针找到其所属的类。</p><h4 id="objc_class">objc_class<a href="#objc_class" title="objc_class"></a></h4><p>Objective-C 的类是由 <code>Class</code> 类型来表示的，它实际上是一个指向 <code>objc_class</code> 结构体的指针。</p><figure class="highlight c"><figcaption><span>objc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><p><code>objc_class</code> 结构体中定义了很多变量：</p><figure class="highlight c"><figcaption><span>objc-runtime-new.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 指向类的指针(位于 objc_object)</span></span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    <span class="comment">// 指向父类的指针</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="comment">// 用于缓存指针和 vtable，加速方法的调用</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="comment">// 存储类的方法、属性、遵循的协议等信息的地方</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    <span class="comment">// class_data_bits_t 结构体的方法，用于返回class_rw_t 指针（）</span></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other methods...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line">    </span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_class</code> 继承自 <code>objc_object</code>，因此它也拥有了 <code>isa</code> 指针。除此之外，它的结构体中还保存了指向父类的指针、缓存、实例变量列表、方法列表、遵守的协议等。</p><h4 id="元类">元类<a href="#元类" title="元类"></a></h4><p>元类（metaclass）是类对象的类，它的结构体和 <code>objc_class</code> 是一样的。</p><p>由于所有的类自身也是一个对象，我们可以向这个对象发送消息，比如调用类方法。那么为了调用类方法，这个类的 <code>isa</code> 指针必须指向一个包含类方法的一个 <code>objc_class</code> 结构体。而类对象中只存储了实例方法，却没有类方法，这就引出了元类的概念，元类中保存了创建类对象以及类方法所需的所有信息。</p><p><img src="/2020/ios-runtime/instance-class-meta-isa-chain.png" class="φcy"></p><p>为了更方便理解，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)eat;    &#x2F;&#x2F; 一个实例方法</span><br><span class="line">+ (void)sleep;  &#x2F;&#x2F; 一个类方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 那么实例方法需要由类对象来调用：</span><br><span class="line">[person eat];</span><br><span class="line">&#x2F;&#x2F; 而类方法需要由元类来调用：</span><br><span class="line">[Person sleep];</span><br></pre></td></tr></table></figure><p>假如 <code>person</code> 对象也能调用 <code>sleep</code> 方法，那我们就无法区分它调用的就究竟是 <code>+ (void)sleep;</code> 还是 <code>- (void)sleep;</code>。</p><p><strong>类对象是元类的实例，类对象的 <code>isa</code> 指针指向了元类。</strong></p><p>这个说法可能有点绕，借助这张经典的图来理解：</p><p><img src="/2020/ios-runtime/instance-class-meta-chain.png" class="φcy"></p><p>当向对象发消息，runtime 会在这个对象所属类方法列表中查找发送消息对应的方法，但当向类发送消息时，runtime 就会在这个类的 meta class 方法列表里查找。所有的 meta class，包括 Root class，Superclass，Subclass 的 isa 都指向 Root class 的 meta class，这样能够形成一个闭环。</p><h4 id="methodmethod_t">Method(method_t)<a href="#methodmethod_t" title="Method(method_t)"></a></h4><p>Method 是一个指向 <code>method_t</code> 结构体的指针，我们找到关于它的定义：</p><figure class="highlight c"><figcaption><span>objc-private.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>objc-runtime-new.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 方法选择器</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="comment">// 类型编码</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    <span class="comment">// 方法实现的指针</span></span><br><span class="line">    MethodListIMP imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 Method 和 SEL、IMP 的关系就是 Method = SEL + IMP + types。</p><p>关于 types 的写法，参考 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank">Type Encodings</a>。</p><h4 id="selobjc_selector">SEL(objc_selector)<a href="#selobjc_selector" title="SEL(objc_selector)"></a></h4><p>SEL 又称<strong>方法选择器</strong>，是一个指向 <code>objc_selector</code> 结构体的指针，也是 <code>objc_msgSend</code> 函数的第二个参数类型。</p><figure class="highlight c"><figcaption><span>objc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure><p>方法的 <code>selector</code> 用于表示运行时方法的名称。代码编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（ Int 类型的地址），即 SEL。</p><p><strong>一个类的方法列表中不能存在两个相同的 SEL</strong>，这也是 <strong>Objective-C 不支持重载</strong>的原因。</p><p><strong>不同类之间可以存在相同的 SEL</strong>，因为不同类的实例对象执行相同的 <code>selector</code> 时，会在各自的方法列表中去寻找自己对应的 IMP。</p><p><strong>获取 SEL</strong> 的方式有三种：</p><ul><li><code>sel_registerName</code> 函数</li><li>Objective-C 编译器提供的 <code>@selector()</code> 方法</li><li><code>NSSeletorFromString()</code> 方法</li></ul><h4 id="imp">IMP<a href="#imp" title="IMP"></a></h4><p>IMP 本质上就是一个函数指针，<strong>指向方法实现的地址</strong>。</p><figure class="highlight c"><figcaption><span>objc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>id：指向 self 的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针）</li><li>SEL：方法选择器</li><li>…：方法的参数列表</li></ul><p>SEL 与 IMP 的关系类似于哈希表中 key 与 value 的关系。采用这种哈希映射的方式可以加快方法的查找速度。</p><h4 id="cache_t">cache_t<a href="#cache_t" title="cache_t"></a></h4><p><code>cache_t</code> 表示类缓存，是 object_class 的结构体变量之一。</p><figure class="highlight c"><figcaption><span>objc-runtime-new.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 存放方法的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="comment">// 能存储的最多数量</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="comment">// 当前已存储的方法数量</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了加速消息分发，系统会对方法和对应的地址进行缓存，就放在 <code>cache_t</code> 中。</p><p>实际运行中，大部分常用的方法都是会被缓存起来的，runtime 系统实际上非常快，接近直接执行内存地址的程序速度。</p><h4 id="category_t">category_t<a href="#category_t" title="category_t"></a></h4><p><code>category_t</code> 表示一个指向分类的结构体的指针。</p><figure class="highlight c"><figcaption><span>objc-runtime-new.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 是指类名，而不是分类名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 要扩展的类对象，编译期间是不会定义的，而是在运行时阶段通过name对应到相应的类对象</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="comment">// 类（元类）属性列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里涉及到一个经典问题：</p><p><strong>分类中可以添加实例变量/成员变量/属性吗？</strong></p><p>首先，<strong>分类中无法直接添加实例变量和成员变量</strong>。</p><p>实践一下，我们就会发现，在分类中添加实例变量/成员变量，在编译阶段，就会报错，但添加属性是允许的。</p><p><img src="/2020/ios-runtime/category-add-instance-variable-error.png" class="φcy"></p><p>这是因为<strong>在分类的结构体当中，没有“实例变量/成员变量”的结构，但是有“属性”的结构</strong>。</p><p>那么分类中就可以直接添加属性吗？</p><p>其实也不然，虽然分类的 <code>.h</code> 中没有报错信息，<code>.m</code> 中却报出了如下的警告，且运行时会报错。</p><p><img src="/2020/ios-runtime/category-add-property-warn.png" class="φcy"></p><p>警告提示上表明有两种解决方法：</p><p>第一种：用 <code>@dynamic修饰</code>。但实际上，<code>@dynamic</code> 修饰只是告诉编译器，属性的 setter 和 getter 方法会由用户自行实现。但这样做只能消除警告，无法解决问题，运行时依然会崩溃。</p><p>第二种：给分类手动添加 setter 和 getter 方法，这是一种有效的方案。</p><p>我们知道 <code>@property = ivar + setter + getter</code>。</p><p>可以通过 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> <strong>向分类中动态添加属性</strong>，具体实现见下文中的<a href="#add-prop-to-category-with-associated-objects">“关联对象给分类增加属性”</a>。</p><h3 id="流程">流程<a href="#流程" title="流程"></a></h3><p>消息传递的完整过程为：</p><p><img src="/2020/ios-runtime/message-send.png" class="φcy" alt="消息传递流程"></p><p>也就是查找 IMP 的过程：</p><ul><li>先从当前 class 的 cache 方法列表里去查找。</li><li>如果找到了，如果找到了就返回对应的 IMP 实现，并把当前的 class 中的 selector 缓存到 cache 里面。</li><li>如果类的方法列表中找不到，就到父类的方法列表中查找，一直找到 NSObject 类为止。</li><li>最后再找不到，就会进入动态方法解析和消息转发的机制。</li></ul><h2 id="消息转发">消息转发<a href="#消息转发" title="消息转发"></a></h2><p>如果消息传递后仍无法找到 IMP，就进入了<strong>消息转发</strong>流程。</p><ol><li>通过运行期的<strong>动态方法解析</strong>功能，我们可以在需要用到某个方法时再将其加入类中。</li><li>对象可以把其无法解读的某些选择子转交给<strong>备用接受者</strong>来处理。</li><li>经过上述两步之后，如果还是没有办法处理选择子，那就启动<strong>完整的消息转发</strong>机制。</li></ol><h3 id="动态方法解析">动态方法解析<a href="#动态方法解析" title="动态方法解析"></a></h3><p>动态方法解析的两个方法：</p><figure class="highlight objc"><figcaption><span>NSObject.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加类方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="comment">// 添加实例方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p>我们再看看这两个方法在源码中的调用：</p><figure class="highlight c"><figcaption><span>objc-class.mm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断是不是元类</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        <span class="comment">// 调用类的 resolveInstanceMethod 方法，动态添加实例方法</span></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        <span class="comment">// 调用元类的 resolveClassMethod 方法，动态添加类方法</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一个动态方法解析的例子。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(foo)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(foo)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)fooMethod, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> fooMethod(<span class="keyword">id</span> obj, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Doing foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到虽然没有实现 <code>foo</code> 这个函数，但是我们通过 <code>class_addMethod</code> 动态添加 <code>fooMethod</code> 函数，并执行 <code>fooMethod</code> 这个函数的IMP。</p><p>如果 <code>resolveInstanceMethod:</code> 方法返回 NO ，运行时就会移到下一步：<code>forwardingTargetForSelector:</code>。</p><h3 id="备用接收者">备用接收者<a href="#备用接收者" title="备用接收者"></a></h3><p>如果目标对象实现了 <code>forwardingTargetForSelector:</code> 方法，runtime 就会调用这个方法，给你把这个消息转发给其他接受者的机会。</p><p>实现一个备用接收者的例子如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Doing foo"</span>);<span class="comment">//Person的foo函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(foo)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="comment">// 返回 NO，进入下一步转发。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(foo)) &#123;</span><br><span class="line">        <span class="comment">//返回 Person对象，让 Person 对象接收这个消息</span></span><br><span class="line">        <span class="keyword">return</span> [Person new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面的实现就是利用 <code>forwardingTargetForSelector</code> 把当前 <code>ViewController</code> 类的方法 <code>foo</code> 转发给了备用接受者 <code>Person</code> 类去执行了。</p><h3 id="完整的消息转发">完整的消息转发<a href="#完整的消息转发" title="完整的消息转发"></a></h3><p>如果在上一步还无法处理未知消息，唯一能做的就是启用<strong>完整的消息转发</strong>机制。</p><p>主要涉及到两个方法：</p><ul><li>发送 <code>methodSignatureForSelector</code>进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil，runtime 会发出 <code>doesNotRecognizeSelector</code> 消息，程序同时崩溃。</li><li>如果返回了一个函数签名，runtime 就会创建一个 <code>NSInvocation</code> 对象并发送 <code>forwardInvocation</code> 消息给目标对象。</li></ul><p>实现一个完整转发的例子如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Doing foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(foo)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="comment">// 返回 NO，进入下一步转发。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="comment">// 返回 nil，进入下一步转发。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"foo"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];<span class="comment">// 签名，进入 forwardInvocation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    <span class="keyword">if</span>([p respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:p];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过签名，runtime 生成了一个对象 <code>anInvocation</code>，发送给方法 <code>forwardInvocation</code>，我们在方法中让 <code>Person</code> 对象执行 <code>foo</code> 函数。</p><p><img src="/2020/ios-runtime/message-forwarding.png" class="φcy" alt="消息转发流程"></p><p>以上就是 runtime 的三次转发流程，下面列举一下 runtime 的实际应用。</p><h2 id="应用">应用<a href="#应用" title="应用"></a></h2><h3 id="关联对象给分类增加属性"><span id="add-prop-to-category-with-associated-objects">关联对象给分类增加属性</span><a href="#关联对象给分类增加属性" title="关联对象给分类增加属性"></a></h3><p>关联对象(Associated Objects) 是 Objective-C 运行时的特性，允许开发者向已经存在的类在扩展中添加自定义属性。</p><p>关联对象 runtime 提供了3个 API 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取关联的对象</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key);</span><br><span class="line">&#x2F;&#x2F; 设置关联对象</span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line">&#x2F;&#x2F; 移除关联的对象</span><br><span class="line">void objc_removeAssociatedObjects(id object);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>：被关联的对象</li><li><code>key</code>：关联对象的唯一标识</li><li><code>value</code>： 关联的对象</li><li><code>policy</code>：内存管理的策略</li></ul><p>关于<strong>内存管理的策略</strong>，源码中这样描述：</p><figure class="highlight c"><figcaption><span>runtime.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Associative References */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Policies related to associative references.</span></span><br><span class="line"><span class="comment"> * These are options to objc_setAssociatedObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">OBJC_ENUM</span><span class="params">(<span class="keyword">uintptr_t</span>, objc_AssociationPolicy)</span> </span>&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们看看内存策略对应的属性修饰。</p><div class="φcz"><div class="φdb"><table><thead><tr><th>内存策略</th><th>属性修饰</th><th>描述</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>@property (assign) 或 @property (unsafe_unretained)</td><td>指定一个关联对象的弱引用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>@property (nonatomic, strong)</td><td>指定一个关联对象的强引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>@property (nonatomic, copy)</td><td>指定一个关联对象的 copy 引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>@property (atomic, strong)</td><td>指定一个关联对象的强引用，能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>@property (atomic, copy)</td><td>指定一个关联对象的 copy 引用，能被原子化使用。</td></tr></tbody></table></div></div><p>下面利用关联对象实现一个“在分类中增加一个用 <code>copy</code> 修饰的非原子性属性 <code>prop</code>的功能。</p><p>上文中，我们已经知道分类中不能直接添加属性，需要手动添加存取方法：</p><figure class="highlight objc"><figcaption><span>NSObject+AssociatedObject.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *prop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><figcaption><span>NSObject+AssociatedObject.m</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSObject+AssociatedObject.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key 有三种常见写法：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1. static void *propKey = &amp;propKey;</span></span><br><span class="line"><span class="comment">// 2. static NSString *propKey = @"propKey";</span></span><br><span class="line"><span class="comment">// 3. static char propKey;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *propKey = <span class="string">@"propKey"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setProp:(<span class="built_in">NSString</span> *)prop &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;propKey, prop, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)prop &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;propKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="黑魔法添加和替换方法">黑魔法添加和替换方法<a href="#黑魔法添加和替换方法" title="黑魔法添加和替换方法"></a></h3><p>黑魔法是方法交换（method swizzling），也就是交换方法的 IMP 实现。</p><p>一般是在 <code>+ (void)load;</code> 中执行方法交换。因为它的加载时机较早，基本能确保方法已交换。</p><h4 id="方法添加">方法添加<a href="#方法添加" title="方法添加"></a></h4><p>在动态方法解析中已经提到了“方法添加”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;class_addMethod(Class  _Nullable __unsafe_unretained cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)</span><br><span class="line">class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>：被添加方法的类</li><li><code>name</code>：添加的方法的名称的 SEL</li><li><code>imp</code>：方法的实现。该函数必须至少要有两个参数，self,_cmd</li><li><code>types</code>：类型编码</li></ul><h4 id="方法替换">方法替换<a href="#方法替换" title="方法替换"></a></h4><p>方法替换就是改变类的选择子映射表。</p><p><img src="/2020/ios-runtime/method-swizzling.png" class="φcy"></p><p>如果要互换两个已经写好的方法实现，可以用下面的函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2);</span><br></pre></td></tr></table></figure><p>方法实现可以通过下面的函数获得：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> class_getInstanceMethod(Class aClass, SEL aSelector);</span><br></pre></td></tr></table></figure><p>下面实现一个替换 <code>ViewController</code> 中 <code>viewDidLoad</code> 方法的例子。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewDidLoad);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(msviewDidLoad);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>,originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>,swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断 original 的方法是否已经实现，如果未实现，将 swizzledMethod 的实现和类型添加进 originalSelector 中</span></span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            <span class="comment">// 将 originalMethod 的实现和类型替换到 swizzledSelector 中</span></span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 交换 originalMethod 和 swizzledMethod</span></span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)msviewDidLoad &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"msviewDidLoad"</span>);</span><br><span class="line">    [<span class="keyword">self</span> msviewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewDidLoad"</span>);</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="kvo-实现">KVO 实现<a href="#kvo-实现" title="KVO 实现"></a></h3><p>KVO 全称是 Key-value observing，也就是键值观察者模式，它提供了一种当其它对象属性被修改的时候能通知到当前对象的机制。</p><p>KVO 的实现也是依赖于 runtime 中的 <code>isa-swizzling</code>。</p><p>当观察某对象 A 时，KVO 机制动态创建一个新的名为：<code>NSKVONotifying_A</code> 的新类，该类继承自对象 A 的本类，且 KVO 为 <code>NSKVONotifying_A</code> 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。</p><p>举个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"A.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    A *a = [A new];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Before KVO: [a class] = %@, a -&gt; isa = %@"</span>, [a <span class="keyword">class</span>], object_getClass(a));</span><br><span class="line">    [a addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After KVO: [a class] = %@, a -&gt; isa = %@"</span>, [a <span class="keyword">class</span>], object_getClass(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>程序运行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before KVO: [a class] &#x3D; A, a -&gt; isa &#x3D; A</span><br><span class="line">After KVO: [a class] &#x3D; A, a -&gt; isa &#x3D; NSKVONotifying_A</span><br></pre></td></tr></table></figure><p>可以看到当对 a 进行观察后，虽然对象 <code>a</code> 的 <code>class</code> 还是 <code>A</code>，isa 实际指向了它的子类 <code>NSKVONotifying_A</code>，来实现当前类属性值改变的监听；</p><p>所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为 <code>NSKVONotifying_A</code> 的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 <code>NSKVONotifying_A</code> 的中间类，并指向这个中间类了。</p><p>那么子类 <code>NSKVONotifying_A</code> 的 setter 方法里具体实现了什么？</p><p>KVO 的键值观察通知依赖于 NSObject 的两个方法：</p><ul><li><p><code>-willChangeValueForKey:</code>：被观察属性发生改变之<strong>前</strong>，改方法被调用，通知系统该 keyPath 的属性值<strong>即将变更</strong>；</p></li><li><p><code>-didChangeValueForKey:</code>：被观察属性发生改变之<strong>后</strong>，改方法被调用，通知系统该 keyPath 的属性值<strong>已经变更</strong>。方法 <code>observeValueForKey:ofObject:change:context:</code>也会被调用。且重写观察属性的 setter 方法这种继承方式的注入是在运行时而不是编译时实现的。</p></li></ul><p>因此，KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line"><span class="comment">// KVO 在调用存取方法之前总调用 </span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="comment">// 调用父类的存取方法 </span></span><br><span class="line">    [<span class="keyword">super</span> setValue:newName forKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="comment">// KVO 在调用存取方法之后总调用</span></span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现字典和模型之间的转换（mjextension）">实现字典和模型之间的转换（MJExtension）<a href="#实现字典和模型之间的转换（mjextension）" title="实现字典和模型之间的转换（MJExtension）"></a></h3><p><strong>原理</strong>：</p><p>通过在 <code>NSObject</code> 的分类中添加方法 <code>-initWithDict:</code>。</p><p>具体实现为：用 runtime 提供的函数 <code>class_copyPropertyList</code> 获取属性列表，再遍历 <code>Model</code> 自身所有属性（通过 <code>property_getName</code> 函数获得属性的名字，通过 <code>property_getAttributes</code> 函数获得属性的类型）。如果属性在 <code>json</code> 中有对应的值，则将其赋值。</p><p><strong>源码</strong>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithDict:(<span class="built_in">NSDictionary</span> *)dict &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 1、获取类的属性及属性对应的类型</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> * keys = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> * attributes = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 例子</span></span><br><span class="line"><span class="comment">         * name = value3 attribute = T@"NSString",C,N,V_value3</span></span><br><span class="line"><span class="comment">         * name = value4 attribute = T^i,N,V_value4</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">        objc_property_t * properties = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            <span class="comment">// 通过 property_getName 函数获得属性的名字</span></span><br><span class="line">            <span class="built_in">NSString</span> * propertyName = [<span class="built_in">NSString</span> stringWithCString:property_getName(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            [keys addObject:propertyName];</span><br><span class="line">            <span class="comment">//通过 property_getAttributes 函数获得属性类型</span></span><br><span class="line">            <span class="built_in">NSString</span> * propertyAttribute = [<span class="built_in">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            [attributes addObject:propertyAttribute];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 立即释放properties指向的内存</span></span><br><span class="line">        free(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、根据类型给属性赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> * key <span class="keyword">in</span> keys) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([dict valueForKey:key] == <span class="literal">nil</span>) <span class="keyword">continue</span>;</span><br><span class="line">            [<span class="keyword">self</span> setValue:[dict valueForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-nscoding-的自动归档和解档">实现 NSCoding 的自动归档和解档<a href="#实现-nscoding-的自动归档和解档" title="实现 NSCoding 的自动归档和解档"></a></h3><p><strong>原理</strong>：</p><p>在 <code>Model</code> 的基类中重写方法：<code>-initWithCoder:</code> 和 <code>-encodeWithCoder:</code>。</p><p>具体实现为：用 runtime 提供的函数 <code>class_copyIvarList</code> 获取实例变量列表，再遍历 <code>Model</code> 自身所有属性，并对属性进行 <code>encode</code> 和 <code>decode</code> 操作。</p><p><strong>源码</strong>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">        Ivar * ivars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            <span class="built_in">NSString</span> * key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">            [<span class="keyword">self</span> setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">    Ivar * ivars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSString</span> * key = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [aCoder encodeObject:[<span class="keyword">self</span> valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jspatch">JSPatch<a href="#jspatch" title="JSPatch"></a></h3><p>JSPatch 是一款 iOS 动态更新框架，只需要在项目中引入引擎，就可以使用 JavaScript 调用所有 Objective-C 原生接口，从而实现热更新。</p><p>它通过<strong>完整的消息转发</strong>实现了获取参数的问题。</p><p><strong>原理</strong>：</p><p>当调用一个 NSObject 对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的 <code>-resolveInstanceMethod:</code>、<code>-forwardingTargetForSelector:</code>、<code>-methodSignatureForSelector:</code>、<code>-forwardInvocation:</code> 等方法，其中 <code>-forwardInvocation:</code> 里的 <code>NSInvocation</code> 对象会保存了这个方法调用的所有信息，包括方法名、参数和返回值类型等。所以只需要让被 JS 替换的方法最后都调用到 <code>-forwardInvocation:</code>，就可以解决无法拿到参数值的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Runtime 是指将数据类型的确定由&lt;strong&gt;编译时&lt;/strong&gt;推迟到了&lt;strong&gt;运行时&lt;/strong&gt;。它是一套底层的纯 C 语言 API，我们平时编写的 Objective-C 代码，最终都会转换成 runtime 的 C 语言代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://blog.fiteen.top/categories/iOS/"/>
    
    
      <category term="runtime" scheme="https://blog.fiteen.top/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + inside 博客个性化定制</title>
    <link href="https://blog.fiteen.top/2020/hexo-theme-inside-plugin/"/>
    <id>https://blog.fiteen.top/2020/hexo-theme-inside-plugin/</id>
    <published>2020-01-17T01:20:03.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.fiteen.top" target="_blank">我的博客</a>采用的是 <a href="https://hexo.io/themes/" target="_blank">Hexo 官方网站</a>上相中的 <a href="https://github.com/ikeq/hexo-theme-inside" target="_blank">hexo+theme+inside</a> 主题。虽然开发者已经提供了主题的<a href="https://blog.oniuo.com/theme-inside" target="_blank">使用文档</a>，但是作为一款小众的主题，一些常用功能的定制并不是那么完善，不过贴心的开发者提供了 <a href="https://blog.oniuo.com/theme-inside/docs/misc#plugins" target="_blank">plugins 配置方案</a>。</p><a id="more"></a><p>下文总结了部分功能的拓展方案，可供需要的朋友参考。</p><h2 id="plugin-前置准备">plugin 前置准备<a href="#plugin-前置准备" title="plugin 前置准备"></a></h2><p><code>themes/inside/_config.yml</code> 中的 plugins 支持于特定位置动态插入可执行的代码片段，或全局加载脚本/样式。</p><p>支持通过安装 html-minifier、babel 和 uglify-js 来实现代码压缩。 在项目根目录执行（Hexo 根目录，非 <code>themes/inside</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-preset-env html-minifier uglify-js --save</span><br></pre></td></tr></table></figure><h2 id="font-awesome">Font Awesome<a href="#font-awesome" title="Font Awesome"></a></h2><p>按照 plugin 配置描述的，要支持 Font Awesome 的 CSS，只需要这样设置：</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure><p>也就是在全局加载样式，<del>不过不知道为什么没有正常生效🤔</del>（<strong><a href="https://github.com/ikeq/hexo-theme-inside/releases/tag/2.6.1" target="_blank">inside-v2.6.1</a> 已经修复了这个问题</strong>，建议你升级到最新版本）。</p><blockquote><p>如果你是 v2.6.0 及以下版本，可以用这个方案解决：</p><p>在 <code>themes/inside/layout/index.swig</code> 的 <code>&lt;head&gt;</code> 标签内加入以下代码：</p><figure class="highlight html"><figcaption><span>index.swig</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时，虽然图标显示出来了，但是样式还是有点问题，可能和主题本身的 CSS 有关系，找到 <code>source</code> 目录下的 <code>styles.e4da61f53c7bc99becf4.css</code>（也可能叫别的） 里的 <code>.fa</code>，删除里面的 <code>margin:10rem 0 3rem;</code> 。</p><p><img src="/2020/hexo-theme-inside-plugin/alter-style-css.png" alt="修改 .fa 样式"></p></blockquote><p>不过个人觉得放在 CDN 上访问速度还是有点慢，所以从官网<a href="http://fontawesome.io" target="_blank">下载</a>最新版放在主题的 <code>source/lib</code> 目录下，全局引用：</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">lib/font-awesome/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure><p>或者在需要的位置引用 CSS 资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;lib&#x2F;font-awesome&#x2F;css&#x2F;font-awesome.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="访问量统计">访问量统计<a href="#访问量统计" title="访问量统计"></a></h2><p>很多人都有站点访问量统计的需求，像这样：</p><p><img src="/2020/hexo-theme-inside-plugin/busuanzi-example.png" class="φcy" alt="访问量统计效果"></p><p>我采用的是轻量的<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank">不蒜子统计</a>来做访问量统计。</p><p>先<strong>安装脚本</strong>，在使用不蒜子的页面，也就是 <code>sidebar</code> 模块插入 <code>busuanzi.js</code>。</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">position:</span> <span class="string">sidebar</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>再<strong>安装标签</strong>，官方给出了站点 PV/UV 的统计代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次&lt;&#x2F;span&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;本站访客数&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人次&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>你也可以用这两个 id 来显示访问数：</p><ul><li><code>busuanzi_value_site_pv</code>：异步回填访问数</li><li><code>busuanzi_container_site_pv</code>：为防止计数服务访问出错或超时（3秒）的情况下，使整个标签自动隐藏显示</li></ul><p>在 <code>_config.yml</code> 文件里找到 <code>footer</code> 下的 <code>custom</code>，写入相关的 html 代码。比如：</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Custom text.</span></span><br><span class="line"><span class="attr">custom:</span> <span class="string">&lt;span</span> <span class="string">id="busuanzi_container_site_uv"</span> <span class="string">style='display:none'&gt;Total</span> <span class="string">&lt;span</span> <span class="string">id="busuanzi_value_site_uv"&gt;&lt;/span&gt;</span> <span class="string">visitors.</span> <span class="string">&lt;/span&gt;&lt;span</span> <span class="string">id="busuanzi_container_site_pv"</span> <span class="string">style='display:none'&gt;&lt;span</span> <span class="string">id="busuanzi_value_site_pv"&gt;&lt;/span&gt;</span> <span class="string">Views&lt;/span&gt;</span></span><br></pre></td></tr></table></figure><p>或者使用 font-awesome 字体：</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Custom text.</span></span><br><span class="line"><span class="attr">custom:</span> <span class="string">&lt;span</span> <span class="string">id="busuanzi_container_site_pv"</span> <span class="string">style='display:none'&gt;&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span> <span class="string">&lt;span</span> <span class="string">id="busuanzi_value_site_pv"&gt;&lt;/span&gt;&lt;/span&gt;</span> <span class="string">｜</span> <span class="string">&lt;span</span> <span class="string">id="busuanzi_container_site_uv"</span> <span class="string">style='display:none'&gt;&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span> <span class="string">&lt;span</span> <span class="string">id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;</span></span><br></pre></td></tr></table></figure><h2 id="代码复制">代码复制<a href="#代码复制" title="代码复制"></a></h2><p>为了方便博客的读者引用代码，可以在文章中代码块的右上角加一个复制按钮，如：</p><p><img src="/2020/hexo-theme-inside-plugin/clipboard-example.png" class="φcy" alt="代码块复制按钮效果"></p><p>它的实现是在页面加载完毕后，使用 js 动态为每个代码块添加一个按钮，当鼠标滑动到代码块上时显示按钮，点击按钮时复制代码块里的内容。因此需要三个文件：</p><ul><li><strong>实现复制代码块功能</strong>的文件 <code>clipboard.js</code>，这里可以直接引用这个文件： <code>https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js</code>。</li><li>支持<strong>动态创建复制按钮</strong>的文件 <code>clipboard-use.js</code></li><li>复制按钮的<strong>样式</strong>文件 <code>clipboard.css</code></li></ul><p>页面载入完成后，创建一个复制按钮，上面用 font-awesome 的 clipboard 图标，实现如下：</p><figure class="highlight js"><figcaption><span>clipboard-use.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="keyword">var</span> initCopyCode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copyHtml = <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;&lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;/button&gt;'</span>;</span><br><span class="line">    $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">    <span class="keyword">new</span> ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">      target: <span class="function"><span class="keyword">function</span> (<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> trigger.nextElementSibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>这里要注意的是， <code>clipboard-use.js</code> 中需要用到 <code>jQuery</code>，而 inside 里没有引入，故需要手动引入。</p><p>复制按钮的样式如下：</p><figure class="highlight css"><figcaption><span>clipboard.css</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.highlight</span> &#123;</span><br><span class="line">    <span class="comment">/* 方便copy代码按钮（btn-copy）的定位 */</span></span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background</span>: none;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>: transparent;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制按钮可以按照自己的喜好设置，如果想简单一点，直接用我的样式，可以这样配置：</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="comment"># inside 主题没有引入 jQuery 框架，需要手动引入</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js</span></span><br><span class="line">  <span class="comment"># 插件生效范围：post 和 page</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">position:</span> <span class="string">[post,</span> <span class="string">page]</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">&lt;script</span> <span class="string">type="text/javascript"</span> <span class="string">src="//cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"&gt;&lt;/script&gt;</span></span><br><span class="line">      <span class="string">&lt;script</span> <span class="string">type="text/javascript"</span> <span class="string">src="//cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.0/clipboard-use.js"&gt;&lt;/script&gt;</span></span><br><span class="line">      <span class="string">&lt;link</span> <span class="string">href="//cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.1/clipboard.css"</span> <span class="string">rel="stylesheet"&gt;</span></span><br><span class="line">      <span class="string">&lt;link</span> <span class="string">href="lib/font-awesome/css/font-awesome.min.css"</span> <span class="string">rel="stylesheet"&gt;</span></span><br></pre></td></tr></table></figure><p>如果已经全局引用过 font-awesome，可以把最后一条引用删除。</p><h2 id="评论系统---valine">评论系统 - Valine<a href="#评论系统---valine" title="评论系统 - Valine"></a></h2><p>主题的内置评论，支持 <a href="https://disqus.com" target="_blank">Disqus</a> 和 <a href="https://livere.com" target="_blank">LiveRe</a>。但个人认为这两款评论系统的 UI 风格主题不是很搭配，最后还是决定采用 <a href="https://valine.js.org" target="_blank">Valine</a>——一款基于LeanCloud的快速、简洁且高效的无后端评论系统。</p><p>虽然文档中也有提供 Valine 的配置方法，但是我实践后发现样式貌似出现了一些问题，这条 <a href="https://github.com/ikeq/hexo-theme-inside/issues/153" target="_blank">issue</a> 也证实了这一点（<strong>inside-2.6.1 已修复</strong>）。所以我另找了一个 js 文件，并做了一点小改动。你可以引用我放在 CDN 上的资源 <code>https://cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.0/valine.js</code>，或者直接把 <code>valine.js</code> 文件<a href="https://github.com/fiteen/fiteen.github.io/releases" target="_blank">下载</a>到本地，放在 <code>inside/source/lib</code>路径下。然后写入以下代码：</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="comment"># inside 主题没有引入 jQuery 框架，需要手动引入</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">//cdn1.lncld.net/static/js/3.0.4/av-min.js</span></span><br><span class="line">  <span class="comment"># 引用本地 source/lib 路径下的 valine.js 文件</span></span><br><span class="line">  <span class="comment"># - lib/valine.js</span></span><br><span class="line">  <span class="comment"># 引用 CDN 上的 valine.js 文件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">//cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.0/valine.js</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">position:</span> <span class="string">comments</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">&lt;div</span> <span class="string">id="vcomment"&gt;&lt;/div&gt;</span></span><br><span class="line">      <span class="string">&lt;script&gt;</span></span><br><span class="line">        <span class="string">new</span> <span class="string">Valine(&#123;</span></span><br><span class="line">          <span class="attr">el:</span> <span class="string">'#vcomment'</span><span class="string">,</span></span><br><span class="line">          <span class="attr">lang:</span> <span class="string">'en'</span><span class="string">,</span></span><br><span class="line">          <span class="attr">admin_email:</span> <span class="string">'Your EMAIL'</span><span class="string">,</span></span><br><span class="line">          <span class="attr">appId:</span> <span class="string">'Your APP ID'</span><span class="string">,</span></span><br><span class="line">          <span class="attr">appKey:</span> <span class="string">'Your APP KEY'</span><span class="string">,</span></span><br><span class="line">          <span class="attr">placeholder:</span> <span class="string">'Write a Comment'</span><span class="string">,</span></span><br><span class="line">          <span class="string">emoticon_url:'https://cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@0.1.0/alu',</span></span><br><span class="line">          <span class="string">emoticon_list:["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],</span></span><br><span class="line">        <span class="string">&#125;)</span></span><br><span class="line">      <span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>关于上面的参数介绍：</p><ul><li><strong>lang</strong>：选填，目前支持英文版 <code>en</code> 和中文版 <code>zh-cn</code> 两种，默认是 <code>zh-cn</code>。</li><li><strong>admin_email</strong>：选填，设置作者邮箱，使用该邮箱账号评论或回复，评论者名字右侧会出现一个人形小图标标识作者。</li><li><strong>appId&amp;appKey</strong>：必填，LeanCloud 中创建应用得到的 <code>APP ID</code> 和 <code>APP KEY</code>，创建方式参照<a href="https://ioliu.cn/2017/add-valine-comments-to-your-blog/" target="_blank">此文</a>。</li><li><strong>emoticon_url</strong>：必填，这里设置一个表情包 CDN 路径，你也可以自定义喜欢的表情包。</li><li><strong>emoticon_list</strong>：必填，<code>emoticon_url</code>里包含的表情包中需要显示在评论区的表情包名称列表。</li></ul><p><img src="/2020/hexo-theme-inside-plugin/valine-comment-example.png" class="φcy" alt="评论区效果"></p><p>这就是配置成功后的评论框效果。</p><p>目前已经有 Valine 评论系统的拓展和增强版 <a href="https://github.com/DesertsP/Valine-Admin.git" target="_blank">Valine+Admin</a>，主要实现评论邮件通知、评论管理、垃圾评论过滤等功能，还支持自定义修改邮件通知模板、漏发邮件自动补发等。具体步骤这篇<a href="https://deserts.io/valine-admin-document/" target="_blank">配置手册</a>已经比较清晰了，照着上面的步骤操作即可，本文就不复制粘贴了。</p><p><strong>注意</strong>：想要在评论区显示自定义头像，先前往<a href="http://cn.gravatar.com/" target="_blank">Gravatar官网</a>注册账号，注册的邮箱需要和你评论时填写的邮箱一致。如果注册成功后，头像仍没有显示，不要着急， <code>gravatar.cat.net</code> 有七天的缓存期，请耐心等待。</p><p>下面再分享几个<strong>小功能点的配置</strong>：</p><h2 id="博客背景">博客背景<a href="#博客背景" title="博客背景"></a></h2><p>修改博客背景很简单，只需修改 <code>themes/inside/_config.yml</code> 中 <code>appearance.background</code> 配置即可。</p><p>这里分享一个网站——<a href="https://www.toptal.com/designers/subtlepatterns/" target="_blank">Subtle Patterns</a>，支持超过 500 种 PNG 高品质免费背景纹理素材，无须注册登录，可以直接下载。</p><h2 id="博客字体">博客字体<a href="#博客字体" title="博客字体"></a></h2><p>你可能会发现部署好的博客首次加载时的字体效果生效比较慢，这是因为主题中默认配置的字体样式用的是谷歌的服务：</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">appearance:</span></span><br><span class="line">  <span class="attr">font:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">//fonts.googleapis.com/css?family=Baloo+Bhaijaan|Inconsolata|Josefin+Sans|Montserrat</span></span><br></pre></td></tr></table></figure><p>如果被墙了就无法正常显示，因此我们可以换一个访问更快的地址，如：</p><figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">appearance:</span></span><br><span class="line">  <span class="attr">font:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">//cdn.jsdelivr.net/gh/fiteen/fiteen.github.io@v0.1.0/font.css</span></span><br></pre></td></tr></table></figure><h2 id="分享-qq-链接">分享 QQ 链接<a href="#分享-qq-链接" title="分享 QQ 链接"></a></h2><p>我们可以在 <code>sns.qq</code> 里配置自己想要链接的 QQ ID 信息，直接写 QQ 号当然是不可行的。需要先开通 <a href="https://shang.qq.com/v3/widget.html" target="_blank">QQ 推广</a>。</p><p><img src="/2020/hexo-theme-inside-plugin/qq-link.png" class="φcy"></p><p><code>&lt;a&gt;</code> 标签里的 <code>href</code> 就是你的 <strong>QQ 号</strong>分享链接，形如：<code>https://wpa.qq.com/msgrd?v=3&amp;uin=${YOUR-QQ-ID}&amp;site=qq&amp;menu=yes</code>。</p><p>如果你要<strong>分享群号</strong>，通过<a href="https://qun.qq.com/join.html" target="_blank">加群组件</a>，拿到形如：<code>https://shang.qq.com/wpa/qunwpa?idkey=${YOUR-GROUP-ID-KEY}</code> 的链接。</p><h2 id="配置-rss">配置 RSS<a href="#配置-rss" title="配置 RSS"></a></h2><p>比较简单，<a href="https://blog.oniuo.com/theme-inside/docs/basic#sns" target="_blank">文档</a>中有提到：</p><blockquote><p>若使用 hexo-generator-feed，sns.feed 可留空，主题会尝试取 hexo.config.feed.path。可通过改变项的先后顺序来自定义排序。</p></blockquote><p>因此直接在站点根目录（不是主题根目录）下执行命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.fiteen.top&quot; target=&quot;_blank&quot;&gt;我的博客&lt;/a&gt;采用的是 &lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot;&gt;Hexo 官方网站&lt;/a&gt;上相中的 &lt;a href=&quot;https://github.com/ikeq/hexo-theme-inside&quot; target=&quot;_blank&quot;&gt;hexo+theme+inside&lt;/a&gt; 主题。虽然开发者已经提供了主题的&lt;a href=&quot;https://blog.oniuo.com/theme-inside&quot; target=&quot;_blank&quot;&gt;使用文档&lt;/a&gt;，但是作为一款小众的主题，一些常用功能的定制并不是那么完善，不过贴心的开发者提供了 &lt;a href=&quot;https://blog.oniuo.com/theme-inside/docs/misc#plugins&quot; target=&quot;_blank&quot;&gt;plugins 配置方案&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.fiteen.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://blog.fiteen.top/tags/Hexo/"/>
    
      <category term="Valine" scheme="https://blog.fiteen.top/tags/Valine/"/>
    
  </entry>
  
  <entry>
    <title>红黑树详细图解</title>
    <link href="https://blog.fiteen.top/2020/red-black-tree/"/>
    <id>https://blog.fiteen.top/2020/red-black-tree/</id>
    <published>2020-01-08T10:55:12.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树（Red Black Tree）是一种自平衡的二叉搜索树（Self-balancing Binary Search Tree）。以前也叫做平衡二叉 B 树（Symmetric Binary B-tree）。</p><a id="more"></a><h2 id="预备知识">预备知识<a href="#预备知识" title="预备知识"></a></h2><p>树的知识框架结构如下图所示：</p><p><img src="/2020/red-black-tree/tree.png" class="φcy"></p><h3 id="平衡二叉搜索树">平衡二叉搜索树<a href="#平衡二叉搜索树" title="平衡二叉搜索树"></a></h3><p><strong>平衡二叉搜索树</strong>（Balanced Binary Search Tree），英文简称 BBST。经典常见的平衡二叉搜索树是 <a href="#avl-tree">AVL 树</a>和红黑树。</p><h4 id="二叉搜索树">二叉搜索树<a href="#二叉搜索树" title="二叉搜索树"></a></h4><p><strong>二叉搜索树</strong>（Binary Search Tree）是二叉树的一种，英文简称 BST。又称为二叉查找树、二叉排序树。</p><p>它的<strong>特点</strong>是任何一个结点的值都<strong>大于</strong>其<strong>左</strong>子树的所有结点的值，任何一个结点的值都<strong>小于</strong>其<strong>右</strong>子树的所有结点的值。</p><h4 id="平衡">平衡<a href="#平衡" title="平衡"></a></h4><p><strong>平衡</strong>（Balance）：就是当结点数量固定时，左右子树的高度越接近，这棵二叉树越平衡（高度越低）。而<strong>最理想的平衡</strong>就是完全二叉树/满二叉树，高度最小的二叉树。</p><p><img src="/2020/red-black-tree/binary-tree-compare.png" class="φcy"></p><p>一棵二叉搜索树平均时间复杂度可以认为是树的高度 O(h)。像左边这棵，结点的左右子树的高度接近，属于一棵平衡二叉搜索树，O(h) = O(logn)；而右边这棵，高度达到了最大，已经退化成了链表，O(h)=O(n)。</p><h4 id="改进二叉搜索树">改进二叉搜索树<a href="#改进二叉搜索树" title="改进二叉搜索树"></a></h4><p>当二叉树退化成链表时，性能是很低的，所以我们需要在结点的插入、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）。但是如果为了追求最理想的平衡，而增加了时间复杂度也不是很有必要，因此比较合理的方案就是：<strong>用尽量少的调整次数达到适度平衡</strong>。</p><p>由此引申出 AVL 树的概念。</p><h3 id="avl-树"><span id="avl-tree">AVL 树</span><a href="#avl-树" title="AVL 树"></a></h3><p>AVL 树是最早发明的自平衡二叉搜索树之一，它取名自两位发明家的名字：G.M.Adelson-Velsky 和 E.M.Landis。</p><h4 id="平衡因子">平衡因子<a href="#平衡因子" title="平衡因子"></a></h4><p>平衡因子（Balance Factor）：某结点的左右子树的高度差。</p><p>每个叶子结点的平衡因子都是 0。看这棵二叉搜索树，红色数字标注了每个结点对应的平衡因子。</p><p><img src="/2020/red-black-tree/binary-search-tree-balance-factor.png" class="φcy"></p><p>举例：</p><p>8 的左子树高度为 2，右子树高度为 1，因此它的平衡因子为 1；5 的左子树高度为 0，右子树高度为 3，因此它的平衡因子为 -3；4 的左子树高度为 2，右子树高度为 4，因此它的平衡因子为 -2；</p><p>再看这棵 AVL 树和它每个结点对应的平衡因子：</p><p><img src="/2020/red-black-tree/avl-tree-balance-factor.png" class="φcy"></p><p>可以看到 AVL 树具有以下<strong>特点</strong>：</p><ul><li>每个结点的平衡因子只可能是 -1、0、1（如果绝对值超过 1，则认为是<strong>失衡</strong>）</li><li>每个结点的左右子树高度差不超过 1</li><li>搜索、插入、删除的时间复杂度是 O(logn)</li></ul><h3 id="b树">B树<a href="#b树" title="B树"></a></h3><p>B 树（Balanced Tree）是一种<strong>平衡</strong>的<strong>多路</strong>搜索树，多用于文件系统、数据库的实现。这是一个简单的 3 阶 B 树：</p><p><img src="/2020/red-black-tree/b-tree.png" class="φcy"></p><h4 id="特点">特点<a href="#特点" title="特点"></a></h4><ul><li>1 个结点可以存储超过 2 个元素，可以拥有超过 2 个子结点</li><li>拥有二叉搜索树的一些性质</li><li>平衡，每个结点的所有子树高度一致</li><li>比较矮</li></ul><h4 id="m-阶-b-树的性质（m-≥-2）">m 阶 B 树的性质（m ≥ 2）<a href="#m-阶-b-树的性质（m-≥-2）" title="m 阶 B 树的性质（m ≥ 2）"></a></h4><p>m 阶 B 树指的是一个结点最多拥有 m 个子结点。假设一个结点存储的元素个数为 x，那么如果这个结点是：</p><ul><li>根结点：1 ≤ x ≤ m - 1</li><li>非根结点：┌ m / 2 ┐ - 1 ≤ x ≤ m - 1</li></ul><p>如果有子结点，子结点个数为 y = x + 1，那么如果这个结点是：</p><ul><li>根结点：2 ≤ y ≤ m</li><li>非根结点：┌ m / 2 ┐ ≤ y ≤ m</li></ul><blockquote><p>向上取整（Ceiling），指的是取比自己大的最小整数，用数学符号 ┌ ┐ 表示。<br>向下取整（Floor），指的是取比自己小的最大整数，用数学符号 └ ┘ 表示。</p></blockquote><p>比如 m = 3， 子结点个数 2 ≤ y ≤ 3，这个 B 树可以称为（2,3）树、2-3 树；</p><p>比如 m = 4， 子结点个数 2 ≤ y ≤ 4，这个 B 树可以称为（2,4）树、2-3-4 树；</p><p>比如 m = 5， 子结点个数 3 ≤ y ≤ 4，这个 B 树可以称为（3,5）树、3-4-5 树；</p><p>以此类推。</p><h4 id="b-树-vs-二叉搜索树">B 树 VS 二叉搜索树<a href="#b-树-vs-二叉搜索树" title="B 树 VS 二叉搜索树"></a></h4><p><img src="/2020/red-black-tree/binary-search-tree.png" class="φcy"></p><p>这是一棵二叉搜索树，通过某些父子结点合并，恰好能与上面的 B 树对应。我们可以得到结论：</p><ul><li>B 树和二叉搜索树，在逻辑上是等价的</li><li>多代结点合并，可以获得一个超级结点，且 n 代合并的超级结点，最多拥有 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.381ex" height="2.343ex" style="vertical-align: -0.338ex;" viewbox="0 -863.1 1025.1 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">2^n</title><defs aria-hidden="true"><path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"> <use xlink:href="#E1-MJMAIN-32" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="707" y="583"/></g></svg> 个子结点 （至少是 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.381ex" height="2.343ex" style="vertical-align: -0.338ex;" viewbox="0 -863.1 1025.1 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">2^n</title><defs aria-hidden="true"><path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"> <use xlink:href="#E1-MJMAIN-32" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="707" y="583"/></g></svg> 阶 B 树）</li></ul><h2 id="红黑树定义和性质">红黑树定义和性质<a href="#红黑树定义和性质" title="红黑树定义和性质"></a></h2><p>红黑树是一种含有<strong>红黑结点</strong>并能<strong>自平衡</strong>的二叉搜索树。</p><p>为了保证平衡，红黑树必须满足以下<strong>性质</strong>：</p><ol><li>每个结点是要么是<span style="color:red"><strong>红色</strong></span>或<strong>黑色</strong></li><li>根结点必须是<strong>黑色</strong></li><li>叶结点（外部结点、空结点）是<strong>黑色</strong></li><li><strong><span style="color:red">红色</span></strong>结点不能连续（也就是，红色结点的孩子和父亲都是<strong>黑色</strong>）</li><li>对于每个结点，从该点至 <code>nil</code>（树尾端，java 中为 <code>null</code> 的结点)的任何路径都包含所相同个数的<strong>黑色</strong>结点</li></ol><h2 id="红黑树与-b-树的等价变换">红黑树与 B 树的等价变换<a href="#红黑树与-b-树的等价变换" title="红黑树与 B 树的等价变换"></a></h2><p><img src="/2020/red-black-tree/red-black-tree.png" class="φcy"></p><p>根据上面的性质，可以画出这样一棵红黑树。接下来对红黑树做<strong>等价变换</strong>，即<strong>将所有的红色结点上升一层与它的父结点放在同一行</strong>，这就很像一棵 <strong>4 阶 B 树</strong>，转换效果如下图所示。</p><p><img src="/2020/red-black-tree/red-black-tree-2-b-tree.png" class="φcy"></p><p>可以得出结论：</p><ul><li>红黑树与 4 阶 B 树（2-3-4树）具有等价性</li><li>黑色结点与红色子结点融合在一起，形成 1 个 B 树结点</li><li>红黑树的黑色结点个数与 4 阶 B 树的结点总个数相等</li></ul><h2 id="红黑树的基本操作">红黑树的基本操作<a href="#红黑树的基本操作" title="红黑树的基本操作"></a></h2><p>当我们对一棵平衡二叉搜索树进行插入、删除的时候，很可能会让这棵树变得<strong>失衡</strong>（最坏可能导致所有祖先结点失衡，但是父结点和非祖先结点都不可能失衡），为了达到平衡，需要对树进行旋转。而红黑树能够达到自平衡，靠的也就是<strong>左旋</strong>、<strong>右旋</strong>和<strong>变色</strong>。</p><p>旋转操作是局部的。当一侧子树的结点少了，向另一侧“借”一些结点；当一侧子树的结点多了，则“租”一些结点给另一侧。</p><p>为了更清楚地讲解这部分内容，先声明几个概念：</p><p><img src="/2020/red-black-tree/red-black-tree-node-definition.png" class="φcy"></p><ul><li>N - node：当前结点</li><li>P - parent：父结点</li><li>S - sibling：兄弟结点</li><li>U - uncle：叔父结点（P 的兄弟结点）</li><li>G - grand：祖父结点（P 的父结点）</li></ul><h3 id="左旋">左旋<a href="#左旋" title="左旋"></a></h3><p><strong>左旋</strong>指的是以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。</p><p><img src="/2020/red-black-tree/left-rotation.png" class="φcy"></p><p>不考虑结点颜色，可以看到左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树移动。</p><h3 id="右旋">右旋<a href="#右旋" title="右旋"></a></h3><p><strong>右旋</strong>指的是以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</p><p><img src="/2020/red-black-tree/right-rotation.png" class="φcy"></p><p>不考虑结点颜色，可以看到右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树移动。</p><h3 id="变色">变色<a href="#变色" title="变色"></a></h3><p><strong>变色</strong>指的是结点的颜色由红变黑或由黑变红。</p><h3 id="变换规则">变换规则<a href="#变换规则" title="变换规则"></a></h3><p>将左旋、右旋和变色结合起来，得到一套<strong>变换规则</strong>：</p><p><strong><span id="change-color">变色</span></strong>：如果当前结点的父结点和叔父结点是<span style="color: red"><strong>红色</strong></span>，那么：</p><ul><li>把父结点和叔父结点变为<strong>黑色</strong></li><li>把祖父结点变为<span style="color:red"><strong>红色</strong></span></li><li>把指针定义到<strong>祖父结点</strong></li></ul><p><strong><span id="turn-left">左旋</span></strong>：当前结点是<strong>右子树</strong>，且父结点是<span style="color: red"><strong>红色</strong></span>，叔父结点是<strong>黑色</strong>，对它的<strong>父结点</strong>左旋</p><p><strong><span id="turn-right">右旋</span></strong>：当前结点是<strong>左子树</strong>，且父结点是<span style="color: red"><strong>红色</strong></span>，叔父结点是<strong>黑色</strong>，那么：</p><ul><li>把父结点变为<strong>黑色</strong></li><li>把祖父结点变为<span style="color:red"><strong>红色</strong></span></li><li>对<strong>祖父结点</strong>右旋</li></ul><h2 id="红黑树搜索"><span id="rbtree-search">红黑树搜索</span><a href="#红黑树搜索" title="红黑树搜索"></a></h2><p>由于红黑树本来就是平衡二叉搜索树，并且搜索也不会破坏树的平衡，所以搜索算法也与平衡二叉搜索树一致：</p><p><img src="/2020/red-black-tree/rbtree-search-flow-chart.png" class="φcy"></p><p>具体步骤：</p><ol><li>从<strong>根结点</strong>开始检索，把根结点设置为当前结点；</li><li>若当前结点为<strong>空</strong>，<strong>返回 nil</strong>。</li><li>若当前结点不为空，比较当前结点 key 与搜索 key 的大小；</li><li>若当前结点 key <strong>等于</strong>搜索 key，那么该 key 就是搜索目标，<strong>返回当前结点</strong>。</li><li>若当前结点 key <strong>大于</strong>搜索 key，把当前结点的<strong>左子结点</strong>设置为当前结点，重复步骤 2；</li><li>若当前结点 key <strong>小于</strong>搜索 key，把当前结点的<strong>右子结点</strong>设置为当前结点，重复步骤 2；</li></ol><h2 id="红黑树插入">红黑树插入<a href="#红黑树插入" title="红黑树插入"></a></h2><p>红黑树插入操作分为下面两步：</p><h3 id="定位插入的位置">定位插入的位置<a href="#定位插入的位置" title="定位插入的位置"></a></h3><p><img src="/2020/red-black-tree/rbtree-add-flow-chart.png" class="φcy"></p><p>具体步骤：</p><ol><li>从根结点开始检索；</li><li>若根结点为空，那么<strong>插入结点设为根结点</strong>，结束。</li><li>若根结点不为空，那么把根结点设为当前结点；</li><li>若当前结点为 nil，<strong>返回当前结点的父结点</strong>，结束。</li><li>若当前结点 key <strong>等于</strong>搜索 key，那么该 key 所在结点就是插入结点，<strong>更新结点的值</strong>，结束。</li><li>若当前结点 key <strong>大于</strong>搜索 key，把当前结点的<strong>左子结点</strong>设置为当前结点，重复步骤4；</li><li>若当前结点 key <strong>小于</strong>搜索 key，把当前结点的<strong>右子结点</strong>设置为当前结点，重复步骤4；</li></ol><h3 id="插入后实现自平衡">插入后实现自平衡<a href="#插入后实现自平衡" title="插入后实现自平衡"></a></h3><p>建议新添加的结点默认为<span style="color: red"><strong>红色</strong></span>，因此这样能够让红黑树的性质尽快满足。不过如果添加的结点是<strong>根结点</strong>，设为黑色即可。</p><p>总结一下<strong>红黑树插入</strong>可能出现的<strong>所有场景</strong>。</p><p><img src="/2020/red-black-tree/rbtree-insert-all.png" class="φcy"></p><p><strong>场景 1：红黑树为空树</strong></p><p>红黑树的性质2：根结点必须是黑色。</p><p><strong>处理</strong>：直接把插入结点设成黑色并作为根结点。</p><p><strong>场景 2：插入结点的 key 已存在</strong></p><p>二叉搜索树中不能插入相同元素，既然结点的 key 已经存在，红黑树也已平衡，无需重复插入。</p><p><strong>处理</strong>：</p><ul><li>将插入结点设为将要替换结点的颜色</li><li>更新当前结点的值为插入结点的值</li></ul><p><strong>场景 3：插入结点的父结点为黑色</strong></p><p>插入的结点默认是红色的，当它的父结点是黑色时，并不会破坏平衡。</p><p><strong>处理</strong>：直接插入。</p><p><strong>场景 4：插入结点的父结点为红色</strong></p><p>如果插入结点的父结点为红色，那么父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，后续的旋转操作需要祖父结点的参与。</p><p><strong>场景 4.1：存在叔父结点，且为红色</strong></p><p>由红黑树性质4可知：红色结点不能连续。那么此时该插入子树的红黑层数的情况是：黑-红-红。显然最简单的处理方式就是将其改为：红-黑-红。</p><p><img src="/2020/red-black-tree/rbtree-insert-4-1.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将父结点和叔父结点变为黑色</li><li>将祖父结点变为红色</li><li>将祖父结点设置为当前插入结点</li></ul><p><strong>场景 4.2：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的左子结点</strong></p><p>这种场景下，叔父结点所在的子树的黑色结点就比父结点所在子树的多，不满足红黑树的性质5。</p><p><strong>场景 4.2.1：插入结点是左子树</strong></p><p><img src="/2020/red-black-tree/rbtree-insert-4-2-1.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将父结点变为黑色</li><li>将祖父结点变为红色</li><li>将祖父结点右旋</li></ul><p><strong>场景 4.2.2：插入结点是左子树</strong></p><p>这种场景显然可以转换为 4.2.1。</p><p><img src="/2020/red-black-tree/rbtree-insert-4-2-2.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将父结点进行左旋</li><li>将父结点设为插入结点，得到场景 4.2.1</li><li>进行场景 4.2.1 的处理</li></ul><p><strong>场景4.3：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的右子结点</strong></p><p>相当于场景 4.2 的方向反转，直接看图。</p><p><strong>场景 4.3.1：插入结点是左子树</strong></p><p><img src="/2020/red-black-tree/rbtree-insert-4-3-1.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将父结点变为黑色</li><li>将祖父结点变为红色</li><li>对祖父结点进行左旋</li></ul><p><strong>场景 4.3.2：插入结点是右子树</strong></p><p><img src="/2020/red-black-tree/rbtree-insert-4-3-2.png" class="φcy"></p><p><strong>处理：</strong></p><ul><li>将父结点进行右旋</li><li>将父结点设置为插入结点，得到场景 4.3.1</li><li>进行场景 4.3.1 的处理</li></ul><p>下面举个例子，往一棵红黑树中插入元素，整棵树的变换如下图所示：</p><p><img src="/2020/red-black-tree/rbtree-insert-example.png" class="φcy"></p><h2 id="红黑树删除">红黑树删除<a href="#红黑树删除" title="红黑树删除"></a></h2><p>红黑树删除操作也分为两步：</p><h3 id="定位删除的位置">定位删除的位置<a href="#定位删除的位置" title="定位删除的位置"></a></h3><p>定位删除位置可以复用<a href="#rbtree-search">红黑树搜索</a>的操作。</p><p>如果不存在目标结点，忽略本次操作；如果找到目标结点，删除后进行自平衡处理。</p><h3 id="删除后实现自平衡">删除后实现自平衡<a href="#删除后实现自平衡" title="删除后实现自平衡"></a></h3><p><strong>二叉搜索树删除</strong>的时候可能出现三种场景：</p><ul><li>场景一：若删除结点<strong>无</strong>子结点，<strong>直接删除</strong>即可；</li><li>场景二：若删除结点只有<strong>一个</strong>子结点，用<strong>子结点</strong>替换删除结点；</li><li>场景三：若删除结点有<strong>两个</strong>子结点，用<strong>后继结点（大于删除结点的最小结点）</strong>替换删除结点。</li></ul><p>具体应用，可以借助这张图理解：</p><p><img src="/2020/red-black-tree/binary-tree-delete-example.png" class="φcy"></p><p>我们可以发现，另外两种二叉树的删除场景都可以通过相互转换变为场景一。</p><p>在场景二情况下：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为场景三，一直自顶向下转换，总是能转换为场景一。</p><p>在场景三情况下：删除结点用后继结点，如果后继结点有右子结点，那么相当于转换为场景二，否则转为场景一。</p><p><img src="/2020/red-black-tree/binary-tree-delete-situation.png" class="φcy"></p><p>综上所述，<strong>删除的结点可以看作删除替换结点</strong>，且<strong>替换结点最后总是在树末</strong>。</p><p>下面总结一下<strong>红黑树删除</strong>可能出现的<strong>所有场景</strong>。</p><p><img src="/2020/red-black-tree/rbtree-delete-all.png" class="φcy"></p><p>为了方面理解，我们先约定一下结点的叫法：</p><p><img src="/2020/red-black-tree/rbtree-delete-node-definition.png" class="φcy"></p><ul><li>R - <strong>替换结点</strong></li><li>P - 替换结点的<strong>父结点</strong></li><li>S - 替换结点的<strong>兄弟结点</strong></li><li>SL - 兄弟结点的<strong>左子结点</strong></li><li>SR - 兄弟结点的<strong>右子结点</strong></li><li>灰色 - 结点颜色可能是红色，也可能是黑色</li></ul><p>注意：<strong>R 是即将被替换到删除结点的位置的替换结点</strong>，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</p><p><strong>场景 1：替换结点为红色</strong></p><p>我们把替换结点换到了删除结点的位置时，由于替换结点为红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色变为删除的结点的颜色即可重新平衡。</p><p><strong>处理</strong>：替换结点颜色变为删除结点的颜色。</p><p><strong>场景 2：替换结点为黑色</strong></p><p>当替换结点是黑色时，就必须进行自平衡处理了，我们可以通过区分替换结点是其父结点的左子结点还是右子结点，来做不同的旋转，使树重新平衡。</p><p><strong>场景 2.1：替换结点是左子树</strong></p><p><strong>场景 2.1.1：替换结点的兄弟结点为红色</strong></p><p>若兄弟结点是红结点，那么根据红黑树性质4，兄弟结点的父结点和子结点肯定为黑色，按照下图方式处理，得到删除场景 2.1.2.3。</p><p><img src="/2020/red-black-tree/rbtree-delete-2-1-1.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将兄弟结点变为黑色</li><li>将父结点变为红色</li><li>对父结点进行左旋，得到场景 2.1.2.3</li><li>进行场景 2.1.2.3 的处理</li></ul><p><strong>场景 2.1.2：替换结点的兄弟结点为黑色</strong></p><p>当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定，此时又得考虑多种子场景。</p><p><strong>场景 2.1.2.1：替换结点的兄弟结点的右子结点为红色，左子结点任意颜色</strong></p><p>即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子结点又是红色，那么我们直接向右子树“借”个红结点来补充黑结点，并进行旋转处理。如图所示：</p><p><img src="/2020/red-black-tree/rbtree-delete-2-1-2-1.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将兄弟结点的颜色变为父结点的颜色</li><li>将父结点变为黑色</li><li>将兄弟结点的右子结点变为黑色</li><li>对父结点进行左旋</li></ul><p><strong>场景 2.1.2.2：替换结点的兄弟结点的右子结点为黑色，左子结点为红色</strong></p><p>兄弟结点所在的子树有红结点，又可以向兄弟子树“借”个红结点过来，这就转换回了场景 2.1.2.1。如图所示：</p><p><img src="/2020/red-black-tree/rbtree-delete-2-1-2-2.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将兄弟结点变为红色</li><li>将兄弟结点的左子结点变为黑色</li><li>对兄弟结点进行右旋，得到场景 2.1.2.1</li><li>进行场景 2.1.2.1 的处理</li></ul><p><strong>场景 2.1.2.3：替换结点的兄弟结点的子结点都为黑色</strong></p><p>兄弟子树没有红结点可以“借”了，再向父结点“借”。如果父结点是黑色，为了让父结点在所在的子树中保证平衡（替换结点即将删除，少了一个黑色结点，子树也需要少一个）先把兄弟结点变为红色，再让父结点成为新的替换结点。</p><p><img src="/2020/red-black-tree/rbtree-delete-2-1-2-3.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>如果父结点为黑色<ul><li>将兄弟结点变为红色</li><li>将父结点作为新的替换结点</li><li>重新进行删除结点的场景处理</li></ul></li><li>如果父结点为红色<ul><li>替换结点的父结点和替换结点的兄弟结点颜色交换</li><li>删除结点和替换结点的值交换后，删除替换结点</li></ul></li></ul><p><strong>场景 2.2：替换结点是右子树</strong></p><p>实际上是场景 2.1 的镜像操作。</p><p><strong>场景 2.2.1：替换结点的兄弟结点为红色</strong></p><p><img src="/2020/red-black-tree/rbtree-delete-2-2-1.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将兄弟结点变为黑色</li><li>将父结点变为红色</li><li>对父结点进行右旋，得到场景 2.2.2.3</li><li>进行场景 2.2.2.3 的处理</li></ul><p><strong>场景 2.2.2：替换结点的兄弟结点为黑色</strong></p><p><strong>场景 2.2.2.1：替换结点的兄弟结点的左子结点为红色，右子结点任意颜色</strong></p><p><strong>处理</strong></p><p><img src="/2020/red-black-tree/rbtree-delete-2-2-2-1.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将兄弟结点的颜色变为父结点的颜色</li><li>将父结点变为黑色</li><li>将兄弟结点的左子结点变为黑色</li><li>对父结点进行右旋</li></ul><p><strong>场景 2.2.2.2：替换结点的兄弟结点的左子结点为黑色，右子结点为红色</strong></p><p><img src="/2020/red-black-tree/rbtree-delete-2-2-2-2.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>将兄弟结点变为红色</li><li>将兄弟结点的右子结点设为黑色</li><li>对兄弟结点进行左旋，得到场景 2.2.2.1</li><li>进行场景 2.2.2.1 的处理</li></ul><p><strong>场景 2.2.2.3：替换结点的兄弟结点的子结点都为黑色</strong></p><p><img src="/2020/red-black-tree/rbtree-delete-2-2-2-3.png" class="φcy"></p><p><strong>处理</strong>：</p><ul><li>如果父结点为黑色<ul><li>将兄弟结点变为红色</li><li>将父结点作为新的替换结点</li><li>重新进行删除结点的场景处理</li></ul></li><li>如果父结点为红色<ul><li>替换结点的父结点和替换结点的兄弟结点颜色交换</li><li>删除结点和替换结点的值交换后，删除替换结点</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑树（Red Black Tree）是一种自平衡的二叉搜索树（Self-balancing Binary Search Tree）。以前也叫做平衡二叉 B 树（Symmetric Binary B-tree）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://blog.fiteen.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://blog.fiteen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="AVL 树" scheme="https://blog.fiteen.top/tags/AVL-%E6%A0%91/"/>
    
      <category term="B 树" scheme="https://blog.fiteen.top/tags/B-%E6%A0%91/"/>
    
      <category term="红黑树" scheme="https://blog.fiteen.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>『2019』未来可期</title>
    <link href="https://blog.fiteen.top/2019/annual-summary-2019/"/>
    <id>https://blog.fiteen.top/2019/annual-summary-2019/</id>
    <published>2019-12-31T22:12:43.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>年纪越大，越感受到时光易逝。</p><a id="more"></a><h2 id="经历">经历<a href="#经历" title="经历"></a></h2><h3 id="工作">工作<a href="#工作" title="工作"></a></h3><p>随着 ReactNative、Weex 与 Flutter 等跨端框架的发展，大前端渐渐成为了我们客户端开发者的转型之路，由于近年来过审情况严峻、金融合规转型等问题，我司大部分的 iOS 开发工程师都或多或少地兼任了 Android 、前端和小程序的开发工作，或者直接转型成前端开发工程师。所以这一年，我的主要工作内容也就涵盖了 App 的主导开发上架和部分前端项目的开发维护，与此同时，接触了 Flutter 混编、H5 首屏加载优化、重签名、多渠道包方案、抓包与防抓包技术等。</p><h3 id="买房">买房<a href="#买房" title="买房"></a></h3><p>从2018年10月份准备买房以来，前前后后参加了二十多次摇号，就在准备放弃摇号选择二手房的时候，终于在今年十月底摇到比较心仪的房子，在父母的帮助下多付了一些首付，贷款也顺利办理下来。中签那天，有一种不可言喻的预感，相信玄学，听了一早上的“好运来”，果然就看到了摇中的结果。实现了人生的一件大事，总算可以舒一口气，参加工作以来，一直抠抠索索，想要尽可能多地去攒些首付，如今竟然有了财务自由的感觉。</p><h3 id="理财">理财<a href="#理财" title="理财"></a></h3><p>考虑到买房的时候，需要不定时进行验资登记，加之去年 P2P 暴雷至今没有兑付的惨痛经历，今年没有分配太多的资产放在基金股票上面，基本上还是选择保本的活期/短期低收益理财。值得欣慰的是，年中还负百分之十几的基金理财的如今终于回本了。</p><p>有人说，理财是最好的副业。希望接下来能多抽一些时间来修习好这门功课。</p><h3 id="游戏">游戏<a href="#游戏" title="游戏"></a></h3><p>游戏方面，自我感觉不是很有天赋的人，为了和朋友同事有更多共同语言，开始打王者荣耀，关注电竞行业。精打细算的我，居然也成为了氪金玩家，为了不浪费花钱升级的战令，S16赛季排位打上了一次最强王者。谈及王者荣耀的火爆，很多人认为不过是抄袭英雄联盟，但不得不说，腾讯在这款游戏的产品设计和运营上确实是非常成功的。它很大程度上弥补了竞技对战类游戏在MOBA类手游的空缺，游戏内的丰富场景、排位机制、氪金模式，以及游戏社交更是保证了玩家的持续活跃和留存。</p><p>因为欣赏职业选手 Cat，今年九月份还去上海现场看了 KPL 秋季赛 eStarPro 和 RW 侠的揭幕战。这个刚满21岁的男孩，颜值并不高，操作不是顶尖，英雄池也常被诟病，却是联盟里现役选手中人气最高的。三年职业生涯，他去过巅峰，也曾坠入低谷，外界对他的质疑从未间断。但是三百六十行，行行出状元，只要有恒心有毅力，总有看到光明的一天。</p><h3 id="旅游">旅游<a href="#旅游" title="旅游"></a></h3><p>这个命题，对于我来说，几年间基本上都是接近空白的，今年除了去上海看比赛的时候顺道去外滩和南京步行街逛了逛，就是 Outing 时去千岛湖感受了一下五星级酒店。没错，贫穷限制了我的消费欲望。但是，我一直相信眼界决定胸怀，胸怀决定高度。希望下一年，有时间多去看看外面的风景，多尝试新的挑战。</p><h2 id="感悟">感悟<a href="#感悟" title="感悟"></a></h2><p>2019年的成长，最多地来源于心态和思维方式上的成长。</p><p>很多领悟是经历带给我的，我开始学会思考，过去的人生里，到底做错了什么选择，到底遗失过什么，到底想到什么样的生活。</p><h3 id="选择">选择<a href="#选择" title="选择"></a></h3><p>有人说，选择比努力更重要。从前，我对这个说法嗤之以鼻，一度傻傻地认为努力可以弥补所有的缺憾。可以回过头来看看，发现自己已然因为一些目光短浅的选择，需要付出成倍的努力去弥补。比如实习期为了一个月多五百元的薪资放弃了大公司，而选择了一家没有太大上升空间的小公司；比如以为房地产行业会继续下行，而错过了置业的最佳时机。</p><p>没有方向的船，任何方向都是逆风。那时的我只是愚蠢地想着要比同学的工资高一些，却忘记了，大学里辛辛苦苦熬夜写的论文、做的视频、写的项目、获的奖项，不过是第一份实习工作的敲门砖，做错了选择，很多努力就失去了价值。</p><p>人生的岔路口上，如果明确知道自己想要什么，那就筚路蓝缕，以启山林，如果感到迷茫和困惑，不如沉下心来好好思考，或者多听取他人的经验，世事总不能万般如意，有舍才有得。</p><h3 id="忧患">忧患<a href="#忧患" title="忧患"></a></h3><p>《论语》里说道：人无远虑，必有近忧。在经历资本狂欢以后，烧钱、补贴、大跃进的扩张模式，互联网的寒冬真的来了。身边的朋友、同事也相继产生了强烈的危机感，受到影响的我也开始谨慎思考自己现在应该何去何从，等五年后步入而立未来又将去往哪里。</p><p>做技术的这几年，我深切地感受到了持续学习和自我驱动的重要性。人生就是一个不断学习的过程，有时候工作促使你不得不开始学习，而学习又能令你不断进步，从而遇到更好的工作，只有在这样的良性循环中，才能找到更适合自己的位置。但愿新的一年，能够不辜负曾经的辛苦，实现心中的愿景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年纪越大，越感受到时光易逝。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://blog.fiteen.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>动画详解十大经典排序算法（C语言版）</title>
    <link href="https://blog.fiteen.top/2019/sorting-algorithm/"/>
    <id>https://blog.fiteen.top/2019/sorting-algorithm/</id>
    <published>2019-12-27T22:58:49.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是程序员必备的基础知识，弄明白它们的原理和实现很有必要。本文中将通过非常细节的动画展示出算法的原理，配合代码更容易理解。</p><a id="more"></a><h2 id="概述">概述<a href="#概述" title="概述"></a></h2><p>由于待排序的元素数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两类：一类是<strong>内部排序</strong>，指的是待排序列存放在计算机随机存储器中进行的排序过程；另一类是<strong>外部排序</strong>，指的是待排序的元素的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</p><p>我们可以将常见的<strong>内部排序算法</strong>可以分成两类：</p><p><img src="/2019/sorting-algorithm/sort-category.png" class="φcy"></p><p><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，时间复杂度为 O(nlogn)～O(n²)。属于比较类的有：</p><div class="φcz"><div class="φdb"><table><thead><tr><th align="center">排序算法</th><th align="center">时间复杂度</th><th align="center">最差情况</th><th align="center">最好情况</th><th align="center">空间复杂度</th><th align="center">排序方式</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center"><a href="#bubble-sort">冒泡排序</a></td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(n)</td><td align="center">O(1)​</td><td align="center">In-place</td><td align="center">✔</td></tr><tr><td align="center"><a href="#quick-sort">快速排序</a></td><td align="center">O(nlogn)​</td><td align="center">O(n²)</td><td align="center">O(nlogn)​</td><td align="center">O(logn)​</td><td align="center">In-place</td><td align="center">✘</td></tr><tr><td align="center"><a href="#insertion-sort">插入排序</a></td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(n)​</td><td align="center">O(1)​</td><td align="center">In-place</td><td align="center">✔</td></tr><tr><td align="center"><a href="#shell-sort">希尔排序</a></td><td align="center">O(nlog²n)​</td><td align="center">O(n²)</td><td align="center">O(n)​</td><td align="center">O(1)​</td><td align="center">In-place</td><td align="center">✘</td></tr><tr><td align="center"><a href="#selection-sort">选择排序</a></td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)​</td><td align="center">In-place</td><td align="center">✘</td></tr><tr><td align="center"><a href="#heap-sort">堆排序</a></td><td align="center">O(nlogn)​</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)​</td><td align="center">O(1)​</td><td align="center">In-place</td><td align="center">✘</td></tr><tr><td align="center"><a href="#merge-sort">归并排序</a></td><td align="center">O(nlogn)​</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)​</td><td align="center">O(n)​</td><td align="center">Out-place</td><td align="center">✔</td></tr></tbody></table></div></div><p><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，其时间复杂度可以突破 O(nlogn)，以线性时间运行。属于非比较类的有：</p><div class="φcz"><div class="φdb"><table><thead><tr><th align="center">排序算法</th><th align="center">时间复杂度</th><th align="center">最差情况</th><th align="center">最好情况</th><th align="center">空间复杂度</th><th align="center">排序方式</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center"><a href="#bucket-sort">桶排序</a></td><td align="center">O(n+nlog(n/r))​</td><td align="center">O(n²)</td><td align="center">O(n)​</td><td align="center">O(n+r)​</td><td align="center">Out-place</td><td align="center">✔</td></tr><tr><td align="center"><a href="#counting-sort">计数排序</a></td><td align="center">O(n+r)​</td><td align="center">O(n+r)​</td><td align="center">O(n+r)​</td><td align="center">O(n+r)​</td><td align="center">Out-place</td><td align="center">✔</td></tr><tr><td align="center"><a href="#radix-sort">基数排序</a></td><td align="center">O(d(n+r))​</td><td align="center">O(d(n+r))</td><td align="center">O(d(n+r))</td><td align="center">O(n+r)​</td><td align="center">Out-place</td><td align="center">✔</td></tr></tbody></table></div></div><p><strong>名次解释</strong>：</p><p><strong><a href="asymptotic-time-complexity-and-space-complexity">时间/空间复杂度</a></strong>：描述一个算法执行时间/占用空间与数据规模的增长关系</p><p><strong>n</strong>：待排序列的个数</p><p><strong>r</strong>：“桶”的个数（上面的三种非比较类排序都是基于“桶”的思想实现的）</p><p><strong>d</strong>：待排序列的最高位数</p><p><strong>In-place</strong>：原地算法，指的是占用常用内存，不占用额外内存。空间复杂度为 O(1) 的都可以认为是原地算法</p><p><strong>Out-place</strong>：非原地算法，占用额外内存</p><p><strong>稳定性</strong>：假设待排序列中两元素相等，排序前后这两个相等元素的相对位置不变，则认为是稳定的。</p><h2 id="冒泡排序"><span id="bubble-sort">冒泡排序</span><a href="#冒泡排序" title="冒泡排序"></a></h2><p>冒泡排序（Bubble Sort），顾名思义，就是指越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h3 id="算法原理">算法原理<a href="#算法原理" title="算法原理"></a></h3><ol><li>从左到右，依次比较相邻的元素大小，更大的元素交换到右边；</li><li>从第一组相邻元素比较到最后一组相邻元素，这一步结束最后一个元素必然是参与比较的元素中最大的元素；</li><li>按照大的居右原则，重新从左到后比较，前一轮中得到的最后一个元素不参与比较，得出新一轮的最大元素；</li><li>按照上述规则，每一轮结束会减少一个元素参与比较，直到没有任何一组元素需要比较。</li></ol><h3 id="动图演示">动图演示<a href="#动图演示" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/bubble-sort.gif" class="φcy"></p><h3 id="代码实现">代码实现<a href="#代码实现" title="代码实现"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析">算法分析<a href="#算法分析" title="算法分析"></a></h3><p>冒泡排序属于<strong>交换排序</strong>，是<strong>稳定排序</strong>，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。</p><p>但是我们常看到冒泡排序的<strong>最优时间复杂度是 O(n)</strong>，那要如何优化呢？</p><p>我们可以用一个 flag 参数记录新一轮的排序中元素是否做过交换，如果没有，说明前面参与比较过的元素已经是正序，那就没必要再从头比较了。代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort_quicker</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, flag;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><span id="quick-sort">快速排序</span><a href="#快速排序" title="快速排序"></a></h2><p>快速排序（Quick Sort），是冒泡排序的改进版，之所以“快速”，是因为使用了<strong>分治法</strong>。它也属于<strong>交换排序</strong>，通过元素之间的位置交换来达到排序的目的。</p><h3 id="基本思想">基本思想<a href="#基本思想" title="基本思想"></a></h3><p>在序列中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</p><p><strong>一趟快速排序</strong>的具体做法是：</p><ol><li>设两个指针 i 和 j，分别指向序列的头部和尾部；</li><li>先从 j 所指的位置向前搜索，找到第一个比基准小的值，把它与基准交换位置；</li><li>再从 i 所指的位置向后搜索，找到第一个比基准大的值，把它与基准交换位置；</li><li>重复 2、3 两步，直到 i = j。</li></ol><p>仔细研究一下上述算法我们会发现，在排序过程中，对基准的移动其实是多余的，因为只有一趟排序结束时，也就是 i = j 的位置才是基准的最终位置。</p><p>由此可以<strong>优化</strong>一下算法：</p><ol><li>设两个指针 i 和 j，分别指向序列的头部和尾部；</li><li>先从 j 所指的位置向前搜索，找到第一个比基准小的数值后停下来，再从 i 所指的位置向后搜索，找到第一个比基准大的数值后停下来，把 i 和 j 指向的两个值交换位置；</li><li>重复步骤2，直到 i = j，最后将相遇点指向的值与基准交换位置。</li></ol><h3 id="动图演示-1">动图演示<a href="#动图演示-1" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/quick-sort.gif" class="φcy"></p><h3 id="代码实现-1">代码实现<a href="#代码实现-1" title="代码实现"></a></h3><p>这里取序列的第一个元素为基准。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选取序列的第一个元素作为基准 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_pivot</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, pivot;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">    pivot = select_pivot(arr, low);</span><br><span class="line">    i = low;</span><br><span class="line">    j = high;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) j--;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = arr[i];</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    quick_sort(arr, low, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort(arr, i + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-1">算法分析<a href="#算法分析-1" title="算法分析"></a></h3><p>快速排序是<strong>不稳定排序</strong>，它的平均时间复杂度为 O(nlogn)，平均空间复杂度为 O(logn)。</p><p>快速排序中，基准的选取非常重要，它将影响排序的效率。举个例子，假如序列本身顺序随机，快速排序是所有同数量级时间复杂度的排序算法中平均性能最好的，但如果序列本身已经有序或基本有序，直接<strong>选取固定位置，例如第一个元素</strong>作为基准，会使快速排序就会沦为冒泡排序，时间复杂度为 O(n^2)。为了避免发生这种情况，引入下面两种获取基准的方法：</p><p><strong>随机选取</strong></p><p>就是选取序列中的任意一个数为基准的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 随机选择基准的位置，区间在 low 和 high 之间 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_pivot_random</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> pivot = rand()%(high - low) + low;</span><br><span class="line">    swap(arr, pivot, low);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三者取中</strong></p><p>就是取起始位置、中间位置、末尾位置指向的元素，对这三个元素排序后取中间数作为基准。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 取起始位置、中间位置、末尾位置指向的元素三者的中间值作为基准 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_pivot_median_of_three</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算数组中间的元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 排序，使 arr[mid] &lt;= arr[low] &lt;= arr[high]</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[high]) swap(arr, mid, high);</span><br><span class="line">    <span class="keyword">if</span> (arr[low] &gt; arr[high]) swap(arr, low, high);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[low]) swap(arr, low, mid);</span><br><span class="line">    <span class="comment">// 使用 low 位置的元素作为基准</span></span><br><span class="line">    <span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经验证明，三者取中的规则可以大大改善快速排序在最坏情况下的性能。</p><h2 id="插入排序"><span id="insertion-sort">插入排序</span><a href="#插入排序" title="插入排序"></a></h2><p>直接插入排序（Straight Insertion Sort），是一种简单直观的排序算法，它的基本操作是不断地将尚未排好序的数插入到已经排好序的部分，好比打扑克牌时一张张抓牌的动作。在冒泡排序中，经过每一轮的排序处理后，序列后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，序列前端的数都是排好序的。</p><h3 id="基本思想-1">基本思想<a href="#基本思想-1" title="基本思想"></a></h3><p>先将第一个元素视为一个有序子序列，然后从第二个元素起逐个进行插入，直至整个序列变成元素非递减有序序列为止。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入大相等元素的后面。整个排序过程进行 n-1 趟插入。</p><h3 id="动图演示-2">动图演示<a href="#动图演示-2" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/insertion-sort.gif" class="φcy"></p><h3 id="代码实现-2">代码实现<a href="#代码实现-2" title="代码实现"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp; j--)</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-2">算法分析<a href="#算法分析-2" title="算法分析"></a></h3><p>插入排序是<strong>稳定排序</strong>，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。</p><h2 id="希尔排序"><span id="shell-sort">希尔排序</span><a href="#希尔排序" title="希尔排序"></a></h2><p>希尔排序（Shell’s Sort）是第一个突破 O(n²) 的排序算法，是直接插入排序的改进版，又称“<strong>缩小增量排序</strong>”（Diminishing Increment Sort）。它与直接插入排序不同之处在于，它会优先比较距离较远的元素。</p><h3 id="基本思想-2">基本思想<a href="#基本思想-2" title="基本思想"></a></h3><p>先将整个待排序列分割成若干个字序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p><p>子序列的构成不是简单地“逐段分割”，将相隔某个增量的记录组成一个子序列，让增量逐趟缩短，直到增量为 1 为止。</p><h3 id="动图演示-3">动图演示<a href="#动图演示-3" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/shell-sort.gif" class="φcy"></p><h3 id="代码实现-3">代码实现<a href="#代码实现-3" title="代码实现"></a></h3><p>增量序列可以有各种取法，例如上面动图所示，增量序列满足 [n / 2, n / 2 / 2, …, 1]，n 是序列本身的长度，这也是一种比较流行的增量序列定义方式。这时希尔排序的算法可以通过下面的代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort_split_half</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, dk, temp;</span><br><span class="line">    <span class="keyword">for</span> (dk = n &gt;&gt; <span class="number">1</span>; dk &gt; <span class="number">0</span>; dk = dk &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = dk; i &lt; n; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - dk; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= dk)</span><br><span class="line">                arr[j + dk] = arr[j];</span><br><span class="line">            arr[j + dk] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增量序列也可以有其它的定义方式，那么希尔排序的实现可以归纳成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_insert</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = dk; i &lt; n; i += dk) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        j = i - dk;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]) &#123;</span><br><span class="line">            arr[j + dk] = arr[j];</span><br><span class="line">            j -= dk;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + dk] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> dlta[], <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; t; ++k) &#123;</span><br><span class="line">        <span class="comment">// 一趟增量为 dlta[k] 的插入排序</span></span><br><span class="line">        shell_insert(arr, n, dlta[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-3">算法分析<a href="#算法分析-3" title="算法分析"></a></h3><p>希尔排序是<strong>不稳定排序</strong>，它的分析是一个复杂的问题，因为它的运行时间依赖于增量序列的选择，它的平均时间复杂度为O(n^1.3)，最好情况是 O(n)，最差情况是 O(n²)。空间复杂度为 O(1)。</p><h2 id="选择排序"><span id="selection-sort">选择排序</span><a href="#选择排序" title="选择排序"></a></h2><p>选择排序（Selection Sort）是一种简单直观的排序算法。它的基本思想就是，每一趟 n-i+1(i=1,2,…,n-1)个记录中选取关键字最小的记录作为有序序列的第 i 个记录。</p><h3 id="算法步骤">算法步骤<a href="#算法步骤" title="算法步骤"></a></h3><p><strong>简单选择排序</strong>：</p><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置;</li><li>在剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾;</li><li>重复步骤2，直到所有元素排序完毕。</li></ol><h3 id="动图演示-4">动图演示<a href="#动图演示-4" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/selection-sort.gif" class="φcy"></p><h3 id="代码实现-4">代码实现<a href="#代码实现-4" title="代码实现"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>])</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, <span class="built_in">min</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-4">算法分析<a href="#算法分析-4" title="算法分析"></a></h3><p>选择排序是<strong>不稳定排序</strong>，时间复杂度固定为 O(n²)，因此它不适用于数据规模较大的序列。不过它也有优点，就是不占用额外的内存空间。</p><h2 id="堆排序"><span id="heap-sort">堆排序</span><a href="#堆排序" title="堆排序"></a></h2><p>堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆的特点：</p><ul><li>一颗完全二叉树（也就是会所生成节点的顺序是：从上往下、从左往右）</li><li>每一个节点必须满足父节点的值不大于/不小于子节点的值</li></ul><h3 id="基本思想-3">基本思想<a href="#基本思想-3" title="基本思想"></a></h3><p>实现堆排序需要解决两个问题：</p><ul><li><p>如何将一个无序序列构建成堆？</p></li><li><p>如何在输出堆顶元素后，调整剩余元素成为一个新的堆？</p></li></ul><p>以升序为例，算法实现的思路为：</p><ol><li>建立一个 <code>build_heap</code> 函数，将数组 tree[0,…n-1] 建立成堆，n 表示数组长度。函数里需要维护的是所有节点的父节点，最后一个子节点下标为 n-1，那么它对应的父节点下标就是(n-1-1)/2。</li><li>构建完一次堆后，最大元素就会被存放在根节点 tree[0]。将 tree[0] 与最后一个元素交换，每一轮通过这种不断将最大元素后移的方式，来实现排序。</li><li>而交换后新的根节点可能不满足堆的特点了，因此需要一个调整函数 heapify 来对剩余的数组元素进行最大堆性质的维护。如果 tree[i] 表示其中的某个节点，那么 tree[2*i+1] 是左孩子，tree[2*i+2] 是右孩子，选出三者中的最大元素的下标，存放于 max 值中，若 max 不等于 i，则将最大元素交换到 i 下标的位置。但是，此时以 tree[max] 为根节点的子树可能不满足堆的性质，需要递归调用自身。</li></ol><h3 id="动图演示-5">动图演示<a href="#动图演示-5" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/heap-sort.gif" class="φcy"></p><h3 id="代码实现-5">代码实现<a href="#代码实现-5" title="代码实现"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> tree[], <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n 表示序列长度，i 表示父节点下标</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 左侧子节点下标</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右侧子节点下标</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; tree[left] &gt; tree[<span class="built_in">max</span>]) <span class="built_in">max</span> = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; tree[right] &gt; tree[<span class="built_in">max</span>]) <span class="built_in">max</span> = right;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> != i) &#123;</span><br><span class="line">        swap(tree, <span class="built_in">max</span>, i);</span><br><span class="line">        heapify(tree, n, <span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> tree[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 树最后一个节点的下标</span></span><br><span class="line">    <span class="keyword">int</span> last_node = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最后一个节点对应的父节点下标</span></span><br><span class="line">    <span class="keyword">int</span> parent = (last_node - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = parent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(tree, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> tree[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    build_heap(tree, n);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素与最后一个元素交换</span></span><br><span class="line">        swap(tree, i, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 调整成大顶堆</span></span><br><span class="line">        heapify(tree, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-5">算法分析<a href="#算法分析-5" title="算法分析"></a></h3><p>堆排序是<strong>不稳定排序</strong>，适合数据量较大的序列，它的平均时间复杂度为 Ο(nlogn)，空间复杂度为 O(1)。<br>此外，堆排序仅需一个记录大小供交换用的辅助存储空间。</p><h2 id="归并排序"><span id="merge-sort">归并排序</span><a href="#归并排序" title="归并排序"></a></h2><p>归并排序（Merge Sort）是建立在<strong>归并</strong>操作上的一种排序算法。它和快速排序一样，采用了<strong>分治法</strong>。</p><h3 id="基本思想-4">基本思想<a href="#基本思想-4" title="基本思想"></a></h3><p>归并的含义是将两个或两个以上的有序表组合成一个新的有序表。也就是说，从几个数据段中逐个选出最小的元素移入新数据段的末尾，使之有序。</p><p>那么归并排序的算法我们可以这样理解：</p><p>假如初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1。然后两两归并，得到 n/2 个长度为2或1的有序子序列；再两两归并，……，如此重复，直到得到一个长度为 n 的有序序列为止，这种排序方法称为 <strong>二路归并排序</strong>，下文介绍的也是这种排序方式。</p><h3 id="动图演示-6">动图演示<a href="#动图演示-6" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/merge-sort.gif" class="φcy"></p><h3 id="代码实现-6">代码实现<a href="#代码实现-6" title="代码实现"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 arr[L..M] 和 arr[M+1..R] 归并 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> LEFT_SIZE = M - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> RIGHT_SIZE = R - M;</span><br><span class="line">    <span class="keyword">int</span> left[LEFT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> right[RIGHT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="comment">// 以 M 为分割线，把原数组分成左右子数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = L; i &lt;= M; i++) left[i - L] = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (i = M + <span class="number">1</span>; i &lt;= R; i++) right[i - M - <span class="number">1</span>] = arr[i];</span><br><span class="line">    <span class="comment">// 再合并成一个有序数组（从两个序列中选出最小值依次插入）</span></span><br><span class="line">    i = <span class="number">0</span>; j = <span class="number">0</span>; k = L;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; LEFT_SIZE &amp;&amp; j &lt; RIGHT_SIZE) arr[k++] = left[i] &lt; right[j] ? left[i++] : right[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; LEFT_SIZE) arr[k++] = left[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; RIGHT_SIZE) arr[k++] = right[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将 arr[L..R] 平分为 arr[L..M] 和 arr[M+1..R]</span></span><br><span class="line">    <span class="keyword">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分别递归地将子序列排序为有序数列</span></span><br><span class="line">    merge_sort(arr, L, M);</span><br><span class="line">    merge_sort(arr, M + <span class="number">1</span>, R);</span><br><span class="line">    <span class="comment">// 将两个排序后的子序列再归并到 arr</span></span><br><span class="line">    merge(arr, L, M, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-6">算法分析<a href="#算法分析-6" title="算法分析"></a></h3><p>归并排序是<strong>稳定排序</strong>，它和选择排序一样，性能不受输入数据的影响，但表现比选择排序更好，它的时间复杂度始终为 O(nlogn)，但它需要额外的内存空间，空间复杂度为 O(n)。</p><h2 id="桶排序"><span id="bucket-sort">桶排序</span><a href="#桶排序" title="桶排序"></a></h2><p>桶排序（Bucket sort）是<a href="#counting-sort">计数排序</a>的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（也有可能是使用别的排序算法或是以递归方式继续用桶排序进行排序）。</p><h3 id="算法步骤-1">算法步骤<a href="#算法步骤-1" title="算法步骤"></a></h3><ol><li>设置固定数量的空桶；</li><li>把数据放在对应的桶内；</li><li>分别对每个非空桶内数据进行排序；</li><li>拼接非空的桶内数据，得到最终的结果。</li></ol><h3 id="动图演示-7">动图演示<a href="#动图演示-7" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/bucket-sort.gif" class="φcy"></p><h3 id="代码实现-7">代码实现<a href="#代码实现-7" title="代码实现"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || r &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据最大/最小元素和桶数量，计算出每个桶对应的元素范围</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = arr[<span class="number">0</span>], <span class="built_in">min</span> = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">max</span> &lt; arr[i]) <span class="built_in">max</span> = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span> &gt; arr[i]) <span class="built_in">min</span> = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> range = (<span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>) / r + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立桶对应的二维数组，一个桶里最多可能出现 n 个元素</span></span><br><span class="line">    <span class="keyword">int</span> buckets[r][n];</span><br><span class="line">    <span class="built_in">memset</span>(buckets, <span class="number">0</span>, <span class="keyword">sizeof</span>(buckets));</span><br><span class="line">    <span class="keyword">int</span> counts[r];</span><br><span class="line">    <span class="built_in">memset</span>(counts, <span class="number">0</span>, <span class="keyword">sizeof</span>(counts));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = (arr[i] - <span class="built_in">min</span>) / range;</span><br><span class="line">        buckets[k][counts[k]++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="comment">// 分别对每个非空桶内数据进行排序，比如计数排序</span></span><br><span class="line">        <span class="keyword">if</span> (counts[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        counting_sort(buckets[i], counts[i]);</span><br><span class="line">        <span class="comment">// 拼接非空的桶内数据，得到最终的结果</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; counts[i]; j++) &#123;</span><br><span class="line">            arr[index++] = buckets[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-7">算法分析<a href="#算法分析-7" title="算法分析"></a></h3><p>桶排序是<strong>稳定排序</strong>，但仅限于桶排序本身，假如桶内排序采用了快速排序之类的非稳定排序，那么就是不稳定的。</p><h4 id="时间复杂度">时间复杂度<a href="#时间复杂度" title="时间复杂度"></a></h4><p>桶排序的时间复杂度可以这样看：</p><ul><li>n 次循环，每个数据装入桶</li><li>r 次循环，每个桶中的数据进行排序（每个桶中平均有 n/r 个数据）</li></ul><p>假如桶内排序用的是选择排序这类时间复杂度较高的排序，整个桶排序的时间复杂度就是 O(n)+O(n²)，视作 O(n²)，这是最差的情况；<br>假如桶内排序用的是比较先进的排序算法，时间复杂度为 O(nlogn)，那么整个桶排序的时间复杂度为 O(n)+O(r*(n/r)*log(n/r))=O(n+nlog(n/r))。k=nlog(n/r)，桶排序的平均时间复杂度为 O(n+k)。当 r 接近于 n 时，k 趋近于 0，这时桶排序的时间复杂度是最优的，就可以认为是 O(n)。也就是说如果数据被分配到同一个桶中，排序效率最低；但如果数据可以均匀分配到每一个桶中，时间效率最高，可以线性时间运行。但同样地，桶越多，空间就越大。</p><h4 id="空间复杂度">空间复杂度<a href="#空间复杂度" title="空间复杂度"></a></h4><p>占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以桶排序的空间复杂度为 O(n+r)。</p><h2 id="计数排序"><span id="counting-sort">计数排序</span><a href="#计数排序" title="计数排序"></a></h2><p>计数排序（Counting Sort）是一种<strong>非比较性质</strong>的排序算法，利用了<strong>桶</strong>的思想。它的核心在于将<strong>输入的数据值转化为键存储在额外开辟的辅助空间中</strong>，也就是说这个辅助空间的长度取决于待排序列中的数据范围。</p><p>如何转化成桶思想来理解呢？我们设立 r 个桶，桶的键值分别对应从序列最小值升序到最大值的所有数值。接着，按照键值，依次把元素放进对应的桶中，然后统计出每个桶中分别有多少元素，再通过对桶内数据的计算，即可确定每一个元素最终的位置。</p><h3 id="算法步骤-2">算法步骤<a href="#算法步骤-2" title="算法步骤"></a></h3><ol><li>找出待排序列中最大值 max 和最小值 min，算出序列的数据范围 r = max - min + 1，申请辅助空间 C[r]；</li><li>遍历待排序列，统计序列中每个值为 i 的元素出现的次数，记录在辅助空间的第 i 位；</li><li>对辅助空间内的数据进行计算（从空间中的第一个元素开始，每一项和前一项相加），以确定值为 i 的元素在数组中出现的位置；</li><li>反向填充目标数组：将每个元素 i 放在目标数组的第 C[i] 位，每放一个元素就将 C[i] 减1，直到 C 中所有值都是 0</li></ol><h3 id="动图演示-8">动图演示<a href="#动图演示-8" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/counting-sort.gif" class="φcy"></p><h3 id="代码实现-8">代码实现<a href="#代码实现-8" title="代码实现"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 定义辅助空间并初始化</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = arr[<span class="number">0</span>], <span class="built_in">min</span> = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">max</span> &lt; arr[i]) <span class="built_in">max</span> = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span> &gt; arr[i]) <span class="built_in">min</span> = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> C[r];</span><br><span class="line">    <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(C));</span><br><span class="line">    <span class="comment">// 定义目标数组</span></span><br><span class="line">    <span class="keyword">int</span> R[n];</span><br><span class="line">    <span class="comment">// 统计每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) C[arr[i] - <span class="built_in">min</span>]++;</span><br><span class="line">    <span class="comment">// 对辅助空间内数据进行计算</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; r; i++) C[i] += C[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 反向填充目标数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) R[--C[arr[i] - <span class="built_in">min</span>]] = arr[i];</span><br><span class="line">    <span class="comment">// 目标数组里的结果重新赋值给 arr</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) arr[i] = R[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-8">算法分析<a href="#算法分析-8" title="算法分析"></a></h3><p>计数排序属于<strong>非交换排序</strong>，是<strong>稳定排序</strong>，适合数据范围不显著大于数据数量的序列。</p><h4 id="时间复杂度-1">时间复杂度<a href="#时间复杂度-1" title="时间复杂度"></a></h4><p>它的时间复杂度是线性的，为 O(n+r)，r 表示待排序列中的数据范围，也就是桶的个数。可以这样理解：将 n 个数据依次放进对应的桶中，再从 r 个桶中把数据按顺序取出来。</p><h4 id="空间复杂度-1">空间复杂度<a href="#空间复杂度-1" title="空间复杂度"></a></h4><p>占用额外内存，还需要 r 个桶，因此空间复杂度是 O(n+r)，计数排序快于任何比较排序算法，但这是通过牺牲空间换取时间来实现的。</p><h2 id="基数排序"><span id="radix-sort">基数排序</span><a href="#基数排序" title="基数排序"></a></h2><p>基数排序（Radix Sort）是<strong>非比较型</strong>排序算法，它和<a href="#counting-sort">计数排序</a>、<a href="#bucket-sort">桶排序</a>一样，利用了“<strong>桶</strong>”的概念。基数排序不需要进行记录关键字间的比较，是一种<strong>借助多关键字排序的思想对单逻辑关键字进行排序</strong>的方法。比如数字100，它的个位、十位、百位就是不同的关键字。</p><p>那么，对于一组乱序的数字，基数排序的实现原理就是将整数按位数（关键字）切割成不同的数字，然后按每个位数分别比较。对于关键字的选择，有最高位优先法（MSD法）和最低位优先法（LSD法）两种方式。MSD 必须将序列先逐层分割成若干子序列，然后再对各子序列进行排序；而 LSD 进行排序时，不必分成子序列，对每个关键字都是整个序列参加排序。</p><h3 id="算法步骤-3">算法步骤<a href="#算法步骤-3" title="算法步骤"></a></h3><p>以 <strong>LSD 法</strong>为例：</p><ol><li>将所有待比较数值（非负整数）统一为同样的数位长度，数位不足的数值前面补零</li><li>从最低位（个位）开始，依次进行一次排序</li><li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li></ol><p>如果要支持负数参加排序，可以将序列中所有的值加上一个常数，使这些值都成为非负数，排好序后，所有的值再减去这个常数。</p><h3 id="动图演示-9">动图演示<a href="#动图演示-9" title="动图演示"></a></h3><p><img src="/2019/sorting-algorithm/radix-sort.gif" class="φcy"></p><h3 id="代码实现-9">代码实现<a href="#代码实现-9" title="代码实现"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基数，范围0~9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIX 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取最大值和最小值</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = arr[<span class="number">0</span>], <span class="built_in">min</span> = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j, l;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">max</span> &lt; arr[i]) <span class="built_in">max</span> = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span> &gt; arr[i]) <span class="built_in">min</span> = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假如序列中有负数，所有数加上一个常数，使序列中所有值变成正数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">min</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) arr[i] -= <span class="built_in">min</span>;</span><br><span class="line">        <span class="built_in">max</span> -= <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取最大值位数</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">max</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">max</span> /= RADIX;</span><br><span class="line">        d ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[RADIX][n];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">queue</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="keyword">int</span> count[RADIX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">        <span class="comment">// 分配数据</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = arr[j] % (<span class="keyword">int</span>)<span class="built_in">pow</span>(RADIX, i + <span class="number">1</span>) / (<span class="keyword">int</span>)<span class="built_in">pow</span>(RADIX, i);</span><br><span class="line">            <span class="built_in">queue</span>[key][count[key]++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收集数据</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RADIX; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; count[j]; l++) &#123;</span><br><span class="line">                arr[c++] = <span class="built_in">queue</span>[j][l];</span><br><span class="line">                <span class="built_in">queue</span>[j][l] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假如序列中有负数，收集排序结果时再减去前面加上的常数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">min</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) arr[i] += <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-9">算法分析<a href="#算法分析-9" title="算法分析"></a></h3><p>基数排序是<strong>稳定排序</strong>，适用于关键字取值范围固定的排序。</p><h4 id="时间复杂度-2">时间复杂度<a href="#时间复杂度-2" title="时间复杂度"></a></h4><p>基数排序可以看作是若干次“分配”和“收集”的过程。假设给定 n 个数，它的最高位数是 d，基数（也就是桶的个数）为 r，那么可以这样理解：共进行 d 趟排序，每趟排序都要对 n 个数据进行分配，再从 r 个桶中收集回来。所以算法的时间复杂度为 O(d(n+r))，在整数的排序中，r = 10，因此可以简化成 O(dn)，是<strong>线性阶</strong>的排序。</p><h4 id="空间复杂度-2">空间复杂度<a href="#空间复杂度-2" title="空间复杂度"></a></h4><p>占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以基数排序的空间复杂度为 O(n+r)。</p><h3 id="计数排序-amp-桶排序-amp-基数排序">计数排序 &amp; 桶排序 &amp; 基数排序<a href="#计数排序-amp-桶排序-amp-基数排序" title="计数排序 &amp; 桶排序 &amp; 基数排序"></a></h3><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>桶排序：每个桶存储一定范围的数值，适用于元素尽可能分布均匀的排序；</li><li>计数排序：每个桶只存储单一键值，适用于最大值和最小值尽可能接近的排序；</li><li>基数排序：根据键值的每位数字来分配桶，适用于非负整数间的排序，且最大值和最小值尽可能接近。</li></ul><hr><p>本文关联<a href="https://github.com/fiteen/Sorting-Algorithm" target="_blank">项目地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法是程序员必备的基础知识，弄明白它们的原理和实现很有必要。本文中将通过非常细节的动画展示出算法的原理，配合代码更容易理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://blog.fiteen.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://blog.fiteen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="https://blog.fiteen.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>为你的 GitHub 开源项目制作高大上的徽标</title>
    <link href="https://blog.fiteen.top/2019/make-badge-via-shields-io/"/>
    <id>https://blog.fiteen.top/2019/make-badge-via-shields-io/</id>
    <published>2019-12-15T18:17:23.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常逛 GitHub 的同学会发现，很多优秀的开源框架里都会出现这样的小徽标。</p><a id="more"></a><p><img src="/2019/make-badge-via-shields-io/badge-sample.png" class="φcy"></p><p>它的实现其实非常简单，借助一些小工具即可，比如：<a href="https://shields.io" target="_blank">shield.io</a>、<a href="https://badgen.net" target="_blank">Badgen</a>、<a href="https://ellerbrock.github.io/open-source-badges/" target="_blank">Open Source Badges</a>、<a href="https://badge.fury.io" target="_blank">Version Badge</a>、<a href="https://forthebadge.com" target="_blank">FOR THE BADGE</a> 等。这里推荐最经典全面的 shield.io。</p><h2 id="静态徽标">静态徽标<a href="#静态徽标" title="静态徽标"></a></h2><p>一个简单的静态徽标链接的标准格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;$&#123;label&#125;-$&#123;message&#125;-$&#123;color&#125;.svg</span><br></pre></td></tr></table></figure><p><strong>label</strong> 表示徽标左半部分信息，可选填，<strong>message</strong> 表示徽标右半部分信息，<strong>color</strong> 表示徽标右半部分的背景颜色。<code>.svg</code> 可以省略。</p><p>如果徽标里的文字包含 <code>-</code>，需要写成 <code>--</code>，比如：</p><p>那么 <img src="https://img.shields.io/badge/language-Objective--C-green"> 徽标，就要这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 加上 .svg</span><br><span class="line">![](https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;language-Objective--C-green.svg)</span><br><span class="line">&#x2F;&#x2F; 省略 .svg</span><br><span class="line">![](https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;language-Objective--C-green)</span><br></pre></td></tr></table></figure><p>如果你不需要两部分信息，比如我的带链接的博客徽标 <a href="https://blog.fiteen.top" target="_blank"><img src="https://img.shields.io/badge/@FiTeen-grey"></a> ，就可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![](https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;@FiTeen-grey)](https:&#x2F;&#x2F;blog.fiteen.top)</span><br></pre></td></tr></table></figure><h3 id="color">color<a href="#color" title="color"></a></h3><p>关于 <strong>color</strong>，你可以直接填入<strong>颜色英文</strong>，比如：</p><p><span><img src="https://img.shields.io/badge/-red-red"> <img src="https://img.shields.io/badge/pink-pink"> <img src="https://img.shields.io/badge/-orange-orange.svg"> <img src="https://img.shields.io/badge/yellow-yellow"> <img src="https://img.shields.io/badge/brightgreen-brightgreen"> <img src="https://img.shields.io/badge/green-green"> <img src="https://img.shields.io/badge/yellowgreen-yellowgreen"> <img src="https://img.shields.io/badge/blue-blue"> <img src="https://img.shields.io/badge/royalblue-royalblue"> <img src="https://img.shields.io/badge/cyan-cyan.svg"> <img src="https://img.shields.io/badge/blueviolet-blueviolet"> <img src="https://img.shields.io/badge/purple-purple"> <img src="https://img.shields.io/badge/grey-grey"> <img src="https://img.shields.io/badge/lightgrey-lightgrey"></span></p><p>也可以用这些<strong>特殊词汇</strong>来代替颜色：</p><p><span><img src="https://img.shields.io/badge/success-success"> <img src="https://img.shields.io/badge/important-important"> <img src="https://img.shields.io/badge/critical-critical"> <img src="https://img.shields.io/badge/informational-informational"> <img src="https://img.shields.io/badge/inactive-inactive"></span></p><p>或者直接通过<strong>十六进制颜色码</strong>，比如：</p><p><span><img src="https://img.shields.io/badge/ffb6c1-ffb6c1"> <img src="https://img.shields.io/badge/7b68ee-7b68ee"> <img src="https://img.shields.io/badge/5f9ea0-5f9ea0"></span></p><h3 id="样式">样式<a href="#样式" title="样式"></a></h3><p>目前支持五种徽标样式，具体实现就是在 svg 路径后面拼接参数。<code>flat</code> 是默认样式。</p><ul><li><code>?style=plastic</code> <img src="https://img.shields.io/badge/style-plastic-green?style=plastic.svg"></li><li><code>?style=flat</code> <img src="https://img.shields.io/badge/style-flat.svg-green?style=flat"></li><li><code>?style=flat-square</code> <img src="https://img.shields.io/badge/style-flat--square-green.svg?style=flat-square"></li><li><code>?style=for-the-badge</code> <img src="https://img.shields.io/badge/style-for--the--badge-green.svg?style=for-the-badge"></li><li><code>?style=social</code> <img src="https://img.shields.io/badge/style-social-green?style=social"></li></ul><p>除此之外，还有一些 query string 参数：</p><ul><li><code>label</code> - 覆盖原有的 label 文本内容。</li><li><code>labelColor</code> 或 <code>labelA</code> - 覆盖原有的 label 背景颜色，默认颜色是 <code>grey</code>。注意这里不能用特殊词汇表示颜色。</li><li><code>logo</code> - 可以插入以下名称之一的徽标（bitcoin、dependabot、discord、gitlab、npm、paypal、serverfault、stackexchange、superuser、telegram、travis）或简单图标。使用简单图标站点上显示的名称来引用简单图标。如果名称中包含空格，用短划线 <code>-</code> 代替(例如: <code>?logo=visual-studio-code</code>) <img src="https://img.shields.io/badge/IDE-VSCode-green?logo=visual-studio-code">。或者插入自定义徽标 logo 图像（高度≥14px）。</li><li><code>logoColor</code> - 设置徽标 logo 的颜色。</li><li><code>logoWidth</code> - 设置徽标 logo 的水平宽度。</li><li><code>link</code> - 指定徽标左/右侧部分的点击操作，格式为：<code>?link=${label-url}&amp;link=${message-url}</code>。</li><li><code>color</code> 或 <code>colorB</code> - 覆盖原有的 message 背景颜色。</li><li><code>cacheSeconds</code> - 设置 HTTP 缓存生存期（规则适用于根据每个徽章推断默认值，低于默认值的任何指定值都将被忽略）。还支持传统名称“ maxAge”。</li></ul><h2 id="动态徽标">动态徽标<a href="#动态徽标" title="动态徽标"></a></h2><p>动态徽标是指会随着项目状态变化，自动更新状态的徽标。GitHub 项目中常用的动态徽标有：</p><h3 id="build-状态">build 状态<a href="#build-状态" title="build 状态"></a></h3><ul><li><p><strong>Travis（.org）：</strong><code>https://travis-ci.org/:user/:repo</code></p></li><li><p><strong>Travis（.org）branch：</strong><code>https://travis-ci.org/:user/:repo/:branch</code></p></li><li><p><strong>GitHub Workflow Status：</strong><code>/github/workflow/build/:user/:repo/:workflow</code></p></li><li><p><strong>GitHub Workflow Status (branch)：</strong><code>https://github.com/:user/:repo/workflows/build/badge.svg?branch=${branch}</code></p></li></ul><p>例如 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank">AFNetworking</a> 的 build 状态为：<a href="https://travis-ci.org/AFNetworking/AFNetworking" target="_blank"><img src="https://travis-ci.org/AFNetworking/AFNetworking.svg" alt="Build Status"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![Build Status](https:&#x2F;&#x2F;travis-ci.org&#x2F;AFNetworking&#x2F;AFNetworking.svg)](https:&#x2F;&#x2F;travis-ci.org&#x2F;AFNetworking&#x2F;AFNetworking)</span><br></pre></td></tr></table></figure><p>而 <a href="https://github.com/onevcat/Kingfisher" target="_blank">Kingfisher</a>-master 分支的 build 状态为：<a href="https://github.com/onevcat/Kingfisher/actions?query=workflow%3Abuild" target="_blank"><img src="https://github.com/onevcat/kingfisher/workflows/build/badge.svg?branch=master" alt="Build Status"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![Build Status](https:&#x2F;&#x2F;github.com&#x2F;onevcat&#x2F;kingfisher&#x2F;workflows&#x2F;build&#x2F;badge.svg?branch&#x3D;master)](https:&#x2F;&#x2F;github.com&#x2F;onevcat&#x2F;Kingfisher&#x2F;actions?query&#x3D;workflow%3Abuild)</span><br></pre></td></tr></table></figure><p>要知道项目在其它平台的持续集成状态，具体参照 <a href="https://shields.io/category/build" target="_blank">shields.io - build</a></p><h3 id="许可协议">许可协议<a href="#许可协议" title="许可协议"></a></h3><ul><li><p><strong>Cocoapods：</strong><code>/cocoapods/l/:spec</code></p></li><li><p><strong>GitHub：</strong><code>/github/license/:user/:repo</code></p></li><li><p><strong>NPM：</strong><code>/npm/l/:packageName</code></p></li></ul><p>比如 <a href="https://github.com/onevcat/Kingfisher" target="_blank">Kingfisher</a> 许可协议支持 Cocoapods 和 GitHub 两种写法： <a href="https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE" target="_blank"><img src="https://img.shields.io/cocoapods/l/Kingfisher?style=flat" alt="license"></a> 和 <a href="https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE" target="_blank"><img src="https://img.shields.io/github/license/onevcat/Kingfisher" alt="license"></a></p><p><a href="https://github.com/visionmedia/debug" target="_blank">debug</a> 的许可协议为 <a href="https://github.com/visionmedia/debug/blob/master/LICENSE" target="_blank"><img src="https://img.shields.io/npm/l/debug" alt="license"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Kingfisher Cocoapods License：</span><br><span class="line">[![license](https:&#x2F;&#x2F;img.shields.io&#x2F;cocoapods&#x2F;l&#x2F;Kingfisher?style&#x3D;flat)](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;onevcat&#x2F;Kingfisher&#x2F;master&#x2F;LICENSE)</span><br><span class="line">&#x2F;&#x2F; Kingfisher GitHub License</span><br><span class="line">[![license](https:&#x2F;&#x2F;img.shields.io&#x2F;github&#x2F;license&#x2F;onevcat&#x2F;Kingfisher)](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;onevcat&#x2F;Kingfisher&#x2F;master&#x2F;LICENSE)</span><br><span class="line">&#x2F;&#x2F; debug NPM Licese</span><br><span class="line">[![license](https:&#x2F;&#x2F;img.shields.io&#x2F;npm&#x2F;l&#x2F;debug)](https:&#x2F;&#x2F;github.com&#x2F;visionmedia&#x2F;debug&#x2F;blob&#x2F;master&#x2F;LICENSE)</span><br></pre></td></tr></table></figure><p>要知道项目在其他平台的许可协议，具体参照 <a href="https://shields.io/category/license" target="_blank">shields-license</a>。</p><h3 id="平台amp版本支持">平台&amp;版本支持<a href="#平台amp版本支持" title="平台&amp;版本支持"></a></h3><ul><li><p><strong>Cocoapods Platform</strong>：<code>/cocoapods/p/:repo</code></p></li><li><p><strong>Cocoapods Compatible</strong>：<code>/cocoapods/v/:repo</code></p></li></ul><p>比如 <a href="https://github.com/onevcat/Kingfisher" target="_blank">Kingfisher</a> 当前支持的平台有 <img src="https://img.shields.io/cocoapods/p/Kingfisher" alt="platform">，pod 版本号为 <img src="https://img.shields.io/cocoapods/v/Kingfisher" alt="version"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Platform Support</span><br><span class="line">![platform](https:&#x2F;&#x2F;img.shields.io&#x2F;cocoapods&#x2F;p&#x2F;Kingfisher)</span><br><span class="line">&#x2F;&#x2F; Version Support</span><br><span class="line">![version](https:&#x2F;&#x2F;img.shields.io&#x2F;cocoapods&#x2F;v&#x2F;Kingfisher)</span><br></pre></td></tr></table></figure><p>要知道相关的其它信息，具体参照 <a href="https://shields.io/category/platform-support" target="_blank">shields.io - platform &amp; version support</a></p><h3 id="代码测试覆盖率">代码测试覆盖率<a href="#代码测试覆盖率" title="代码测试覆盖率"></a></h3><p>针对不同的代码测试平台，有不同的获取方法，例如：</p><ul><li><p><strong>Codecov：</strong><code>https://codecov.io/github/:user/:repo/coverage.svg?token=${token}</code></p></li><li><p><strong>Codecov Branch：</strong> <code>https://codecov.io/github/:user/:repo/coverage.svg?branch=${branch}&amp;token=${token}</code></p></li></ul><p>以 <a href="https://github.com/AFNetworking/AFNetworking/master" target="_blank">AFNetworking</a>-master 分支为例：<a href="https://codecov.io/github/AFNetworking/AFNetworking?branch=master" target="_blank"><img src="https://codecov.io/github/AFNetworking/AFNetworking/coverage.svg?branch=master" alt="codecov.io"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![codecov.io](https:&#x2F;&#x2F;codecov.io&#x2F;github&#x2F;AFNetworking&#x2F;AFNetworking&#x2F;coverage.svg?branch&#x3D;master)](https:&#x2F;&#x2F;codecov.io&#x2F;github&#x2F;AFNetworking&#x2F;AFNetworking?branch&#x3D;master)</span><br></pre></td></tr></table></figure><p>要知道项目在其它平台的测试覆盖率，具体参照 <a href="https://shields.io/category/coverage" target="_blank">shields.io - coverage</a>。</p><h3 id="项目信息">项目信息<a href="#项目信息" title="项目信息"></a></h3><ul><li><p><strong>GitHub Followers：</strong><code>/github/followers/:user?label=Follow</code></p></li><li><p><strong>GitHub Forks：</strong><code>/github/forks/:user/:repo?label=Fork</code></p></li><li><p><strong>GitHub Stars：</strong><code>/github/stars/:user/:repo?style=social</code></p></li><li><p><strong>GitHub Watchers：</strong><code>/github/watchers/:user/:repo?label=Watch</code></p></li></ul><p>以我本人的 <a href="https://github.com/fiteen" target="_blank">GitHub</a> 和项目 <a href="https://github.com/fiteen/HTCart" target="_blank">HTCart</a> 为例：</p><p><span><img src="https://img.shields.io/github/followers/fiteen?label=Follow" alt="followers"> <img src="https://img.shields.io/github/forks/fiteen/HTCart?label=Fork" alt="forks"> <img src="https://img.shields.io/github/stars/fiteen/HTCart?style=social" alt="stars"> <img src="https://img.shields.io/github/watchers/fiteen/HTCart.svg?label=Watchers" alt="watchers"></span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Followers</span><br><span class="line">![followers](https:&#x2F;&#x2F;img.shields.io&#x2F;github&#x2F;followers&#x2F;fiteen?label&#x3D;Follow)</span><br><span class="line">&#x2F;&#x2F; Forks</span><br><span class="line">![forks](https:&#x2F;&#x2F;img.shields.io&#x2F;github&#x2F;forks&#x2F;fiteen&#x2F;HTCart?label&#x3D;Fork)</span><br><span class="line">&#x2F;&#x2F; Stars</span><br><span class="line">![stars](https:&#x2F;&#x2F;img.shields.io&#x2F;github&#x2F;stars&#x2F;fiteen&#x2F;HTCart?style&#x3D;social)</span><br><span class="line">&#x2F;&#x2F; Watchers</span><br><span class="line">![watchers](https:&#x2F;&#x2F;img.shields.io&#x2F;github&#x2F;watchers&#x2F;fiteen&#x2F;HTCart.svg?label&#x3D;Watchers)</span><br></pre></td></tr></table></figure><h3 id="下载量">下载量<a href="#下载量" title="下载量"></a></h3><ul><li><p><strong>GitHub All Releases：</strong><code>/github/downloads/:user/:repo/total</code></p></li><li><p><strong>GitHub Releases：</strong><code>/github/downloads/:user/:repo/:tag/total</code></p></li></ul><p>以 <a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank">ShadowsocksX-NG</a> 为例：</p><p><span><img src="https://img.shields.io/github/downloads/shadowsocks/ShadowsocksX-NG/total" alt="GitHub All Releases"> <img src="https://img.shields.io/github/downloads/shadowsocks/ShadowsocksX-NG/v1.7.1/total" alt="GitHub Releases"></span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 总下载量</span><br><span class="line">![GitHub All Releases](https:&#x2F;&#x2F;img.shields.io&#x2F;github&#x2F;downloads&#x2F;shadowsocks&#x2F;ShadowsocksX-NG&#x2F;total)</span><br><span class="line">&#x2F;&#x2F; v1.7.1 的下载量</span><br><span class="line">![GitHub Releases](https:&#x2F;&#x2F;img.shields.io&#x2F;github&#x2F;downloads&#x2F;shadowsocks&#x2F;ShadowsocksX-NG&#x2F;v1.7.1&#x2F;total)</span><br></pre></td></tr></table></figure><h3 id="其他">其他<a href="#其他" title="其他"></a></h3><p>当然，可支持动态的徽标还有很多，本文就不一一列举，有兴趣的可以直接在<a href="https://shields.io" target="_blank">官网</a>查询。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常逛 GitHub 的同学会发现，很多优秀的开源框架里都会出现这样的小徽标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序员必备" scheme="https://blog.fiteen.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87/"/>
    
    
      <category term="GitHub" scheme="https://blog.fiteen.top/tags/GitHub/"/>
    
      <category term="shield.io" scheme="https://blog.fiteen.top/tags/shield-io/"/>
    
  </entry>
  
  <entry>
    <title>还没抢到 HPV？试试这串 JS</title>
    <link href="https://blog.fiteen.top/2019/oh-hpv/"/>
    <id>https://blog.fiteen.top/2019/oh-hpv/</id>
    <published>2019-11-20T23:42:11.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>年初时候了解到了 HPV，几个月里，经历了若干次失败的尝试，功夫不负有心人，今天终于如愿抢到了疫苗。我决定将我期间的经历和尝试记录下来，如果你也有需要，不妨看一看。</p><a id="more"></a><h2 id="什么是-hpv">什么是 HPV<a href="#什么是-hpv" title="什么是 HPV"></a></h2><p>HPV 英文名称 Human papillomavirus，西医学名“人乳头瘤病毒”，是一个拥有一百多种型号的家族。在女性恶性肿瘤中，宫颈癌的发病率仅次于乳腺癌，超过90%的宫颈癌病例都与 HPV 感染有关。HPV 有三种类型：二价、四价、九价，下面是简单的对比表：</p><div class="φcz"><div class="φdb"><table><thead><tr><th align="center">疫苗种类</th><th align="center">二价</th><th align="center">四价</th><th align="center">九价</th></tr></thead><tbody><tr><td align="center">有效预防的 HPV 型号</td><td align="center">6，18</td><td align="center">6，11，16，18</td><td align="center">6，11，16，18，31，33，45，52，58</td></tr><tr><td align="center">国内规定的接种年龄</td><td align="center">9-45周岁</td><td align="center">20-45周岁</td><td align="center">16-26周岁</td></tr><tr><td align="center">接种时间</td><td align="center">0，1，6个月</td><td align="center">0，2，6个月</td><td align="center">0，2，6个月</td></tr><tr><td align="center">参考价格（3针）</td><td align="center">1740元</td><td align="center">2394元</td><td align="center">3894元</td></tr><tr><td align="center">主要功能</td><td align="center">预防84.5%的宫颈癌</td><td align="center">预防84.5%的宫颈癌金和90%的生殖器疣</td><td align="center">预防92.1%的宫颈癌和90%的生殖器疣</td></tr></tbody></table></div></div><h2 id="杭州及周边疫苗预约信息">杭州及周边疫苗预约信息<a href="#杭州及周边疫苗预约信息" title="杭州及周边疫苗预约信息"></a></h2><p>从2019年2月27日至今，我吐血整理了微信公众号“杭州本地宝”中发布过的四价和九价的疫苗预约点，若几次开放的数据不一致，以最近的为准，具体信息如下：</p><div class="φcz"><div class="φdb"><table><thead><tr><th align="center">预约点</th><th align="center">HPV 类型（价）</th><th align="center">预约方式</th><th align="center">预约条件</th><th align="center">开放人数/次</th></tr></thead><tbody><tr><td align="center">杭州东新</td><td align="center">四/九</td><td align="center">问卷星</td><td align="center">不限户籍</td><td align="center">100</td></tr><tr><td align="center">杭州湖滨</td><td align="center">九</td><td align="center">问卷星</td><td align="center">不限户籍</td><td align="center">100</td></tr><tr><td align="center">杭州凯旋</td><td align="center">九</td><td align="center">支付宝</td><td align="center">不限户籍</td><td align="center">230/350</td></tr><tr><td align="center">杭州凯旋</td><td align="center">四</td><td align="center">现场</td><td align="center">不限户籍</td><td align="center">100</td></tr><tr><td align="center">杭州朝晖</td><td align="center">四</td><td align="center">电话/问卷星</td><td align="center">不限户籍</td><td align="center">50～60</td></tr><tr><td align="center">杭州西溪</td><td align="center">四</td><td align="center">问卷星</td><td align="center">不限户籍</td><td align="center">不明</td></tr><tr><td align="center">杭州米市巷</td><td align="center">四</td><td align="center">问卷星</td><td align="center">不限户籍</td><td align="center">40</td></tr><tr><td align="center">杭州灵隐</td><td align="center">九</td><td align="center">问卷星</td><td align="center">不限户籍</td><td align="center">100～300</td></tr><tr><td align="center">杭州清波</td><td align="center">九</td><td align="center">问卷星</td><td align="center">不限户籍</td><td align="center">100</td></tr><tr><td align="center">杭州半山</td><td align="center">九</td><td align="center">问卷星</td><td align="center">不限户籍</td><td align="center">20</td></tr><tr><td align="center">杭州钱塘新区</td><td align="center">九</td><td align="center">网络登记</td><td align="center">不限户籍</td><td align="center">120</td></tr><tr><td align="center">杭州余杭</td><td align="center">九</td><td align="center">问卷星</td><td align="center">余杭户籍/参保人员/辖区内学生/持居住证</td><td align="center">2000</td></tr><tr><td align="center">杭州萧山</td><td align="center">九</td><td align="center">摇号</td><td align="center">萧山户籍/参保地在萧山</td><td align="center">100+</td></tr><tr><td align="center">杭州滨江</td><td align="center">九</td><td align="center">摇号</td><td align="center">滨江户籍/参保地在滨江</td><td align="center">200</td></tr><tr><td align="center">杭州大江东</td><td align="center">九</td><td align="center">摇号</td><td align="center">大江东范围户籍/住大江东范围满3个月</td><td align="center">100+</td></tr><tr><td align="center">杭州建德新安江</td><td align="center">九</td><td align="center">现场</td><td align="center">建德户籍/住建德满3个月</td><td align="center">100</td></tr><tr><td align="center">杭州富阳</td><td align="center">九</td><td align="center">网络预约</td><td align="center">富阳户籍/住富阳满3个月</td><td align="center">120</td></tr><tr><td align="center">绍兴新昌</td><td align="center">九</td><td align="center">官方微信</td><td align="center">新昌户籍/住新昌满3个月</td><td align="center">200</td></tr><tr><td align="center">绍兴上虞</td><td align="center">九</td><td align="center">现场</td><td align="center">上虞户籍/住上虞满3个月</td><td align="center">不明</td></tr><tr><td align="center">绍兴诸暨</td><td align="center">九</td><td align="center">电话</td><td align="center">不限户籍</td><td align="center">不明</td></tr><tr><td align="center">绍兴越城</td><td align="center">九</td><td align="center">现场</td><td align="center">不限户籍</td><td align="center">150～200</td></tr><tr><td align="center">绍兴柯桥/市区</td><td align="center">九</td><td align="center">官方微信</td><td align="center">不限户籍，但需先到医院门诊激活就诊卡</td><td align="center">10～100</td></tr><tr><td align="center">金华</td><td align="center">四/九</td><td align="center">微信小程序</td><td align="center">金华市各区户籍或持金华市社会保障市民卡</td><td align="center">90～225</td></tr><tr><td align="center">舟山</td><td align="center">九</td><td align="center">电话、现场</td><td align="center">不限户籍、本辖区优先</td><td align="center">不明</td></tr><tr><td align="center">衢州</td><td align="center">九</td><td align="center">现场</td><td align="center">不限户籍</td><td align="center">800</td></tr><tr><td align="center">嘉兴</td><td align="center">九</td><td align="center">电话</td><td align="center">户籍地或居住地在南湖（经开）区范围内</td><td align="center">200</td></tr><tr><td align="center">海宁</td><td align="center">九</td><td align="center">网址</td><td align="center">海宁户籍</td><td align="center">150</td></tr><tr><td align="center">临海</td><td align="center">九</td><td align="center">网络预约</td><td align="center">不限户籍</td><td align="center">30</td></tr><tr><td align="center">台州</td><td align="center">九</td><td align="center">问卷星</td><td align="center">不限户籍</td><td align="center">41</td></tr><tr><td align="center">宁波海曙</td><td align="center">九</td><td align="center">现场</td><td align="center">不限户籍</td><td align="center">不明</td></tr><tr><td align="center">宁波各区</td><td align="center">九</td><td align="center">金苗宝 App</td><td align="center">不限户籍</td><td align="center">不明</td></tr><tr><td align="center">…</td><td align="center">四/九</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr></tbody></table></div></div><p>这里我要先吐槽一下几个小坑的预约经历：</p><ol><li><strong>金苗宝 App</strong>，它的使用率在宁波各大医院和社区服务中心的使用率还是蛮高的，尤其是 HPV 疫苗和流感疫苗基本上都是通过这个 App 预约，但是我试过两次，都是接近预约时间，预约功能就处于瘫痪状态，估计服务器内存不够，大量请求同时访问，高并发导致服务器处于超负荷状态（我猜的）。</li><li><strong>杭州钱塘新区7个公众号的疫苗预约</strong>，这次预约消息是很早就放出来的，总结了前几次憨憨的失败经验，我决定借助一点技术手段，这次很容易就从页面中抓出了7个POST请求的 Request URL 和 body，查阅网上资料现学写了一个 sh 脚本，摩拳擦掌跃跃欲试，只待良辰一到，可是现实再一次打击了我，居然还是没有抢到？！！后面再 Review 了一下我的脚本，发现应该把七个请求做定时任务，进行异步执行。</li></ol><p>现在言归正传，杭州周边地区的预约地点对户籍和居住条件有限制，且多为现场或电话预约。<strong>近来疫苗供应有多起来的趋势</strong>，如果不是想打九价的女生即将超过26周岁或者有其它急迫的理由，不太建议大家离开自己的所在地区打疫苗，一来是无法刷医保，二来来回交通和时间成本也比较高。因此我建议：</p><p><strong>浙江省内（非杭州）户籍的女生</strong>：关注自己户籍所在地的疾控中心微信公众号，如富阳疾控、嘉兴疾控等，及时跟进公众号发布的信息。</p><p><strong>萧山、余杭、大江东、滨江户籍或参保地在这四地的女生</strong>：不要错过摇号的时间，毕竟其他区的女生都得不到这个机会。</p><p><strong>其他女生</strong>：能尝试的都可以试一下，尤其是江干凯旋中心的支付宝预约和杭州主城区各街道提供的的问卷星预约。输入问卷时，可以事先在输入法里设置快捷键，输入简单的字符串就能弹出个人信息，这样速度又快，也不担心填错。如果还是不行，下面介绍的小技巧，也许对你有帮助。</p><h3 id="支付宝抢疫苗攻略">支付宝抢疫苗攻略<a href="#支付宝抢疫苗攻略" title="支付宝抢疫苗攻略"></a></h3><p>支付宝预约页面和微信不一样，他允许提早填好信息，非本人也可以帮忙预约，且页面上有倒计时，你只需要掐好提交按钮 enable 的时间，就看谁手速更快，网速更好了。</p><p>根据成功人士的建议：一定要提早十多分钟进页面填好信息，<strong>千万不要中途退出</strong>！！！亲测在有次手贱退出去了，然后就一直在页面上欣赏蚂蚁了（手动微笑）。</p><h2 id="问卷星抢疫苗攻略">问卷星抢疫苗攻略<a href="#问卷星抢疫苗攻略" title="问卷星抢疫苗攻略"></a></h2><p>问卷星是我成功抢到疫苗的渠道，之前几个预约点在微信公众号里提供的问卷星链接是可以在电脑网页里打开的，当时我查看了一下它的前端代码，大概是这样：</p><p><img src="/2019/oh-hpv/hpv-html.png" class="φcy" alt="问卷 html 代码"></p><p>这令我们发现问卷星的几个输入框其实是有明显规律的，输入的值会成为 id 分别为 q1、q2、q3、q4 的元素的value，哪怕问卷中的问题顺序发生了调整，我们也只需要通过模糊匹配，找到对应的 div id 和 input id 即可。</p><p>基本上预约信息上需要填写的不外乎<strong>姓名、联系方式、身份证、年龄</strong>等，这样你就可以引用下面这串 JS。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">javascript: <span class="keyword">void</span>((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="string">"div1"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            location.reload()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hash = [[<span class="string">"这里换成你的真实姓名"</span>, /(姓名)|(名字)/], [<span class="string">"这里换成你的手机号"</span>, /(手机)|(联系方式)/], [<span class="string">"这里换成你的年龄（周岁）"</span>, /(年龄)/], [<span class="string">"这里换成你的身份证"</span>, /(身份证)|(证件)/], ];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>;; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="string">"div"</span> + i) == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!$(<span class="string">"q"</span> + i)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> title = $(<span class="string">"div"</span> + i).innerHTML;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; hash.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[j][<span class="number">1</span>].test(title)) &#123;</span><br><span class="line">                $(<span class="string">"q"</span> + i).value = hash[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开浏览器的开发者模式，在控制台中粘贴这串 JS，回车，网页上就会自动注入信息。</p><p><img src="/2019/oh-hpv/inject-js.png" class="φcy"></p><p>10月30日这一天，因为写好了这个“外挂”，我对抢疫苗非常信心满满，不料这次他们设置了“只允许从微信中填写” 和“获取微信用户昵称、性别等（需登录）”，可见问卷设计者也在和我们在斗智斗勇啊🤦‍♀️。</p><p><img src="/2019/oh-hpv/you-should-login-wechat.png" class="φcy"></p><p>第一个解决起来也很简单，只需要用微信开发者工具打开网址即可。但是第二种我暂时没有找到解决方案，因为按照<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Web_Developer_Tools.html" target="_blank">微信官方文档</a>中所说，<strong>微信开发者工具只能调试自己账号绑定过的公众平台</strong>，不过好在这次下城区东新街道社区卫生服务中心没有强制要求微信登录。</p><p>最后，再感叹一下技术改变生活，nice～</p><hr><blockquote><p>（2020年2月2日更新）前几天有网友给我提了一个 issue，我又重新去研究了一下微信 OAuth2 授权和自动化脚本的问题，相关结论也在 <a href="https://github.com/fiteen/fiteen.github.io/issues/1" target="_blank">issue</a> 中回复，有兴趣可以在下面交流。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年初时候了解到了 HPV，几个月里，经历了若干次失败的尝试，功夫不负有心人，今天终于如愿抢到了疫苗。我决定将我期间的经历和尝试记录下来，如果你也有需要，不妨看一看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.fiteen.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HPV" scheme="https://blog.fiteen.top/tags/HPV/"/>
    
  </entry>
  
  <entry>
    <title>V2Ray + CDN 中转隐藏 IP</title>
    <link href="https://blog.fiteen.top/2019/hide-ip/"/>
    <id>https://blog.fiteen.top/2019/hide-ip/</id>
    <published>2019-09-07T02:43:01.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⚠️⚠️⚠️ <strong>声明：本文内容仅限技术交流，若有用作商业或其他违规行为，与本人无关。</strong></p></blockquote><a id="more"></a><p>IP 又双叒叕被墙了？</p><p>刚换的 IP 还没捂热又凉了，怎么办？</p><p>下面教你一招，为你的 IP 加上双重保护锁，从此躲开“中奖”，快乐省钱又省心！</p><h2 id="原理">原理<a href="#原理" title="原理"></a></h2><p>先在 VPS 服务器上用 V2Ray 伪装成一个网站，再用 CDN 中转。这时流量传递的顺序是这样的：</p><p><img src="/2019/hide-ip/visitor-firewall-cdn-vps-website.png" class="φcy" alt="CDN 中转"></p><p>主要实现就是两点：<br>一、借助 V2Ray 代理，将我们的流量被伪装成网站流量<br>二、利用 CDN 中转 V2Ray 的 WebSocket 流量</p><p>这样，GFW 只知道你与 CDN 之间的联系，不知道 VPS 的实际地址，并且 CDN 会有很多 IP 地址，GFW 也不会随意封这些 IP，毕竟也有很多正规网站在使用，因此可以基本保证 IP 的安全。</p><h2 id="准备工作">准备工作<a href="#准备工作" title="准备工作"></a></h2><p>于是，只要有了 VPS、域名和 CDN，就能实现这套方案：</p><ul><li>VPS：推荐 <a href="https://bandwagonhost.com/" target="_blank">BandwagonHost</a>、<a href="https://www.vultr.com" target="_blank">Vultr</a>、<a href="https://www.hostwinds.com" target="_blank">Hostwinds</a>、<a href="https://manage.hostdare.com/index.php" target="_blank">HostDare</a>、<a href="teach-you-to-build-a-free-Shadowsocks-service">谷歌免费薅一年</a>。</li><li>域名：通过阿里云/腾讯云/华为云等购买域名，<code>.xyz</code>、<code>.top</code> 都是性价比比较高的选择。如果不想花钱也可以在 <a href="http://www.freenom.com/nl/index.html" target="_blank">freenom</a> 上注册一个免费域名，运气好的话域名免费有效期可以达到12个月。</li><li>CDN：推荐使用美国的 Cloudflare，优点是免费、无需备案。</li></ul><h2 id="v2ray">V2Ray<a href="#v2ray" title="V2Ray"></a></h2><h3 id="什么是-v2ray">什么是 V2Ray<a href="#什么是-v2ray" title="什么是 V2Ray"></a></h3><p>V2Ray 是继 Shadowsocks 之后一款非常好用的代理软件，甚至比 Shadowsocks 更优秀，它拥有更多可选择的协议和传输载体，还有强大的路由功能。</p><p>想要知道它的工作机制、本地策略、如何配置等细节可以查看 <a href="https://www.v2ray.com" target="_blank">V2Ray 官网</a>。</p><h3 id="搭建-v2ray-服务">搭建 V2Ray 服务<a href="#搭建-v2ray-服务" title="搭建 V2Ray 服务"></a></h3><p>V2Ray 的配置其实是比较繁琐的，可以借助这个<a href="https://github.com/233boy/v2ray/wiki/V2Ray一键安装脚本" target="_blank">一键安装脚本</a>快速配置。</p><h3 id="安装脚本">安装脚本<a href="#安装脚本" title="安装脚本"></a></h3><p>通过 SSH 连接到 VPS 主机，以 root 用户输入以下命令来安装或卸载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -s -L https:&#x2F;&#x2F;git.io&#x2F;v2ray.sh)</span><br></pre></td></tr></table></figure><h3 id="管理-v2ray">管理 V2Ray<a href="#管理-v2ray" title="管理 V2Ray"></a></h3><p>安装完成后，直接在终端输入 <code>v2ray</code> 就可以进行管理。面板上会出现如下选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1. 查看 V2Ray 配置</span><br><span class="line"> 2. 修改 V2Ray 配置</span><br><span class="line"> 3. 下载 V2Ray 配置 &#x2F; 生成配置信息链接 &#x2F; 生成二维码链接</span><br><span class="line"> 4. 查看 Shadowsocks 配置 &#x2F; 生成二维码链接</span><br><span class="line"> 5. 修改 Shadowsocks 配置</span><br><span class="line"> 6. 查看 MTProto 配置 &#x2F; 修改 MTProto 配置</span><br><span class="line"> 7. 查看 Socks5 配置 &#x2F; 修改 Socks5 配置</span><br><span class="line"> 8. 启动 &#x2F; 停止 &#x2F; 重启 &#x2F; 查看日志</span><br><span class="line"> 9. 更新 V2Ray &#x2F; 更新 V2Ray 管理脚本</span><br><span class="line">10. 卸载 V2Ray</span><br><span class="line">11. 其他</span><br></pre></td></tr></table></figure><p>输入 <code>2</code> 进入修改 V2Ray面板，面板上会出现如下选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 修改 V2Ray 端口</span><br><span class="line">2. 修改 V2Ray 传输协议</span><br><span class="line">3. 修改 V2Ray 动态端口 (如果可以)</span><br><span class="line">4. 修改 用户ID ( UUID )</span><br><span class="line">5. 修改 TLS 域名 (如果可以)</span><br><span class="line">6. 修改 分流的路径 (如果可以)</span><br><span class="line">7. 修改 伪装的网址 (如果可以)</span><br><span class="line">8. 关闭 网站伪装 和 路径分流 (如果可以)</span><br><span class="line">9. 开启 &#x2F; 关闭 广告拦截</span><br></pre></td></tr></table></figure><p>输入 <code>2</code> 修改 V2Ray 传输协议，终端会输出当前的传输协议，如果不是 <code>WebSocket + TLS</code>，继续在终端输入 <code>4</code> 改成这个协议。如图下所示，依次点击回车键、输入正确的域名、将域名解析到指定的 IPv4 地址。</p><p><img src="/2019/hide-ip/domain-name-resolution.png" class="φcy" alt="输入域名并解析到指定地址"></p><p>关于域名解析，以阿里云为例，像这样添加一条 A 记录类型即可。</p><p><img src="/2019/hide-ip/aliyun-resolution.png" class="φcy" alt="阿里云域名解析"></p><p>接下来，你还会被询问是否要<strong>设置分流路径</strong>和<strong>伪装的网址</strong>，如果没有特殊要求，回复默认项即可。</p><p>修改配置完成后，终端会输出新的配置信息，形如：</p><p><img src="/2019/hide-ip/v2ray-config.png" class="φcy" alt="V2Ray 配置信息"></p><p>你也可以通过以下命令进行<strong>快速管理</strong>：</p><ul><li><code>v2ray info</code> 查看 V2Ray 配置信息</li><li><code>v2ray config</code> 修改 V2Ray 配置</li><li><code>v2ray link</code> 生成 V2Ray 配置文件链接</li><li><code>v2ray infolink</code> 生成 V2Ray 配置信息链接</li><li><code>v2ray qr</code> 生成 V2Ray 配置二维码链接</li><li><code>v2ray ss</code> 修改 Shadowsocks 配置</li><li><code>v2ray ssinfo</code> 查看 Shadowsocks 配置信息</li><li><code>v2ray ssqr</code> 生成 Shadowsocks 配置二维码链接</li><li><code>v2ray status</code> 查看 V2Ray 运行状态</li><li><code>v2ray start</code> 启动 V2Ray</li><li><code>v2ray stop</code> 停止 V2Ray</li><li><code>v2ray restart</code> 重启 V2Ray</li><li><code>v2ray log</code> 查看 V2Ray 运行日志</li><li><code>v2ray update</code> 更新 V2Ray</li><li><code>v2ray update.sh</code> 更新 V2Ray 管理脚本</li><li><code>v2ray uninstall</code> 卸载 V2Ray</li></ul><p>配置完成后，我们将信息设置到支持 V2Ray 的客户端，比如集成了 <a href="https://github.com/shadowsocks/v2ray-plugin" target="_blank">v2ray-plugin</a> 的 <a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank">ShadowsocksX-NG</a>、<a href="https://github.com/yanue/V2rayU" target="_blank">V2rayU</a>、<a href="https://github.com/Cenmrev/V2RayX" target="_blank">V2RayX</a> 等。</p><p>这时候挂上代理访问，我们流量被伪装成网站流量，当别人访问你的域名时，打开的将是你设置的伪装网址，终于你的 IP 就不会直接暴露。</p><p>不过我们 <code>ping</code> 一下域名，就会发现，显示的还是原始 IP。那么下面要做的，就是利用 CDN 中转 V2Ray 的 WebSocket 流量。</p><h2 id="cdn-中转">CDN 中转<a href="#cdn-中转" title="CDN 中转"></a></h2><p>这里用到的就是 Cloudflare 的<strong>免费</strong>的<strong>自带防御功能</strong>的 CDN 服务。</p><h3 id="注册-cloudflare-账号">注册 Cloudflare 账号<a href="#注册-cloudflare-账号" title="注册 Cloudflare 账号"></a></h3><p>前往<a href="https://www.cloudflare.com/" target="_blank">官网</a>注册一个账号，流程很简单，只需验证一下有效邮箱。</p><h3 id="使用-cloudflare-管理域名">使用 Cloudflare 管理域名<a href="#使用-cloudflare-管理域名" title="使用 Cloudflare 管理域名"></a></h3><p>登录后账户就会引导你添加托管域名。</p><p><img src="/2019/hide-ip/add-site.png" class="φcy" alt="添加域名"></p><p>注意这里必须使用<strong>根域名</strong>，并确保该域名不在于 Cloudflare 官方以及百度云加速以及其他合作商的系统中。</p><h3 id="选择-free-套餐">选择 Free 套餐<a href="#选择-free-套餐" title="选择 Free 套餐"></a></h3><p>添加好网站后，选择套餐，这里点击第一个 Free 方案即可。</p><p><img src="/2019/hide-ip/select-a-plan.png" class="φcy" alt="选择套餐"></p><h3 id="补全域名的解析纪录">补全域名的解析纪录<a href="#补全域名的解析纪录" title="补全域名的解析纪录"></a></h3><p>Cloudflare 会自动搜索域名的解析记录，如果有我们需要的 DNS 记录但是没有解析出来的，可以手动添加。</p><p>找到伪装域名的解析记录，修改它 DNS 解析记录的代理状态为 Proxied，也就是橘色云朵。</p><p><img src="/2019/hide-ip/revise-dns-record.png" class="φcy" alt="修改 DNS 记录"></p><p>关于 <strong>Proxy state</strong>：</p><ul><li>Proxied：解析DNS，同时该记录要经过代理</li><li>DNS only：只解析DNS，不代理</li></ul><p>设置完成后，然后点击 Continue。</p><h3 id="替换-dns-服务器">替换 DNS 服务器<a href="#替换-dns-服务器" title="替换 DNS 服务器"></a></h3><p><img src="/2019/hide-ip/replace-nameservers.png" class="φcy" alt="替换 DNS"></p><p>我们看到 Cloudflare 提示我们将原来的两台 DNS 服务器换成新分配的服务器。前往自己的域名服务商修改 DNS 之后，等待生效，我10分钟左右就收到了 “Status Active” 的通知邮件，等待时间正常来说不超过 24h。</p><h2 id="效果">效果<a href="#效果" title="效果"></a></h2><p>在<a href="https://tool.lu/ip/" target="_blank">IP 地址查询网</a> 上输入域名，看到解析出的 IP 归属地为 CloudFlare 公司CDN 节点。</p><p><img src="/2019/hide-ip/ip-query.png" class="φcy" alt="域名 IP 查询"></p><p>如此，原始 IP 就被隐藏了。</p><p>同样地，如果 IP 已经被墙，也可以通过这套方案拯救。因为域名托管在 CDN 上，只要 CDN 没有被封，它就可以帮助我们代理访问到 VPS，然后借助 VPS 上的代理科学上网。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;⚠️⚠️⚠️ &lt;strong&gt;声明：本文内容仅限技术交流，若有用作商业或其他违规行为，与本人无关。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="科学上网" scheme="https://blog.fiteen.top/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="V2Ray" scheme="https://blog.fiteen.top/tags/V2Ray/"/>
    
      <category term="Cloudflare" scheme="https://blog.fiteen.top/tags/Cloudflare/"/>
    
      <category term="CDN" scheme="https://blog.fiteen.top/tags/CDN/"/>
    
      <category term="DNS" scheme="https://blog.fiteen.top/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>App 多渠道打包及重签名方案</title>
    <link href="https://blog.fiteen.top/2019/solution-of-app-muti-channel-pack/"/>
    <id>https://blog.fiteen.top/2019/solution-of-app-muti-channel-pack/</id>
    <published>2019-08-10T09:41:39.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，渠道包是国内 Android 应用市场中常用的分发方式。渠道包中会包含不同的渠道信息，方便我们后续统计 App 在各分发渠道的下载量、用户量、留存率等，有针对地调整应用内容或是推广方案等。随着国内 iOS 应用上架越来越难，衍生出了很多企业包，为了方便采集数据，也会用多渠道的方案。</p><a id="more"></a><p>另外，项目进展过程中，可能会出现一些临时新增渠道的需求，这时回到工程中重新打包是比较费时的，有没有办法加快打包速度呢？下文中分享了一些方案。</p><h2 id="ios-多渠道打包方案">iOS 多渠道打包方案<a href="#ios-多渠道打包方案" title="iOS 多渠道打包方案"></a></h2><p>iOS 打渠道包目前想到的就只有两种方式，一种是通过<a href="#muti-target-way">多 target 方式</a>，另一种是<a href="#revise-plist-way">修改 plist 文件方式</a>。</p><h3 id="多-target-方式"><span id="muti-target-way">多 target 方式</span><a href="#多-target-方式" title="多 target 方式"></a></h3><p>点击项目中的 target，右键选择 <code>Duplicate</code>。可以修改下图标红框的三处：target 名称、plist 名称和 scheme 名称。</p><p><img src="/2019/solution-of-app-muti-channel-pack/target-copy.png" class="φcy"></p><p>判断当前是哪个 target，可以通过添加宏定义实现，方式就是在 <code>Build Settings</code> 找到 <code>Preprocessor Macros</code>，填入宏定义名。</p><p>代码中这样判断：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TARGET1MACROS</span></span><br><span class="line">    <span class="comment">// target1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined TARGET2MACROS</span></span><br><span class="line">    <span class="comment">// target2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>具体打包脚本就不介绍了，读者可以自行网上搜索，这种方式的缺点是一个渠道打一次，效率较低。下面着重分享修改 plist 的批量打包方式。</p><h3 id="修改-plist-方式"><span id="revise-plist-way">修改 plist 方式</span><a href="#修改-plist-方式" title="修改 plist 方式"></a></h3><p>下面用一个简单的 Demo 演示一下：</p><p><strong>第一步</strong>：创建工程名为 MultiChannelDemo 的项目，并在项目中新建一个 <code>Channel.plist</code> 文件，plist 中设置 Channel 字段，值为 channel01。然后在页面上设置一个 label 标签用于显示当前的渠道名称，渠道名可以通过下面的代码获取到：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *channelDic = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"Channel"</span> ofType:<span class="string">@"plist"</span>]];</span><br><span class="line"><span class="built_in">NSString</span> *channel = channelDic[<span class="string">@"Channel"</span>];</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：把这个项目用可用的证书正常打一个母包，解压这个 ipa 包可以获得一个名为 <code>Payload</code> 的文件夹，里面是一个 .app 文件，右键显示其包内容，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── Base.lproj</span><br><span class="line">├── Channel.plist</span><br><span class="line">├── Info.plist</span><br><span class="line">├── MultiChannelDemo</span><br><span class="line">├── PkgInfo</span><br><span class="line">├── _CodeSignature</span><br><span class="line">└── embedded.mobileprovision</span><br></pre></td></tr></table></figure><p>可以看到，里面的 <code>Channel.plist</code> 也就是在前面工程中新建的存储渠道信息的 plist，我们会修改里面的 Channel 再生成新的渠道包。</p><p><strong>第三步</strong>：提取描述文件用于重签名，上一步中 Payload 的文件夹里有一个 <code>embedded.mobileprovision</code> 文件，这就是我们需要的文件。</p><p><strong>第四步</strong>：新建一个纯文本，里面输入你要新增的渠道号，如：</p><p><img src="/2019/solution-of-app-muti-channel-pack/channel-list-txt.png" class="φcy"></p><p><strong>第五步</strong>：写一个脚本文件，内容如下：</p><figure class="highlight plain"><figcaption><span>ChannelPackage.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 输入的包名</span><br><span class="line"></span><br><span class="line">name&#x3D;&quot;MultiChannelDemo&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;------SDK渠道包----------&quot;</span><br><span class="line"></span><br><span class="line">appName&#x3D;&quot;$&#123;name&#125;.app&quot;</span><br><span class="line"></span><br><span class="line">plistBuddy&#x3D;&quot;&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy&quot;</span><br><span class="line"></span><br><span class="line">configName&#x3D;&quot;Payload&#x2F;$&#123;appName&#125;&#x2F;Channel.plist&quot;</span><br><span class="line"></span><br><span class="line">ipa&#x3D;&quot;$&#123;name&#125;.ipa&quot;</span><br><span class="line"></span><br><span class="line"># 输出的新包所在的文件夹名</span><br><span class="line"></span><br><span class="line">outUpdateAppDir&#x3D;&quot;ChannelPackages&quot;</span><br><span class="line"></span><br><span class="line"># entitlements.plist路径</span><br><span class="line"></span><br><span class="line">entitlementsDir&#x3D;&quot;entitlements.plist&quot;</span><br><span class="line"></span><br><span class="line"># 切换到当前目录</span><br><span class="line"></span><br><span class="line">currDir&#x3D;$&#123;PWD&#125;</span><br><span class="line"></span><br><span class="line">cd $&#123;currDir&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;-----$&#123;currDir&#125;&quot;</span><br><span class="line"></span><br><span class="line">rm -rf Payload</span><br><span class="line"></span><br><span class="line"># 解压缩-o：覆盖文件 -q：不显示解压过程</span><br><span class="line"></span><br><span class="line">unzip -o -q $&#123;ipa&#125;</span><br><span class="line"></span><br><span class="line"># 删除旧的文件夹，重新生成</span><br><span class="line"></span><br><span class="line">rm -rf $&#123;outUpdateAppDir&#125;</span><br><span class="line"></span><br><span class="line">mkdir $&#123;outUpdateAppDir&#125;</span><br><span class="line"></span><br><span class="line"># 删除旧的 entitlements.plist，重新生成</span><br><span class="line"></span><br><span class="line">rm -rf $&#123;entitlementsDir&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -x -c &quot;print :Entitlements &quot; &#x2F;dev&#x2F;stdin &lt;&lt;&lt; $(security cms -D -i Payload&#x2F;$&#123;appName&#125;&#x2F;embedded.mobileprovision) &gt; entitlements.plist</span><br><span class="line"></span><br><span class="line">echo &quot;------------------------开始打包程序------------------------&quot;</span><br><span class="line"></span><br><span class="line"># 渠道列表文件开始打包</span><br><span class="line"></span><br><span class="line">for line in $(cat ChannelList.txt)</span><br><span class="line"></span><br><span class="line"># 循环数组，修改渠道信息</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line"></span><br><span class="line"># 修改 plist 中的 Channel 值</span><br><span class="line"></span><br><span class="line">$plistBuddy -c &quot;Set :Channel $line&quot; $&#123;configName&#125;</span><br><span class="line"></span><br><span class="line"># app 重签名</span><br><span class="line"></span><br><span class="line">rm -rf Payload&#x2F;$&#123;appName&#125;&#x2F;_CodeSignature</span><br><span class="line"></span><br><span class="line">cp embedded.mobileprovision &quot;Payload&#x2F;$&#123;appName&#125;&#x2F;embedded.mobileprovision&quot;</span><br><span class="line"></span><br><span class="line"># 填入可用的证书 ID</span><br><span class="line"></span><br><span class="line">codesign -f -s &quot;iPhone Distribution: XXXXXX.&quot; Payload&#x2F;$&#123;appName&#125;  --entitlements $&#123;entitlementsDir&#125;</span><br><span class="line"></span><br><span class="line"># 若输出 Payload&#x2F;MultiChannelDemo.app: replacing existing signature 说明重签名完成</span><br><span class="line"></span><br><span class="line"># 压缩 -r:递归处理，将指定目录下的所有文件和子目录一并处理 -q:不显示处理过程</span><br><span class="line"></span><br><span class="line">zip -rq &quot;$&#123;outUpdateAppDir&#125;&#x2F;$line.ipa&quot; Payload</span><br><span class="line"></span><br><span class="line">echo &quot;........渠道$&#123;line&#125;打包已完成&quot;</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>脚本里的信息请根据你实际情况修改。到这里准备工作都完成了，需要的文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── ChannelList.txt</span><br><span class="line">├── ChannelPackage.sh</span><br><span class="line">├── MultiChannelDemo.ipa</span><br><span class="line">└── embedded.mobileprovision</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>：在当前目录下执行脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ChannelPackage.sh</span><br></pre></td></tr></table></figure><p>打包完成后生成的 <code>ChannelPackages</code> 文件夹下，就是我们需要的渠道包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── ChannelList.txt</span><br><span class="line">├── ChannelPackage.sh</span><br><span class="line">├── ChannelPackages</span><br><span class="line">│   ├── channel02.ipa</span><br><span class="line">│   ├── channel03.ipa</span><br><span class="line">│   └── channel04.ipa</span><br><span class="line">├── MultiChannelDemo.ipa</span><br><span class="line">├── Payload</span><br><span class="line">│   └── MultiChannelDemo.app</span><br><span class="line">├── embedded.mobileprovision</span><br><span class="line">└── entitlements.plist</span><br></pre></td></tr></table></figure><p>这种自动化打包的方式，可以规避掉 Xcode 本身打包编译的部分时间，快速出包。</p><h2 id="android-多渠道打包方案">Android 多渠道打包方案<a href="#android-多渠道打包方案" title="Android 多渠道打包方案"></a></h2><p>下文介绍的是美团技术团队开源的 <a href="https://github.com/Meituan-Dianping/walle" target="_blank">Walle</a>，它有 <a href="#gradle-way">Gradle 插件</a>和<a href="#command-way">命令行</a>两种使用方式，前者快速集成，后者满足自定义需求。</p><h3 id="gladle-插件方式"><span id="gradle-way">Gladle 插件方式</span><a href="#gladle-插件方式" title="Gladle 插件方式"></a></h3><h4 id="配置-buildgradle">配置 build.gradle<a href="#配置-buildgradle" title="配置 build.gradle"></a></h4><p>在项目根目录下的 <code>build.gradle</code> 文件中添加 Walle 插件依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.meituan.android.walle:plugin:1.1.6'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 app 目录下的 <code>build.gradle</code> 文件中 apply 插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'walle'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'com.meituan.android.walle:library:1.1.6'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置插件">配置插件<a href="#配置插件" title="配置插件"></a></h4><p>在 app 目录下的 <code>build.gradle</code> 文件中进行渠道配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">walle &#123;</span><br><span class="line">    <span class="comment">// 指定渠道包的输出路径</span></span><br><span class="line">    apkOutputFolder = <span class="keyword">new</span> File(<span class="string">"$&#123;project.buildDir&#125;/outputs/channels"</span>);</span><br><span class="line">    <span class="comment">// 定制渠道包的APK的文件名称</span></span><br><span class="line">    apkFileNameFormat = <span class="string">'$&#123;appName&#125;_v$&#123;versionName&#125;_$&#123;channel&#125;.apk'</span>;</span><br><span class="line">    <span class="comment">// 渠道配置文件</span></span><br><span class="line">    channelFile = <span class="keyword">new</span> File(<span class="string">"$&#123;project.getProjectDir()&#125;/channel"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渠道配置文件里的内容格式详见：<a href="https://github.com/Meituan-Dianping/walle/blob/master/app/channel" target="_blank">渠道配置文件示例</a>。</p><h4 id="如何获取渠道信息">如何获取渠道信息<a href="#如何获取渠道信息" title="如何获取渠道信息"></a></h4><p>在需要填写渠道信息的地方引用这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String channel = WalleChannelReader.getChannel(<span class="keyword">this</span>.getApplicationContext());</span><br></pre></td></tr></table></figure><h4 id="如何生成渠道包">如何生成渠道包<a href="#如何生成渠道包" title="如何生成渠道包"></a></h4><p>用 <code>assemble${variantName}Channels</code> 指令，导出 apk 包。</p><h3 id="命令行方式"><span id="command-way">命令行方式</span><a href="#命令行方式" title="命令行方式"></a></h3><p>通过命令行方式，可以不打开 IDE，直接导出新渠道的 apk。步骤如下：</p><p>首先，新建一个文件夹，取用一个上面步骤导出的 apk 包，再下载 <a href="https://github.com/Meituan-Dianping/walle/releases" target="_blank">walle-cli-all.jar</a>，两者都放置在这个文件夹目录下。</p><p>然后，在文件夹目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar walle-cli-all.jar put -c <span class="variable">$&#123;channelName&#125;</span> <span class="variable">$&#123;apkName&#125;</span>.apk</span><br></pre></td></tr></table></figure><p>若上面的命令执行成功，会在当前目录下生成新的渠道包，名称为 <code>${apkName}_${channelName}.apk</code></p><p>如果要批量写入渠道，可以这样，渠道之间用逗号隔开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar walle-cli-all.jar batch -c <span class="variable">$&#123;channelName0&#125;</span>,<span class="variable">$&#123;channelName1&#125;</span>,<span class="variable">$&#123;channelName2&#125;</span> <span class="variable">$&#123;apkName&#125;</span>.apk</span><br></pre></td></tr></table></figure><p>或者指定渠道配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar walle-cli-all.jar batch -c <span class="variable">$&#123;channelFile&#125;</span> <span class="variable">$&#123;apkName&#125;</span>.apk</span><br></pre></td></tr></table></figure><blockquote><p>如果要写入额外信息，参考<a href="https://github.com/Meituan-Dianping/walle/blob/master/walle-cli/README.md" target="_blank">官方文档</a>。</p></blockquote><p>如果要检查/显示渠道，命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar walle-cli-all.jar show <span class="variable">$&#123;apkName&#125;</span>.apk</span><br></pre></td></tr></table></figure><p>Walle 现在既能满足新应用签名方案对安全性的要求，也能满足对渠道包打包时间的要求，有需要的可以尝试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，渠道包是国内 Android 应用市场中常用的分发方式。渠道包中会包含不同的渠道信息，方便我们后续统计 App 在各分发渠道的下载量、用户量、留存率等，有针对地调整应用内容或是推广方案等。随着国内 iOS 应用上架越来越难，衍生出了很多企业包，为了方便采集数据，也会用多渠道的方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://blog.fiteen.top/categories/iOS/"/>
    
      <category term="Android" scheme="https://blog.fiteen.top/categories/Android/"/>
    
    
      <category term="重签名" scheme="https://blog.fiteen.top/tags/%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>【译】Fucking SwiftUI</title>
    <link href="https://blog.fiteen.top/2019/fucking-swift-ui/"/>
    <id>https://blog.fiteen.top/2019/fucking-swift-ui/</id>
    <published>2019-07-18T02:31:57.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://fuckingswiftui.com/" target="_blank">Fucking Swift UI - Cheat Sheet</a><br>译者的话：翻译过程中，发现了原文中的几个错误，我向作者<a href="https://twitter.com/sarunw" target="_blank">@sarunw</a>提出意见后，直接在译文中改掉了，如果您发现文中内容有误，欢迎与我联系。</p></blockquote><a id="more"></a><p>关于 SwiftUI，您在下文中看到的所有答案并不是完整详细的，它只能充当一份备忘单，或是检索表。</p><h2 id="常见问题">常见问题<a href="#常见问题" title="常见问题"></a></h2><p>关于 SwiftUI 的常见问题：</p><p><strong>是否需要学 SwiftUI？</strong></p><p>是</p><p><strong>是否有必要现在就学 SwiftUI？</strong></p><p>看情况，因为 SwiftUI 目前只能在 iOS 13、macOS 10.15、tvOS 13和 watchOS 6 上运行。如果您要开发的新应用计划仅针对前面提到的 OS 系统，我会说是。 但是，如果您打算找工作或是无法确保会在此 OS 版本的客户端项目上工作，则可能要等一两年，再考虑迁移成 SwiftUI，毕竟大多数客户端工作都希望支持尽可能多的用户，这意味着您的应用必须兼容多个 OS 系统。 因此，一年后再去体验优雅的 SwiftUI 也许是最好的时机。</p><p><strong>是否需要学 UIKit/AppKit/WatchKit？</strong></p><p>是的，就长时间来看，UIKit 仍将是 iOS 架构的重要组成部分。现在的 SwiftUI 并不成熟完善，我认为即使您打算用 SwiftUI 来开发，仍然不时需要用到 UIKit。</p><p><strong>SwiftUI 能代替 UIKit/AppKit/WatchKit 吗?</strong></p><p>现在不行，但将来也许会。SwiftUI 虽然是刚刚推出的，它看起来已经很不错。我希望两者能长期共存，SwiftUI 还很年轻，它还需要几年的打磨成长才能去代替 UIKit/AppKit/WatchKit。</p><p><strong>如果我现在只能学习一种，那么应该选择 UIKit/AppKit/WatchKit 还是 SwiftUI？</strong></p><p>UIKit。 您始终可以依赖 UIKit，它用起来一直不错，且未来一段时间仍然可用。如果您直接从 SwiftUI 开始学习，可能会遗漏了解一些功能。</p><p><strong>SwiftUI 的控制器在哪里？</strong></p><p>没有了。 如今页面间直接通过响应式编程框架 Combine 交互。Combine 也作为新的通信方式替代了 UIViewController。</p><h2 id="要求">要求<a href="#要求" title="要求"></a></h2><ul><li>Xcode 11 Beta（<a href="https://developer.apple.com/download/" target="_blank">从 Apple 官网下载</a>）</li><li>iOS 13 / macOS 10.15 / tvOS 13 / watchOS 6</li><li>macOS Catalina，以便在画布上呈现 SwiftUI（<a href="https://developer.apple.com/download/" target="_blank">从 Apple 官网下载</a>）</li></ul><blockquote><p><strong>想要体验 SwiftUI 画布，但不想在您的电脑上安装 macOS Catalina beta 系统</strong><br>您可以与当前的 macOS 版本并行安装 Catalina。这里介绍了<a href="https://support.apple.com/en-us/HT208891" target="_blank">如何在单独的 APFS 卷上安装 macOS</a></p></blockquote><h2 id="swiftui-中等效的-uikit">SwiftUI 中等效的 UIKit<a href="#swiftui-中等效的-uikit" title="SwiftUI 中等效的 UIKit"></a></h2><h3 id="视图控制器">视图控制器<a href="#视图控制器" title="视图控制器"></a></h3><div class="φcz"><div class="φdb"><table><thead><tr><th align="left">UIKit</th><th align="center">SwiftUI</th><th align="center">备注</th></tr></thead><tbody><tr><td align="left">UIViewController</td><td align="center">View</td><td align="center">-</td></tr><tr><td align="left">UITableViewController</td><td align="center"><a href="#list">List</a></td><td align="center">-</td></tr><tr><td align="left">UICollectionViewController</td><td align="center">-</td><td align="center">目前，还没有 SwiftUI 的替代品，但是您可以像<a href="https://developer.apple.com/tutorials/swiftui/composing-complex-interfaces" target="_blank">Composing Complex Interfaces’s tutorial</a>里那样，使用 List 的组成来模拟布局</td></tr><tr><td align="left">UISplitViewController</td><td align="center"><a href="#navigationview">NavigationView</a></td><td align="center">Beta 5中有部分支持，但仍然无法使用。</td></tr><tr><td align="left">UINavigationController</td><td align="center"><a href="#navigationview">NavigationView</a></td><td align="center">-</td></tr><tr><td align="left">UIPageViewController</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">UITabBarController</td><td align="center"><a href="#tabview">TabView</a></td><td align="center">-</td></tr><tr><td align="left">UISearchController</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">UIImagePickerController</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">UIVideoEditorController</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">UIActivityViewController</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">UIAlertController</td><td align="center"><a href="#alert">Alert</a></td><td align="center">-</td></tr></tbody></table></div></div><h3 id="视图和控件">视图和控件<a href="#视图和控件" title="视图和控件"></a></h3><div class="φcz"><div class="φdb"><table><thead><tr><th align="left">UIKit</th><th align="center">SwiftUI</th><th align="center">备注</th></tr></thead><tbody><tr><td align="left">UILabel</td><td align="center"><a href="#text">Text</a></td><td align="center">-</td></tr><tr><td align="left">UITabBar</td><td align="center"><a href="#tabview">TabView</a></td><td align="center">-</td></tr><tr><td align="left">UITabBarItem</td><td align="center"><a href="#tabview">TabView</a></td><td align="center"><a href="#tabview">TabView</a> 里的 <code>.tabItem</code></td></tr><tr><td align="left">UITextField</td><td align="center"><a href="#textfield">TextField</a></td><td align="center">Beta 5中有部分支持，但仍然无法使用。</td></tr><tr><td align="left">UITableView</td><td align="center"><a href="#list">List</a></td><td align="center"><a href="#vstack">VStack</a> 和 <a href="#form">Form</a> 也可以</td></tr><tr><td align="left">UINavigationBar</td><td align="center"><a href="#navigationview">NavigationView</a></td><td align="center"><a href="#navigationview">NavigationView</a> 的一部分</td></tr><tr><td align="left">UIBarButtonItem</td><td align="center"><a href="#navigationview">NavigationView</a></td><td align="center"><a href="#navigationview">NavigationView</a> 里的 <code>.navigationBarItems</code></td></tr><tr><td align="left">UICollectionView</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">UIStackView</td><td align="center"><a href="#hstack">HStack</a></td><td align="center"><code>.axis == .Horizontal</code></td></tr><tr><td align="left">UIStackView</td><td align="center"><a href="#vstack">VStack</a></td><td align="center"><code>.axis == .Vertical</code></td></tr><tr><td align="left">UIScrollView</td><td align="center"><a href="#scrollview">ScrollView</a></td><td align="center">-</td></tr><tr><td align="left">UIActivityIndicatorView</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">UIImageView</td><td align="center"><a href="#image">Image</a></td><td align="center">-</td></tr><tr><td align="left">UIPickerView</td><td align="center"><a href="#picker">Picker</a></td><td align="center">-</td></tr><tr><td align="left">UIButton</td><td align="center"><a href="#button">Button</a></td><td align="center">-</td></tr><tr><td align="left">UIDatePicker</td><td align="center"><a href="#datepicker">DatePicker</a></td><td align="center">-</td></tr><tr><td align="left">UIPageControl</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">UISegmentedControl</td><td align="center"><a href="#picker">Picker</a></td><td align="center"><a href="#picker">Picker</a> 中的一种样式 <code>SegmentedPickerStyle</code></td></tr><tr><td align="left">UISlider</td><td align="center"><a href="#slider">Slider</a></td><td align="center">-</td></tr><tr><td align="left">UIStepper</td><td align="center"><a href="#stepper">Stepper</a></td><td align="center">-</td></tr><tr><td align="left">UISwitch</td><td align="center"><a href="#toggle">Toggle</a></td><td align="center">-</td></tr><tr><td align="left">UIToolBar</td><td align="center">-</td><td align="center">-</td></tr></tbody></table></div></div><h3 id="框架集成---swiftui-中的-uikit">框架集成 - SwiftUI 中的 UIKit<a href="#框架集成---swiftui-中的-uikit" title="框架集成 - SwiftUI 中的 UIKit"></a></h3><p>将 SwiftUI 视图集成到现有应用程序中，并将 UIKit 视图和控制器嵌入 SwiftUI 视图层次结构中。</p><div class="φcz"><div class="φdb"><table><thead><tr><th align="left">UIKit</th><th align="left">SwiftUI</th><th align="center">备注</th></tr></thead><tbody><tr><td align="left">UIView</td><td align="left"><a href="#uiviewrepresentable">UIViewRepresentable</a></td><td align="center">-</td></tr><tr><td align="left">UIViewController</td><td align="left"><a href="#uiviewcontrollerrepresentable">UIViewControllerRepresentable</a></td><td align="center">-</td></tr></tbody></table></div></div><h3 id="框架集成---uikit-中的-swiftui">框架集成 - UIKit 中的 SwiftUI<a href="#框架集成---uikit-中的-swiftui" title="框架集成 - UIKit 中的 SwiftUI"></a></h3><p>将 SwiftUI 视图集成到现有应用程序中，并将 UIKit 视图和控制器嵌入 SwiftUI 视图层次结构中。</p><div class="φcz"><div class="φdb"><table><thead><tr><th align="left">UIKit</th><th align="left">SwiftUI</th><th align="center">备注</th></tr></thead><tbody><tr><td align="left">UIView (<a href="#uihostingcontroller">UIHostingController</a>)</td><td align="left">View</td><td align="center">没有直接转换为 UIView 的方法，但是您可以使用容器视图将 UIViewController 中的视图添加到视图层次结构中</td></tr><tr><td align="left">UIViewController (<a href="#uihostingcontroller">UIHostingController</a>)</td><td align="left">View</td><td align="center">-</td></tr></tbody></table></div></div><h2 id="swiftui---视图和控件">SwiftUI - 视图和控件<a href="#swiftui---视图和控件" title="SwiftUI - 视图和控件"></a></h2><h3 id="text"><span id="text">Text</span><a href="#text" title="Text"></a></h3><p>显示一行或多行只读文本的视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure><p>样式:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  .bold()</span><br><span class="line">  .italic()</span><br><span class="line">  .underline()</span><br><span class="line">  .lineLimit(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><code>Text</code> 中填入的字符串也用作 <code>LocalizedStringKey</code>，因此也会直接获得 <code>NSLocalizedString</code> 的特性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"This text used as localized key"</span>)</span><br></pre></td></tr></table></figure><p>直接在文本视图里格式化文本。 实际上，这不是 SwiftUI 的功能，而是 Swift 5的字符串插入特性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">    formatter.dateStyle = .long</span><br><span class="line">    <span class="keyword">return</span> formatter</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> now = <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"What time is it?: \(now, formatter: Self.dateFormatter)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接用 <code>+</code> 拼接 <code>Text</code> 文本:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello "</span>) + <span class="type">Text</span>(<span class="string">"World!"</span>).bold()</span><br></pre></td></tr></table></figure><p>文字对齐方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello\nWorld!"</span>).multilineTextAlignment(.center)</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/text" target="_blank">文档</a></p><h3 id="textfield"><span id="textfield">TextField</span><a href="#textfield" title="TextField"></a></h3><p>显示可编辑文本界面的控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"John"</span>    </span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">TextField</span>(<span class="string">"Name's placeholder"</span>, text: $name)</span><br><span class="line">        .textFieldStyle(<span class="type">RoundedBorderTextFieldStyle</span>())</span><br><span class="line">        .padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/textfield" target="_blank">文档</a></p><h3 id="securefield"><span id="securefield">SecureField</span><a href="#securefield" title="SecureField"></a></h3><p>用户安全地输入私人文本的控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> password: <span class="type">String</span> = <span class="string">"1234"</span>    </span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">SecureField</span>($password)</span><br><span class="line">        .textFieldStyle(<span class="type">RoundedBorderTextFieldStyle</span>())</span><br><span class="line">        .padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/securefield" target="_blank">文档</a></p><h3 id="image"><span id="image">Image</span><a href="#image" title="Image"></a></h3><p>显示图像的视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">"foo"</span>) <span class="comment">//图像名字为 foo</span></span><br></pre></td></tr></table></figure><p>我们可以使用新的 SF Symbols：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">"clock.fill"</span>)</span><br></pre></td></tr></table></figure><p>您可以通过为系统图标添加样式，来匹配您使用的字体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">"cloud.heavyrain.fill"</span>)</span><br><span class="line">    .foregroundColor(.red)</span><br><span class="line">    .font(.title)</span><br><span class="line"><span class="type">Image</span>(systemName: <span class="string">"clock"</span>)</span><br><span class="line">    .foregroundColor(.red)</span><br><span class="line">    .font(<span class="type">Font</span>.system(.largeTitle).bold())</span><br></pre></td></tr></table></figure><p>为图片增加样式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">"foo"</span>)</span><br><span class="line">    .resizable() <span class="comment">// 调整大小，以便填充所有可用空间</span></span><br><span class="line">    .aspectRatio(contentMode: .fit)</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/image" target="_blank">文档</a></p><h3 id="button"><span id="button">Button</span><a href="#button" title="Button"></a></h3><p>在触发时执行操作的控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(</span><br><span class="line">    action: &#123;</span><br><span class="line">        <span class="comment">// 点击事件</span></span><br><span class="line">    &#125;,</span><br><span class="line">    label: &#123; <span class="type">Text</span>(<span class="string">"Click Me"</span>) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果按钮的标签只有 <code>Text</code>，则可以通过下面这种简单的方式进行初始化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">"Click Me"</span>) &#123;</span><br><span class="line">    <span class="comment">// 点击事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以像这样给按钮添加属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(action: &#123;</span><br><span class="line">                </span><br><span class="line">&#125;, label: &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">"clock"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Click Me"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Subtitle"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.foregroundColor(<span class="type">Color</span>.white)</span><br><span class="line">.padding()</span><br><span class="line">.background(<span class="type">Color</span>.blue)</span><br><span class="line">.cornerRadius(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/button" target="_blank">文档</a></p><h3 id="navigationlink"><span id="navigationlink">NavigationLink</span><a href="#navigationlink" title="NavigationLink"></a></h3><p>按下时会触发导航演示的按钮。它用作代替 <code>pushViewController</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">NavigationLink</span>(destination:</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Detail"</span>)</span><br><span class="line">        .navigationBarTitle(<span class="type">Text</span>(<span class="string">"Detail"</span>))</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Push"</span>)</span><br><span class="line">    &#125;.navigationBarTitle(<span class="type">Text</span>(<span class="string">"Master"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了增强可读性，可以把 <code>destination</code> 包装成自定义视图 <code>DetailView</code> 的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">NavigationLink</span>(destination: <span class="type">DetailView</span>()) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Push"</span>)</span><br><span class="line">    &#125;.navigationBarTitle(<span class="type">Text</span>(<span class="string">"Master"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但不确定是 Bug 还是设计使然，上述代码 在 Beta 5 中的无法正常执行。尝试像这样把 <code>NavigationLink</code> 包装进列表中试一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">   <span class="type">List</span> &#123;</span><br><span class="line">       <span class="type">NavigationLink</span>(destination: <span class="type">Text</span>(<span class="string">"Detail"</span>)) &#123;</span><br><span class="line">           <span class="type">Text</span>(<span class="string">"Push"</span>)</span><br><span class="line">       &#125;.navigationBarTitle(<span class="type">Text</span>(<span class="string">"Master"</span>))</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><p>如果 <code>NavigationLink</code> 的标签只有 <code>Text</code> ，则可以用这样更简单的方式初始化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(<span class="string">"Detail"</span>, destination: <span class="type">Text</span>(<span class="string">"Detail"</span>).navigationBarTitle(<span class="type">Text</span>(<span class="string">"Detail"</span>)))</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/navigationlink" target="_blank">文档</a></p><h3 id="toggle"><span id="toggle">Toggle</span><a href="#toggle" title="Toggle"></a></h3><p>在开/关状态之间切换的控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> isShowing = <span class="literal">true</span> <span class="comment">// toggle 状态值</span></span><br><span class="line"></span><br><span class="line"><span class="type">Toggle</span>(isOn: $isShowing) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>Toggle</code> 的标签只有 <code>Text</code>，则可以用这样更简单的方式初始化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Toggle</span>(<span class="string">"Hello World"</span>, isOn: $isShowing)</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/toggle" target="_blank">文档</a></p><h3 id="picker"><span id="picker">Picker</span><a href="#picker" title="Picker"></a></h3><p>从一组互斥值中进行选择的控件。</p><p>选择器样式根据其被父视图进行更改，在表单或列表下作为一个列表行显示，点击可以推出新界面展示所有的选项卡。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">Form</span> &#123;</span><br><span class="line">        <span class="type">Section</span> &#123;</span><br><span class="line">            <span class="type">Picker</span>(selection: $selection, label:</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Picker Name"</span>)</span><br><span class="line">                , content: &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"Value 1"</span>).tag(<span class="number">0</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"Value 2"</span>).tag(<span class="number">1</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"Value 3"</span>).tag(<span class="number">2</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"Value 4"</span>).tag(<span class="number">3</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用 <code>.pickerStyle(WheelPickerStyle())</code>覆盖样式。</p><p>在 iOS 13 中， <code>UISegmentedControl</code> 也只是 <code>Picker</code> 的一种样式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> mapChoioce = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> settings = [<span class="string">"Map"</span>, <span class="string">"Transit"</span>, <span class="string">"Satellite"</span>]</span><br><span class="line"><span class="type">Picker</span>(<span class="string">"Options"</span>, selection: $mapChoioce) &#123;</span><br><span class="line">    <span class="type">ForEach</span>(<span class="number">0</span> ..&lt; settings.<span class="built_in">count</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(<span class="keyword">self</span>.settings[index])</span><br><span class="line">            .tag(index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;.pickerStyle(<span class="type">SegmentedPickerStyle</span>())</span><br></pre></td></tr></table></figure><blockquote><p>分段控制器在iOS 13中也焕然一新了。</p></blockquote><p><a href="https://developer.apple.com/documentation/swiftui/picker" target="_blank">文档</a></p><h3 id="datepicker"><span id="datepicker">DatePicker</span><a href="#datepicker" title="DatePicker"></a></h3><p>选择日期的控件。</p><p>日期选择器样式也会根据其父视图进行更改，在表单或列表下作为一个列表行显示，点击可以扩展到日期选择器（就像日历 App 一样）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> selectedDate = <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dateClosedRange: <span class="type">ClosedRange</span>&lt;<span class="type">Date</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">min</span> = <span class="type">Calendar</span>.current.date(byAdding: .day, value: -<span class="number">1</span>, to: <span class="type">Date</span>())!</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">max</span> = <span class="type">Calendar</span>.current.date(byAdding: .day, value: <span class="number">1</span>, to: <span class="type">Date</span>())!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>...<span class="built_in">max</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">Form</span> &#123;</span><br><span class="line">        <span class="type">Section</span> &#123;</span><br><span class="line">            <span class="type">DatePicker</span>(</span><br><span class="line">                selection: $selectedDate,</span><br><span class="line">                <span class="keyword">in</span>: dateClosedRange,</span><br><span class="line">                displayedComponents: .date,</span><br><span class="line">                label: &#123; <span class="type">Text</span>(<span class="string">"Due Date"</span>) &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不在表单或列表里，它就可以作为普通的旋转选择器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> selectedDate = <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dateClosedRange: <span class="type">ClosedRange</span>&lt;<span class="type">Date</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">min</span> = <span class="type">Calendar</span>.current.date(byAdding: .day, value: -<span class="number">1</span>, to: <span class="type">Date</span>())!</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">max</span> = <span class="type">Calendar</span>.current.date(byAdding: .day, value: <span class="number">1</span>, to: <span class="type">Date</span>())!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>...<span class="built_in">max</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DatePicker</span>(</span><br><span class="line">    selection: $selectedDate,</span><br><span class="line">    <span class="keyword">in</span>: dateClosedRange,</span><br><span class="line">    displayedComponents: [.hourAndMinute, .date],</span><br><span class="line">    label: &#123; <span class="type">Text</span>(<span class="string">"Due Date"</span>) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果 <code>DatePicker</code> 的标签只有 <code>Text</code>，则可以用这样更简单的方式初始化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">"Due Date"</span>,</span><br><span class="line">            selection: $selectedDate,</span><br><span class="line">            <span class="keyword">in</span>: dateClosedRange,</span><br><span class="line">            displayedComponents: [.hourAndMinute, .date])</span><br></pre></td></tr></table></figure><p>可以使用 <a href="https://developer.apple.com/documentation/swift/closedrange" target="_blank"><code>ClosedRange</code></a>、<a href="https://developer.apple.com/documentation/swift/partialrangethrough" target="_blank"><code>PartialRangeThrough</code></a> 和 <a href="https://developer.apple.com/documentation/swift/partialrangefrom" target="_blank"><code>PartialRangeFrom</code></a> 来设置 <code>minimumDate</code> 和 <code>maximumDate</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">"Minimum Date"</span>,</span><br><span class="line">    selection: $selectedDate,</span><br><span class="line">    <span class="keyword">in</span>: <span class="type">Date</span>()...,</span><br><span class="line">    displayedComponents: [.date])</span><br><span class="line"><span class="type">DatePicker</span>(<span class="string">"Maximum Date"</span>,</span><br><span class="line">    selection: $selectedDate,</span><br><span class="line">    <span class="keyword">in</span>: ...<span class="type">Date</span>(),</span><br><span class="line">    displayedComponents: [.date])</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/datepicker" target="_blank">文档</a></p><h3 id="slider"><span id="slider">Slider</span><a href="#slider" title="Slider"></a></h3><p>从有界的线性范围中选择一个值的控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> progress: <span class="type">Float</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="type">Slider</span>(value: $progress, from: <span class="number">0.0</span>, through: <span class="number">100.0</span>, by: <span class="number">5.0</span>)</span><br></pre></td></tr></table></figure><p>Slider 虽然没有 <code>minimumValueImage</code> 和 <code>maximumValueImage</code> 属性， 但可以借助 <code>HStack</code>实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> progress: <span class="type">Float</span> = <span class="number">0</span></span><br><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">"sun.min"</span>)</span><br><span class="line">    <span class="type">Slider</span>(value: $progress, from: <span class="number">0.0</span>, through: <span class="number">100.0</span>, by: <span class="number">5.0</span>)</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">"sun.max.fill"</span>)</span><br><span class="line">&#125;.padding()</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/slider" target="_blank">文档</a></p><h3 id="stepper"><span id="stepper">Stepper</span><a href="#stepper" title="Stepper"></a></h3><p>用于执行语义上递增和递减动作的控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> quantity: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="type">Stepper</span>(value: $quantity, <span class="keyword">in</span>: <span class="number">0</span>...<span class="number">10</span>, label: &#123; <span class="type">Text</span>(<span class="string">"Quantity \(quantity)"</span>)&#125;)</span><br></pre></td></tr></table></figure><p>如果您的 <code>Stepper</code> 的标签只有 <code>Text</code>，则可以用这样更简单的方式初始化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stepper</span>(<span class="string">"Quantity \(quantity)"</span>, value: $quantity, <span class="keyword">in</span>: <span class="number">0</span>...<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>如果您要一个自己管理的数据源的控件，可以这样写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> quantity: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="type">Stepper</span>(onIncrement: &#123;</span><br><span class="line">    <span class="keyword">self</span>.quantity += <span class="number">1</span></span><br><span class="line">&#125;, onDecrement: &#123;</span><br><span class="line">    <span class="keyword">self</span>.quantity -= <span class="number">1</span></span><br><span class="line">&#125;, label: &#123; <span class="type">Text</span>(<span class="string">"Quantity \(quantity)"</span>) &#125;)</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/stepper" target="_blank">文档</a></p><h2 id="swiftui---页面布局与演示">SwiftUI - 页面布局与演示<a href="#swiftui---页面布局与演示" title="SwiftUI - 页面布局与演示"></a></h2><h3 id="hstack"><span id="hstack">HStack</span><a href="#hstack" title="HStack"></a></h3><p>水平排列子元素的视图。</p><p>创建一个水平排列的静态列表：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span> (alignment: .center, spacing: <span class="number">20</span>)&#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="type">Divider</span>()</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/hstack" target="_blank">文档</a></p><h3 id="vstack"><span id="vstack">VStack</span><a href="#vstack" title="VStack"></a></h3><p>垂直排列子元素的视图。</p><p>创建一个垂直排列的静态列表：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> (alignment: .center, spacing: <span class="number">20</span>)&#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="type">Divider</span>()</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/vstack" target="_blank">文档</a></p><h3 id="zstack"><span id="zstack">ZStack</span><a href="#zstack" title="ZStack"></a></h3><p>子元素会在 z轴方向上叠加，同时在垂直/水平轴上对齐的视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">        .padding(<span class="number">10</span>)</span><br><span class="line">        .background(<span class="type">Color</span>.red)</span><br><span class="line">        .opacity(<span class="number">0.8</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"World"</span>)</span><br><span class="line">        .padding(<span class="number">20</span>)</span><br><span class="line">        .background(<span class="type">Color</span>.red)</span><br><span class="line">        .offset(x: <span class="number">0</span>, y: <span class="number">40</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/zstack" target="_blank">文档</a></p><h3 id="list"><span id="list">List</span><a href="#list" title="List"></a></h3><p>用于显示排列一系列数据行的容器。</p><p>创建一个静态可滚动列表：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello world"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello world"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表单里的内容可以混搭：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello world"</span>)</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">"clock"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个动态列表：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"John"</span>, <span class="string">"Apple"</span>, <span class="string">"Seed"</span>]</span><br><span class="line"><span class="type">List</span>(names) &#123; name <span class="keyword">in</span></span><br><span class="line">    <span class="type">Text</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入分区：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"UIKit"</span>), footer: <span class="type">Text</span>(<span class="string">"We will miss you"</span>)) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"UITableView"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"SwiftUI"</span>), footer: <span class="type">Text</span>(<span class="string">"A lot to learn"</span>)) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"List"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使其成为分组列表，请添加 <code>.listStyle(GroupedListStyle())</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"UIKit"</span>), footer: <span class="type">Text</span>(<span class="string">"We will miss you"</span>)) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"UITableView"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"SwiftUI"</span>), footer: <span class="type">Text</span>(<span class="string">"A lot to learn"</span>)) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"List"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.listStyle(<span class="type">GroupedListStyle</span>())</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/list" target="_blank">文档</a></p><h3 id="scrollview"><span id="scrollview">ScrollView</span><a href="#scrollview" title="ScrollView"></a></h3><p>滚动视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollView</span>(alwaysBounceVertical: <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Image</span>(<span class="string">"foo"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/scrollview" target="_blank">文档</a></p><h3 id="form"><span id="form">Form</span><a href="#form" title="Form"></a></h3><p>对数据输入的控件进行分组的容器，例如在设置或检查器中。</p><p>您可以往表单中插入任何内容，它将为表单渲染适当的样式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">Form</span> &#123;</span><br><span class="line">        <span class="type">Section</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Plain Text"</span>)</span><br><span class="line">            <span class="type">Stepper</span>(value: $quantity, <span class="keyword">in</span>: <span class="number">0</span>...<span class="number">10</span>, label: &#123; <span class="type">Text</span>(<span class="string">"Quantity"</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Section</span> &#123;</span><br><span class="line">            <span class="type">DatePicker</span>($date, label: &#123; <span class="type">Text</span>(<span class="string">"Due Date"</span>) &#125;)</span><br><span class="line">            <span class="type">Picker</span>(selection: $selection, label:</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Picker Name"</span>)</span><br><span class="line">                , content: &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"Value 1"</span>).tag(<span class="number">0</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"Value 2"</span>).tag(<span class="number">1</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"Value 3"</span>).tag(<span class="number">2</span>)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"Value 4"</span>).tag(<span class="number">3</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/form" target="_blank">文档</a></p><h3 id="spacer"><span id="spacer">Spacer</span><a href="#spacer" title="Spacer"></a></h3><p>一块既能在包含栈布局时沿主轴伸展，也能在不包含栈时沿两个轴展开的灵活空间。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">"clock"</span>)</span><br><span class="line">    <span class="type">Spacer</span>()</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Time"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/spacer" target="_blank">文档</a></p><h3 id="divider"><span id="divider">Divider</span><a href="#divider" title="Divider"></a></h3><p>用于分隔其它内容的可视化元素。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">"clock"</span>)</span><br><span class="line">    <span class="type">Divider</span>()</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Time"</span>)</span><br><span class="line">&#125;.fixedSize()</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/divider" target="_blank">文档</a></p><h3 id="navigationview"><span id="navigationview">NavigationView</span><a href="#navigationview" title="NavigationView"></a></h3><p>用于渲染视图堆栈的视图，这些视图会展示导航层次结构中的可见路径。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;            </span><br><span class="line">    <span class="type">List</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationBarTitle(<span class="type">Text</span>(<span class="string">"Navigation Title"</span>)) <span class="comment">// 默认使用大标题样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于旧样式标题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;            </span><br><span class="line">    <span class="type">List</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationBarTitle(<span class="type">Text</span>(<span class="string">"Navigation Title"</span>), displayMode: .inline)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加 <code>UIBarButtonItem</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">List</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationBarItems(trailing:</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="comment">// Add action</span></span><br><span class="line">        &#125;, label: &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Add"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">    .navigationBarTitle(<span class="type">Text</span>(<span class="string">"Navigation Title"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <a href="#navigationlink">NavigationLink</a> 添加 <code>show</code>/<code>push</code> 功能。</p><p>作为 <code>UISplitViewController</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">List</span> &#123;</span><br><span class="line">        <span class="type">NavigationLink</span>(<span class="string">"Go to detail"</span>, destination: <span class="type">Text</span>(<span class="string">"New Detail"</span>))</span><br><span class="line">    &#125;.navigationBarTitle(<span class="string">"Master"</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Placeholder for Detail"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用两种新的样式属性：<code>stack</code> 和 <code>doubleColumn</code> 为 NavigationView 设置样式。默认情况下，iPhone 和 Apple TV 上的导航栏上显示导航堆栈，而在 iPad 和 Mac 上，显示的是拆分样式的导航视图。</p><p>您可以通过 <code>.navigationViewStyle</code> 重写样式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">MyMasterView</span>()</span><br><span class="line">    <span class="type">MyDetailView</span>()</span><br><span class="line">&#125;</span><br><span class="line">.navigationViewStyle(<span class="type">StackNavigationViewStyle</span>())</span><br></pre></td></tr></table></figure><p>在 beta 3中，<code>NavigationView</code> 支持拆分视图，但它仅支持非常基本的结构，其中主视图为列表，详细视图为叶视图，我期待在下一个 release 版本中能有优化补充。</p><p><a href="https://developer.apple.com/documentation/swiftui/navigationview" target="_blank">文档</a></p><h3 id="tabview"><span id="tabview">TabView</span><a href="#tabview" title="TabView"></a></h3><p>使用交互式用户界面元素在多个子视图之间切换的视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"First View"</span>)</span><br><span class="line">        .font(.title)</span><br><span class="line">        .tabItem(&#123; <span class="type">Text</span>(<span class="string">"First"</span>) &#125;)</span><br><span class="line">        .tag(<span class="number">0</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Second View"</span>)</span><br><span class="line">        .font(.title)</span><br><span class="line">        .tabItem(&#123; <span class="type">Text</span>(<span class="string">"Second"</span>) &#125;)</span><br><span class="line">        .tag(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签元素支持同时显示图像和文本， 您也可以使用 SF Symbols。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"First View"</span>)</span><br><span class="line">        .font(.title)</span><br><span class="line">        .tabItem(&#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"circle"</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"First"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .tag(<span class="number">0</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Second View"</span>)</span><br><span class="line">        .font(.title)</span><br><span class="line">        .tabItem(<span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(<span class="string">"second"</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Second"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .tag(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您也可以省略 <code>VStack</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"First View"</span>)</span><br><span class="line">        .font(.title)</span><br><span class="line">        .tabItem(&#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"circle"</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"First"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .tag(<span class="number">0</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Second View"</span>)</span><br><span class="line">        .font(.title)</span><br><span class="line">        .tabItem(&#123;</span><br><span class="line">            <span class="type">Image</span>(<span class="string">"second"</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Second"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .tag(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/tabview" target="_blank">文档</a></p><h3 id="alert"><span id="alert">Alert</span><a href="#alert" title="Alert"></a></h3><p>一个展示警告信息的容器。</p><p>我们可以根据布尔值显示 <code>Alert</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> isError: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Button</span>(<span class="string">"Alert"</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isError = <span class="literal">true</span></span><br><span class="line">&#125;.alert(isPresented: $isError, content: &#123;</span><br><span class="line">    <span class="type">Alert</span>(title: <span class="type">Text</span>(<span class="string">"Error"</span>), message: <span class="type">Text</span>(<span class="string">"Error Reason"</span>), dismissButton: .<span class="keyword">default</span>(<span class="type">Text</span>(<span class="string">"OK"</span>)))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它也可与 <code>Identifiable</code> 项目绑定。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> error: <span class="type">AlertError?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">"Alert Error"</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.error = <span class="type">AlertError</span>(reason: <span class="string">"Reason"</span>)</span><br><span class="line">    &#125;.alert(item: $error, content: &#123; error <span class="keyword">in</span></span><br><span class="line">        alert(reason: error.reason)</span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alert</span><span class="params">(reason: String)</span></span> -&gt; <span class="type">Alert</span> &#123;</span><br><span class="line">    <span class="type">Alert</span>(title: <span class="type">Text</span>(<span class="string">"Error"</span>),</span><br><span class="line">            message: <span class="type">Text</span>(reason),</span><br><span class="line">            dismissButton: .<span class="keyword">default</span>(<span class="type">Text</span>(<span class="string">"OK"</span>))</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlertError</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reason</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> reason: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/alert" target="_blank">文档</a></p><h3 id="modal"><span id="modal">Modal</span><a href="#modal" title="Modal"></a></h3><p>模态视图的存储类型。</p><p>我们可以根据布尔值显示 <code>Modal</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> isModal: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> modal: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Modal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span>(<span class="string">"Modal"</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isModal = <span class="literal">true</span></span><br><span class="line">&#125;.sheet(isPresented: $isModal, content: &#123;</span><br><span class="line">    <span class="keyword">self</span>.modal</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/view/3352791-sheet" target="_blank">文档</a></p><p>它也可与 <code>Identifiable</code> 项目绑定。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> detail: <span class="type">ModalDetail?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">"Modal"</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.detail = <span class="type">ModalDetail</span>(body: <span class="string">"Detail"</span>)</span><br><span class="line">    &#125;.sheet(item: $detail, content: &#123; detail <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.modal(detail: detail.body)</span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modal</span><span class="params">(detail: String)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(detail)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ModalDetail</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/view/3352792-sheet" target="_blank">文档</a></p><h3 id="actionsheet"><span id="actionsheet">ActionSheet</span><a href="#actionsheet" title="ActionSheet"></a></h3><p>操作表视图的存储类型。</p><p>我们可以根据布尔值显示 <code>ActionSheet</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> isSheet: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> actionSheet: <span class="type">ActionSheet</span> &#123;</span><br><span class="line">    <span class="type">ActionSheet</span>(title: <span class="type">Text</span>(<span class="string">"Action"</span>),</span><br><span class="line">                message: <span class="type">Text</span>(<span class="string">"Description"</span>),</span><br><span class="line">                buttons: [</span><br><span class="line">                    .<span class="keyword">default</span>(<span class="type">Text</span>(<span class="string">"OK"</span>), action: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;),</span><br><span class="line">                    .destructive(<span class="type">Text</span>(<span class="string">"Delete"</span>), action: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span>(<span class="string">"Action Sheet"</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isSheet = <span class="literal">true</span></span><br><span class="line">&#125;.actionSheet(isPresented: $isSheet, content: &#123;</span><br><span class="line">    <span class="keyword">self</span>.actionSheet</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它也可与 <code>Identifiable</code> 项目绑定。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">var</span> sheetDetail: <span class="type">SheetDetail?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">"Action Sheet"</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sheetDetail = <span class="type">ModSheetDetail</span>(body: <span class="string">"Detail"</span>)</span><br><span class="line">    &#125;.actionSheet(item: $sheetDetail, content: &#123; detail <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.sheet(detail: detail.body)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sheet</span><span class="params">(detail: String)</span></span> -&gt; <span class="type">ActionSheet</span> &#123;</span><br><span class="line">    <span class="type">ActionSheet</span>(title: <span class="type">Text</span>(<span class="string">"Action"</span>),</span><br><span class="line">                message: <span class="type">Text</span>(detail),</span><br><span class="line">                buttons: [</span><br><span class="line">                    .<span class="keyword">default</span>(<span class="type">Text</span>(<span class="string">"OK"</span>), action: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;),</span><br><span class="line">                    .destructive(<span class="type">Text</span>(<span class="string">"Delete"</span>), action: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SheetDetail</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/actionsheet" target="_blank">文档</a></p><h2 id="框架集成---swiftui-中的-uikit-1">框架集成 - SwiftUI 中的 UIKit<a href="#框架集成---swiftui-中的-uikit-1" title="框架集成 - SwiftUI 中的 UIKit"></a></h2><h3 id="uiviewrepresentable"><span id="uiviewrepresentable">UIViewRepresentable</span><a href="#uiviewrepresentable" title="UIViewRepresentable"></a></h3><p>表示 UIKit 视图的视图，当您想在 SwiftUI 中使用 UIView 时，请使用它。</p><p>要使任何 UIView 在 SwiftUI 中可用，请创建一个符合 UIViewRepresentable 的包装器视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ActivityIndicator</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> isAnimating: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: Context)</span></span> -&gt; <span class="type">UIActivityIndicatorView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> v = <span class="type">UIActivityIndicatorView</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="number">_</span> uiView: UIActivityIndicatorView, context: Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> isAnimating &#123;</span><br><span class="line">            uiView.startAnimating()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uiView.stopAnimating()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想要桥接 UIKit 里的数据绑定 (delegate, target/action) 就使用 <code>Coordinator</code>， 具体见 <a href="https://developer.apple.com/tutorials/swiftui/interfacing-with-uikit" target="_blank">SwiftUI 教程</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageControl</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfPages: <span class="type">Int</span></span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> currentPage: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: Context)</span></span> -&gt; <span class="type">UIPageControl</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> control = <span class="type">UIPageControl</span>()</span><br><span class="line">        control.numberOfPages = numberOfPages</span><br><span class="line">        control.addTarget(</span><br><span class="line">            context.coordinator,</span><br><span class="line">            action: #selector(<span class="type">Coordinator</span>.updateCurrentPage(sender:)),</span><br><span class="line">            <span class="keyword">for</span>: .valueChanged)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> control</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="number">_</span> uiView: UIPageControl, context: Context)</span></span> &#123;</span><br><span class="line">        uiView.currentPage = currentPage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeCoordinator</span><span class="params">()</span></span> -&gt; <span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="type">Coordinator</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is where old paradigm located</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> control: <span class="type">PageControl</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(<span class="number">_</span> control: <span class="type">PageControl</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.control = control</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">updateCurrentPage</span><span class="params">(sender: UIPageControl)</span></span> &#123;</span><br><span class="line">            control.currentPage = sender.currentPage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable" target="_blank">文档</a></p><h3 id="uiviewcontrollerrepresentable"><span id="uiviewcontrollerrepresentable">UIViewControllerRepresentable</span><a href="#uiviewcontrollerrepresentable" title="UIViewControllerRepresentable"></a></h3><p>表示 UIKit 视图控制器的视图。当您想在 SwiftUI 中使用 UIViewController 时，请使用它。</p><p>要使任何 UIViewController 在 SwiftUI 中可用，请创建一个符合 UIViewControllerRepresentable 的包装器视图，具体见 <a href="https://developer.apple.com/tutorials/swiftui/interfacing-with-uikit" target="_blank">SwiftUI 教程</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageViewController</span>: <span class="title">UIViewControllerRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> controllers: [<span class="type">UIViewController</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIViewController</span><span class="params">(context: Context)</span></span> -&gt; <span class="type">UIPageViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pageViewController = <span class="type">UIPageViewController</span>(</span><br><span class="line">            transitionStyle: .scroll,</span><br><span class="line">            navigationOrientation: .horizontal)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pageViewController</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIViewController</span><span class="params">(<span class="number">_</span> pageViewController: UIPageViewController, context: Context)</span></span> &#123;</span><br><span class="line">        pageViewController.setViewControllers(</span><br><span class="line">            [controllers[<span class="number">0</span>]], direction: .forward, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/uiviewcontrollerrepresentable" target="_blank">文档</a></p><h2 id="框架集成---uikit-中的-swiftui-1">框架集成 - UIKit 中的 SwiftUI<a href="#框架集成---uikit-中的-swiftui-1" title="框架集成 - UIKit 中的 SwiftUI"></a></h2><h3 id="uihostingcontroller"><span id="uihostingcontroller">UIHostingController</span><a href="#uihostingcontroller" title="UIHostingController"></a></h3><p>表示 SwiftUI 视图的 UIViewController。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vc = <span class="type">UIHostingController</span>(rootView: <span class="type">Text</span>(<span class="string">"Hello World"</span>))</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">UIHostingController</span>(rootView: <span class="type">ContentView</span>())</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/uihostingcontroller" target="_blank">文档</a></p><h2 id="来源">来源<a href="#来源" title="来源"></a></h2><ul><li><a href="https://developer.apple.com/documentation/swiftui/" target="_blank">API 文档</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/tutorials" target="_blank">官方教程</a></li><li><a href="https://developer.apple.com/videos/wwdc2019/" target="_blank">WWDC 2019</a><ul><li><a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank">介绍 SwiftUI: 创建您的第一个 App</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/216/" target="_blank">SwiftUI 基础</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/226/" target="_blank">SwiftUI 数据流</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/237/" target="_blank">使用 SwiftUI 构建自定义视图</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/231/" target="_blank">集成 SwiftUI</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/238/" target="_blank">SwiftUI 中的可访问性</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/240/" target="_blank">所有设备上的 SwiftUI</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/219/" target="_blank">watchOS 上的 SwiftUI</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/233/" target="_blank">掌握 Xcode 预览</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://fuckingswiftui.com/&quot; target=&quot;_blank&quot;&gt;Fucking Swift UI - Cheat Sheet&lt;/a&gt;&lt;br&gt;译者的话：翻译过程中，发现了原文中的几个错误，我向作者&lt;a href=&quot;https://twitter.com/sarunw&quot; target=&quot;_blank&quot;&gt;@sarunw&lt;/a&gt;提出意见后，直接在译文中改掉了，如果您发现文中内容有误，欢迎与我联系。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://blog.fiteen.top/categories/iOS/"/>
    
      <category term="翻译" scheme="https://blog.fiteen.top/categories/iOS/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="SwiftUI" scheme="https://blog.fiteen.top/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>如何提升 Flutter 项目的开发效率</title>
    <link href="https://blog.fiteen.top/2019/how-to-develop-flutter-projects-more-efficiently/"/>
    <id>https://blog.fiteen.top/2019/how-to-develop-flutter-projects-more-efficiently/</id>
    <published>2019-05-11T12:43:27.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近参与了一个 Flutter 项目的开发，总结了一些提升开发效率的工具和方法。</p><a id="more"></a><h2 id="ui-可视化工具">UI 可视化工具<a href="#ui-可视化工具" title="UI 可视化工具"></a></h2><p>纯客户端开发者一开始可能会对写 Flutter 的界面布局会不太适应，那么这个 <a href="https://flutterstudio.app" target="_blank">https://flutterstudio.app</a> 网站可以帮助你更快熟悉 Flutter 的常用组件，在这个工具上，你可以通过简单的拖拽直接实现布局。</p><p><img src="/2019/how-to-develop-flutter-projects-more-efficiently/flutterstudio.png" class="φcy" alt="flutterstudio 网站"></p><h2 id="代码模版">代码模版<a href="#代码模版" title="代码模版"></a></h2><p>我们发现在开发时，IDE 自带的代码快捷提示都不太丰富，比如要创建一个包含所有生命周期相关方法的完整的 StatefulWidget，如果能一键导入就能快速很多，这时候就可以借助代码模版。我事先在网上找到一份比较全面的模版，有需要的可以参考 <a href="https://github.com/AweiLoveAndroid/Flutter-learning/blob/master/code_plugins/no_new_keywords/dart.json" target="_blank">code plugins</a>，有时间我会按照自己习惯的风格再整理一份。</p><p>如果你使用的是 <strong>VSCode</strong>，打开路径：</p><blockquote><p>View → Command Palette… → 输入 &gt;Preferences: Configure User Snippets</p></blockquote><p><img src="/2019/how-to-develop-flutter-projects-more-efficiently/configure-user-snippets.png" class="φcy" alt="VSCode 上配置代码模版"></p><p>然后输入 <code>dart</code>，这时会打开一个 <code>dart.json</code> 文件，把上面的内容替换进来即可。</p><p>如果你使用的是 <strong>Android Studio</strong>，依次打开路径：</p><blockquote><p>Preferences → Editor → File and Code Templates</p></blockquote><p>在 <code>Files</code> 下找到 <code>Dart File</code>,将 json 文件里的内容粘贴进去即可。</p><p><img src="/2019/how-to-develop-flutter-projects-more-efficiently/file-and-code-templates.png" class="φcy" alt="Android Studio 上配置代码模版"></p><p>这样我们只需要输入简单的前缀就能直接联想出整个代码块了。 </p><h2 id="布局调试">布局调试<a href="#布局调试" title="布局调试"></a></h2><p>在实现 UI 模块的时候，经常会出现布局错乱的情况，VSCode 也为此提供了界面调试工具，在 Flutter App <strong>调试</strong>过程中，打开路径：</p><blockquote><p>View → Command Palette… → 输入 &gt;Flutter: Toggle Debug Painting</p></blockquote><p><img src="/2019/how-to-develop-flutter-projects-more-efficiently/toggle-debug-painting.png" class="φcy" alt="布局调试"></p><p>上面的辅助线可以帮助开发者检查布局。</p><blockquote><p>注意：通过 <code>flutter run</code> 方式启动的模拟器/真机是没法开启布局调试的。</p></blockquote><p>不过如果遇到难以定位的问题，建议还是使用 Androidio Studio 进行调试，它提供了下面这两个可视化工具：</p><p><a href="https://flutterchina.club/inspector/" target="_blank"><strong>Flutter Inspector</strong></a></p><ul><li>理解和查看现有布局</li><li>诊断布局的问题</li></ul><p><strong>Flutter Outline</strong></p><ul><li>视图预览</li><li>调整 widget</li></ul><p><img src="/2019/how-to-develop-flutter-projects-more-efficiently/flutter-outline-inspector.png" class="φcy" alt="Flutter Outline 和 Flutter Inspector"></p><h2 id="巧用快捷键">巧用快捷键<a href="#巧用快捷键" title="巧用快捷键"></a></h2><p>借助 IDE 中的快捷键也是我们提高开发效率的关键之一。以 Android Studio 为例：</p><ul><li>option+enter：对 widget 进行特定的操作</li></ul><p><img src="/2019/how-to-develop-flutter-projects-more-efficiently/option+enter.png" class="φcy" alt="快速修改布局"></p><ul><li><p>command+option+L：格式化代码，同时，也建议你在方法尾部尽量加逗号，这有助于自动格式化程序为 Flutter 样式代码插入适当的换行符</p></li><li><p>control+option+O：一键清除多余的 imports</p></li><li><p>……</p></li></ul><h2 id="常用插件">常用插件<a href="#常用插件" title="常用插件"></a></h2><p>常用的插件基本上都可以在<a href="https://pub.dartlang.org" target="_blank">Dart 开源包的网站</a>里找到，选用合适的 package 可以帮你节省不少重复实现的时间。网上的 Coder 朋友们也总结了很多不错的插件，本文里就不一一记录了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近参与了一个 Flutter 项目的开发，总结了一些提升开发效率的工具和方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="跨端" scheme="https://blog.fiteen.top/categories/%E8%B7%A8%E7%AB%AF/"/>
    
    
      <category term="Flutter" scheme="https://blog.fiteen.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>海外开发者账号上架总结</title>
    <link href="https://blog.fiteen.top/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/"/>
    <id>https://blog.fiteen.top/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/</id>
    <published>2019-02-17T17:59:18.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⚠️⚠️⚠️ <strong>声明：本文仅供技术交流，勿企图上架违法 App，否则后果自负，谢谢！</strong></p></blockquote><a id="more"></a><h2 id="背景">背景<a href="#背景" title="背景"></a></h2><p>众所周知，国内的 App 上架形势愈发严峻。尤其是金融、医疗、博彩类的 App，审核非常严格，只要开发者缺少相关资质，想通过正常流程上架基本不可能；游戏方面，新政策又要求游戏版号需要广电审批，向大批游戏公司泼了一盆冷水；随着苹果机审算法的优化，苹果爸爸可以不费人力轻松看穿你的马甲包；甚至一些不存在任何违反审核规则的应用，也有可能因为开发者账号是新号被审核人员怀疑。</p><p><img src="/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/four-major-tortures.png" class="φcy" alt="拒审四大酷刑"></p><p>相信不少开发者对上面的“四大酷刑”都不陌生，最怕苹果爸爸深夜邮件的关心，最怕上包率要写上 kpi。</p><p><img src="/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/low-kpi.png" class="φcy"></p><p>于是，为了很多开发者将目光抛向企业包，但是企业包成本来说比较高，根据企业签的稳定性，收费从每月几百到几千不等，遇到苹果封号密集的时期，甚至会出现每日掉签的情况。一个独立的企业签名，稳定周期基本也只能保持在2-3个月左右。因此企业包的方案仅适用于一些不受限于用户留存的 App，想要一款稳定运营的 App，依然需要上架 AppStore，下面介绍的就是使用海外开发者账号上架的方案。</p><h2 id="如何申请账号">如何申请账号<a href="#如何申请账号" title="如何申请账号"></a></h2><p>海外个人账号的申请方式和国内的大同小异：</p><ul><li>外国人身份证信息</li><li>国外地区的信用卡一张</li><li>国外的联系方式（手机号码）</li><li>海外邮箱（gmail、hotmail、Yeah等邮箱均可）</li></ul><p>申请时候记得挂海外 VPN，且在后续登录开发者中心时也是用这个 IP，频繁更换 IP 尤其是用国内的很容易被封。</p><p>如果没有渠道获得海外个人开发者的身份信息，可以直接找第三方（某宝）购买，大约1100元人民币，对方会告知你最近哪个地区的账号比较容易上架。</p><blockquote><p>注意：现在使用开发者账号都强制要求进行双重验证，用自己国内的手机号是没问题的。</p></blockquote><p>如果你的应用涉及到内购，需要关注一下账户所属国家。因为一些国家（美国，加拿大，澳大利亚）需要去税务局报税，没法用内购，其他国家是可以正常收款的。建议使用招行的储蓄卡，其次是建行的。满$150以后苹果就会汇款给你。</p><p>还有一个非常值得注意的问题——<strong>如何避免被封号</strong>：</p><ul><li>登录开发者账号时关闭你的 Mac/iPhone 上的 iCloud 功能和系统定位服务</li><li>使用海外区域的 VPN，勤换 IP</li><li>最好不要在同一台电脑，同一个IP登录多个开发者账号</li></ul><h2 id="app-设计">App 设计<a href="#app-设计" title="App 设计"></a></h2><h3 id="主题">主题<a href="#主题" title="主题"></a></h3><p>App 设计的方案很简单，就是“挂羊头卖狗肉”，你需要先设计一个对审核人员显示的壳，它要符合苹果爸爸心中“核心价值”的主题，尽量避讳直接表现一些敏感功能（如支付、教育、用户隐私权限等）。以下主题可供参考:</p><ul><li>记录类（记账（不太推荐，市面上用得比较多，容易被怀疑）、行程/心情/车票/电影票记录等）</li><li>提醒类（备忘录、提醒事项、番茄ToDo）</li><li>创意类（发挥你的 idea 做一些小工具之类）</li></ul><p>这些主题的特点就是可以做成单机类，但如果不得不涉及到网络请求数据，最好搞一台国外的服务器，不容易引起怀疑。</p><p>如果你的 App 不可避免地要涉及要一些权限，比如联网、推送、通讯录、麦克风、相册、相机、定位、运动与健身等，需要将权限自然地设计进去。</p><h3 id="ui">UI<a href="#ui" title="UI"></a></h3><p>相比于主题来说，UI 的优劣可能更能影响审核人员的判断。千万不要认为只是一个壳而粗制滥造，优美的视觉真的可以在很大程度上帮助你过审。</p><p><img src="/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/amazon-app.png" class="φcy" alt="亚马逊 App - 中美国版对比"></p><p>如上所示，海外 App 的风格和国内还是有比较大的差异，相对更简约，且海外 App 更看重动效的丰富性，如果你的 App 能令审核人员得到视觉上的愉悦感，就成功了一半。</p><h3 id="语言">语言<a href="#语言" title="语言"></a></h3><p>App 语言的选择需要得到重视，大部分情况下选择英文是没问题的，毕竟是全球通用的语言，但也要考虑上架地区的母语。我在第一次提审海外版 App 时就犯了一个错误，我将 App 语言设定为英文，为了避开中国审核，将面向上架地区时指定了墨西哥，结果收到了苹果的拒审邮件，他认定 App 违反了 Guideline 1.1.6，即存在虚假内容。为了不露馅，我通过找了在国外的朋友与苹果电话沟通，费了一番周折才确定原因在于“墨西哥的母语是西班牙语”。</p><p><img src="/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/mexico-speaks-spanish.png" class="φcy"></p><p>由于 App 上架后是要面向国内推广的，基本上都要做国际化（例如 App 名称、权限文案等），这一步建议在顺利过审2个版本后再加入。</p><h2 id="app-上架与迭代">App 上架与迭代<a href="#app-上架与迭代" title="App 上架与迭代"></a></h2><p>前面做的一切准备当然只是为了让我们想要的 App 上架，因为选择合适的时机做审核切换是非常关键的。假如你的 App 本身包体积比较大，千万不要在某一次迭代中一次性加入所有代码，容易引起审核人员的怀疑。在 App 稳定更新2～3次后（这里的稳定指的是审核速度较快，一次通过，未卡审），你可以在 App 中加入审核开关，这个开关可以在接口里检测 ip 所属地。但假如是单机类的壳，用网络请求来判断就会很明显，这里也推荐了一种方案——借助<strong>时间戳延迟打开开关</strong>。</p><p>根据前几次的审核经验，设定一个保险的时间节点，在那个时间点打开审核开关请求，尽量确保苹果在审核时候拦截不到任何可疑内容。同时为了防止苹果复审发现问题，可以再加一层判断，就是本地语言。因为国外工作人员的测试机基本上不会将中文设为默认语言，因此如下图所示，只要满足国内IP+默认中文两个条件的，才允许打开切换开关。</p><p><img src="/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/audit-switch.png" class="φcy"></p><hr><p>以上就是我海外版 App 上架的经验，欢迎给我 E-mail 留言交流，最后祝大家都过包顺利！</p><p><img src="/2019/how-to-use-an-overseas-developer-account-to-launch-an-ios-app/talisman.png" class="φcy"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;⚠️⚠️⚠️ &lt;strong&gt;声明：本文仅供技术交流，勿企图上架违法 App，否则后果自负，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://blog.fiteen.top/categories/iOS/"/>
    
    
      <category term="上架审核" scheme="https://blog.fiteen.top/tags/%E4%B8%8A%E6%9E%B6%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>『2018』勿忘初心</title>
    <link href="https://blog.fiteen.top/2018/annual-summary-2018/"/>
    <id>https://blog.fiteen.top/2018/annual-summary-2018/</id>
    <published>2018-12-31T18:01:19.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间飞逝，又到了写小作文的时候。2018 年用一个词语概括，就是“忙碌”。</p><a id="more"></a><h2 id="工作">工作<a href="#工作" title="工作"></a></h2><p>关键词——“尝试”。</p><p>受到整个金融大环境的影响，公司里的大量移动端产品（尤其是 iOS 端）遇到了上架难的问题，和公司里很多的iOSer 一样，开始转型大前端，参与Android、h5、小程序的产品开发。由于没有完整的学习周期来过渡，基本上都是被直接排期启动开发，这段时间的压力还是比较大。为了保证开发进度，只能通过模仿项目里原有的代码的风格和写法去进行快速迭代，期间一度出现“我能实现这个功能，但我不清楚为什么这么做”的情况，很没有成就感。不过经历了三四个月的适应和学习，也慢慢弄清楚各种技术的框架和逻辑，也能独立完成项目并解决一些棘手的遗留问题。</p><p>因为资质、监管的影响，产品的设计受到了极大的限制，团队也一直在找寻合适的方向。希望接下来的时间，我可以利用自己的专业为产品的进步提一些建设性的意见。</p><p>最近和领导聊了一写东西，他说公司有的时候更愿意招聘1-3年经验的开发，因为这些人脑子灵活，开发速度快，“性价比”高，能够被提拔，给予高薪的，一定不只是因为他能够开发。本身女性在行业里会处于劣势一些，曾经的同学、幼年的伙伴，很多也已经迈入婚姻和家庭。学无止尽，我希望自己对工作和生活的热爱还能持续下去，也相信能为自己创造一片天地。</p><h2 id="投资">投资<a href="#投资" title="投资"></a></h2><p>关键词——“惨烈”。</p><p>基金跌、股票跌、p2p暴雷，吃一堑、长一智。磨难让人成长，打不倒我们的才会令我们更强大！</p><h2 id="买房">买房<a href="#买房" title="买房"></a></h2><p>关键词——“迷茫”。</p><p>杭州的房价在 G20 前后开始呈现节节攀升的态势，虽然政府一再提出限价，还是抑不住房价放飞的趋势。今天杭州开始实行摇号买房政策，身边一些朋友，也在万人摇中分到一杯羹。不过我参与了好几个红盘的摇号，也并没有摇到，但其实有的红盘位置并不是我目前以及未来很长一段时间的生活和工作情况，回过头来想一想，我为什么要摇这个房子呢？不了解楼面价、容积率、得房率，甚至连样板房都没有看过，就登记报名了，仅仅为了所谓的差价，为了实现买房的目标，为了凑个热闹，看看自己运气好不好？也许也有很多人像我这样，也许这个社会就是这样，人性就是这样，模仿是人类的本能，但是我想我真的要知道自己是什么样，想要的到底是什么，自我认知是一辈子长久的修行，但愿我们都能修好这门课。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间飞逝，又到了写小作文的时候。2018 年用一个词语概括，就是“忙碌”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://blog.fiteen.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>手把手教你免费搭建 Shadowsocks 服务</title>
    <link href="https://blog.fiteen.top/2018/build-a-free-shadowsocks-service/"/>
    <id>https://blog.fiteen.top/2018/build-a-free-shadowsocks-service/</id>
    <published>2018-12-27T21:43:02.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、申请免费试用-gcp">一、申请免费试用 GCP<a href="#一、申请免费试用-gcp" title="一、申请免费试用 GCP"></a></h2><p>每位新注册的用户可以在谷歌云平台 <a href="https://cloud.google.com/free/" target="_blank">GCP</a> (Google Cloud Platform)获得第一年$300 的免费赠送额度。一年后若不主动选择继续使用不会扣费的。（如果谷歌云免费到期，你也可以通过<a href="https://aws.amazon.com/cn/" target="_blank">亚马逊AWS</a>再薅一年羊毛。）</p><a id="more"></a><p>注册账户的准备工作：</p><p>1、可用的 VPN，用于正常访问 GCP；</p><p>2、具有 VISA、MasterCard 等海外支付功能的信用卡一张；</p><p>有账户的可以直接登录，没有的就创建一个。</p><p><img src="/2018/build-a-free-shadowsocks-service/create-account.jpg" class="φcy" alt="创建账号"></p><p>如果阅读英文不习惯，可以将左下方的语言改成简体中文。登录成功后进入 <a href="https://console.cloud.google.com/freetrial" target="_blank">GCP 试用申请</a>：</p><p><strong>第1步 - 同意条款</strong>：注意选择国家/地区时避免选择“中国”，因为根据 Google Cloud 的政策，不支持中国使用，直接使用默认的“美国”即可。</p><p><img src="/2018/build-a-free-shadowsocks-service/apply-for-a-free-trial.jpg" class="φcy" alt="申请免费试用"></p><p><strong>第2步 - 填写客户信息和付款方式</strong></p><p>客户信息的账户类型选择“个人”，通过<a href="http://www.haoweichi.com/Index/random" target="_blank">虚拟美国人信息生成工具</a>，补充完成“姓名和地址”信息。</p><p><img src="/2018/build-a-free-shadowsocks-service/account-information.jpg" class="φcy" alt="客户信息"></p><p>填写付款方式时，务必填入<strong>正确真实</strong>的信用卡信息，不能再使用生成工具里的虚拟信息。可以取消“信用卡或借记卡账单邮寄地址与上述地址相同”的勾选，输入真实的地址。</p><p><img src="/2018/build-a-free-shadowsocks-service/payment-method.jpg" class="φcy" alt="付款方式"></p><p>申请成功会扣除$1，验证后将返回。至此，试用 GCP 免费申请完成。</p><h2 id="二、部署虚拟机">二、部署虚拟机<a href="#二、部署虚拟机" title="二、部署虚拟机"></a></h2><h3 id="1、修改防火墙">1、修改防火墙<a href="#1、修改防火墙" title="1、修改防火墙"></a></h3><p>在菜单中依次点击 【网络】 –&gt;【VPC 网络】 –&gt;<a href="https://console.cloud.google.com/networking/firewalls/list" target="_blank">【防火墙规则】</a>–&gt;【创建防火墙规则】，如下图创建一条入站规则：</p><p><img src="/2018/build-a-free-shadowsocks-service/firewall-rules.jpg" class="φcy" alt="防火墙规则"></p><p>注意点：</p><ul><li><p>目标：网络中的所有实例；如果选择指定标签，需要在后续的配置中输入标签</p></li><li><p>IP地址范围： 0.0.0.0/0</p></li><li><p>协议和端口：全部允许</p></li></ul><h3 id="2、保留静态地址">2、保留静态地址<a href="#2、保留静态地址" title="2、保留静态地址"></a></h3><p>在菜单中依次点击 【网络】 –&gt;【VPC 网络】 –&gt;<a href="https://console.cloud.google.com/networking/addresses/list" target="_blank">【外部 IP 地址】</a>–&gt;【保留静态 IP】</p><p><img src="/2018/build-a-free-shadowsocks-service/static-ip.jpg" class="φcy" alt="保留静态地址"></p><p>静态 IP 只能申请一个。区域可以选择亚洲东部、欧洲、美国等地，推荐使用 asia-east1，对应台湾地区，访问速度较快。</p><h3 id="3、创建计算引擎">3、创建计算引擎<a href="#3、创建计算引擎" title="3、创建计算引擎"></a></h3><p>在菜单中依次点击 【计算】 –&gt;【Compute Engine】 –&gt;<a href="https://console.cloud.google.com/networking/addresses/list" target="_blank">【VM 实例】</a>–&gt;【创建实例】</p><p><img src="/2018/build-a-free-shadowsocks-service/create-instance.jpg" class="φcy" alt="创建实例"></p><p>注意点：</p><ul><li><p>区域：与创建静态地址时一致</p></li><li><p>机器类型：最便宜的“微型”即可</p></li><li><p>启动磁盘：Ubuntu 16.04 LTS Minimal</p></li></ul><p>展开“管理、安全、磁盘、网络、单独租用”，外部 IP 选择第2步的静态 IP。到这里，虚拟机部署完成。</p><p><img src="/2018/build-a-free-shadowsocks-service/vm-instance.jpg" class="φcy" alt="VM 实例"></p><h2 id="三、搭建-ssr--bbr">三、搭建 SSR + BBR<a href="#三、搭建-ssr--bbr" title="三、搭建 SSR + BBR"></a></h2><p>在 VM 实例列表中找到刚才创建好的实例，点击上图红框内的 SSH，会弹出终端，如下图所示。如果用的是谷歌浏览器可以使用 <a href="https://chrome.google.com/webstore/detail/ssh-for-google-cloud-plat/ojilllmhjhibplnppnamldakhpmdnibd" target="_blank">SSH 插件</a></p><p><img src="/2018/build-a-free-shadowsocks-service/ssh.jpg" class="φcy" alt="SSH"></p><ul><li>获得 root 权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure><ul><li>检查内核版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname –sr</span><br></pre></td></tr></table></figure><p>正常情况下，当前的内核版本都是超过 4.9，无需升级，可以直接进入下一步；如果需要升级，按照以下步骤进行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 更新系统</span><br><span class="line">apt update</span><br><span class="line">apt upgrade</span><br><span class="line">// 安装指定的新内核</span><br><span class="line">apt install linux-image-4.10.0-20</span><br><span class="line">// 卸载旧内核</span><br><span class="line">apt autoremove</span><br><span class="line">// 启用新内核</span><br><span class="line">update-grub</span><br><span class="line">// 重启</span><br><span class="line">reboot</span><br><span class="line">// 获得 root 权限</span><br><span class="line">sudo -i</span><br><span class="line">// 验证内核版本</span><br><span class="line">uname –r</span><br></pre></td></tr></table></figure><ul><li>写入配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc&#x3D;fq&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control&#x3D;bbr&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><ul><li>配置生效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><ul><li>检验是否开启成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>如果看到回显<code>tcp_bbr 20480</code>说明已经成功开启 BBR。</p><h2 id="四、搭建-shadowsocks-server">四、搭建 Shadowsocks Server<a href="#四、搭建-shadowsocks-server" title="四、搭建 Shadowsocks Server"></a></h2><ul><li>更新 apt-get 软件包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><ul><li>通过 apt-get 安装 python-pip</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><ul><li>使用 pip 安装 shadowsocks 服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure><p>如果出现类似 <code>Successfullying installed shadowsocks - x.x.x</code>的提示说明安装成功。</p><ul><li>创建 Shadowsocks Server 配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ss-conf.json</span><br></pre></td></tr></table></figure><p>回车之后会进入这个创建的文件，windows 下点击键盘上的 insert 键进入编辑，mac 系统则随便输入一个字母可以进入编辑。输入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">&quot;server_port&quot;:8838,</span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">&quot;local_port&quot;:1080,</span><br><span class="line">&quot;password&quot;:&quot;fiteen&quot;,</span><br><span class="line">&quot;timeout&quot;:600,</span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; server_port 与 password 分别对应 Shadowsocks 客户端上配置使用的端口和密码，内容请自定义</span><br></pre></td></tr></table></figure><p>点击 ESC 键，左下角的 insert 标志消失，同时按下”shift” 和”:”键，左下角出现”:” 标志，输入”wq”，接着回车即保存退出文件。</p><ul><li>用配置文件启动 Shadowsocks Server</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -c /etc/ss-conf.json -d start</span><br></pre></td></tr></table></figure><p>如果要设置开机启动，可以参考这篇<a href="https://my.oschina.net/oncereply/blog/467349" target="_blank">文章</a>。</p><p>服务搭建已经完成了，在 <a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank">SSR（Mac 端）</a>上输入上面配置的内容，确定后开启服务便可以科学上网了。</p><p><img src="/2018/build-a-free-shadowsocks-service/server-settings.png" class="φcy" alt="服务器设定"></p><p>如果你的 iPhone 客户端也需要下载小火箭，可以用美区账号 App Store 购买/ TB 购买礼品卡，如果不想花钱，可以尝试一下<a href="https://github.com/v2ss/shadowrocket" target="_blank">这个方案</a>。（2019-12-31 更新）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、申请免费试用-gcp&quot;&gt;一、申请免费试用 GCP&lt;a href=&quot;#一、申请免费试用-gcp&quot; title=&quot;一、申请免费试用 GCP&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;每位新注册的用户可以在谷歌云平台 &lt;a href=&quot;https://cloud.google.com/free/&quot; target=&quot;_blank&quot;&gt;GCP&lt;/a&gt; (Google Cloud Platform)获得第一年$300 的免费赠送额度。一年后若不主动选择继续使用不会扣费的。（如果谷歌云免费到期，你也可以通过&lt;a href=&quot;https://aws.amazon.com/cn/&quot; target=&quot;_blank&quot;&gt;亚马逊AWS&lt;/a&gt;再薅一年羊毛。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="科学上网" scheme="https://blog.fiteen.top/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="Shadowsocks" scheme="https://blog.fiteen.top/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Git 手册之 Mac 上给 Git 设置 SOCKS5/HTTP 代理</title>
    <link href="https://blog.fiteen.top/2018/set-up-sock5-or-http-proxy-for-git-on-mac/"/>
    <id>https://blog.fiteen.top/2018/set-up-sock5-or-http-proxy-for-git-on-mac/</id>
    <published>2018-09-02T18:59:02.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们常会遇到从 GitHub 上 clone 代码的时候龟速的情况，这时如果手上有不错的代理，可以借助代理来获取更快下载/上传资源的速度。</p><a id="more"></a><p>通常我们 clone 代码时有以下两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTTPS 方式</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;accountname&#x2F;projectname.git</span><br><span class="line">&#x2F;&#x2F; SSH 方式</span><br><span class="line">git@github.com:accountname&#x2F;projectname.git</span><br></pre></td></tr></table></figure><h2 id="设置-http-方式的代理">设置 HTTP 方式的代理<a href="#设置-http-方式的代理" title="设置 HTTP 方式的代理"></a></h2><p>由于 Shadowsocks 客户端就提供一个本地的 SOCKS5 代理，代理地址是 127.0.0.1:1080。在终端输入以下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">"socks5://127.0.0.1:1080"</span></span><br><span class="line">git config --global https.proxy <span class="string">"socks5://127.0.0.1:1080"</span></span><br></pre></td></tr></table></figure><p>取消代理则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>也可以直接修改用户主目录下的  <code>.gitconfig</code> 文件，插入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">        proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">[https]</span><br><span class="line">        proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>如果你用的不是 SOCKS5，而是 HTTP 代理，就把上面命令中的 <code>socks5</code> 换成 <code>http</code> ，同时改成正确的端口号。</p><h2 id="设置-ssh-方式的代理">设置 SSH 方式的代理<a href="#设置-ssh-方式的代理" title="设置 SSH 方式的代理"></a></h2><p>修改用户目录下文件  <code>~/.ssh/config</code> 里的内容，对 GitHub 域名作单独处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    # 若使用的是默认端口，设置如下</span><br><span class="line">    HostName           github.com</span><br><span class="line">    # 如果想用443端口，设置如下</span><br><span class="line">    # Hostname         ssh.github.com</span><br><span class="line">    # Port             443</span><br><span class="line">    User               git</span><br><span class="line">    # 如果是 SOCKS5 代理，取消下面这行注释，并把 1080 改成自己 SOCKS5 代理的端口</span><br><span class="line">    # ProxyCommand     nc -x localhost:1080 %h %p</span><br><span class="line">    # 如果是 HTTP 代理，取消下面这行注释，并把 6666 改成自己 HTTP 代理的端口</span><br><span class="line">    # ProxyCommand     socat - PROXY:127.0.0.1:%h:%p,proxyport&#x3D;6666</span><br></pre></td></tr></table></figure><h2 id="直接在终端设置临时代理">直接在终端设置临时代理<a href="#直接在终端设置临时代理" title="直接在终端设置临时代理"></a></h2><p>或者我们可以在 <code>~/.bashrc</code>文件中，直接写入以下内容并保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias setproxy&#x3D;&quot;export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">alias unsetproxy&#x3D;&quot;unset ALL_PROXY&quot;</span><br><span class="line">alias ip&#x3D;&quot;curl -i http:&#x2F;&#x2F;ip.cn&quot;</span><br></pre></td></tr></table></figure><p>clone 之前先在终端执行  <code>setproxy</code> 命令，结束后执行  <code>unsetproxy</code> 命令如果终端提示 <code>command not found: setproxy</code>，说明配置没有生效，执行一下  <code>source ~/.bashrc</code> 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常会遇到从 GitHub 上 clone 代码的时候龟速的情况，这时如果手上有不错的代理，可以借助代理来获取更快下载/上传资源的速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://blog.fiteen.top/categories/Git/"/>
    
    
      <category term="SOCKS5" scheme="https://blog.fiteen.top/tags/SOCKS5/"/>
    
      <category term="HTTP" scheme="https://blog.fiteen.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>借助 Safari 调试苹果手机上的 webView</title>
    <link href="https://blog.fiteen.top/2018/debug-webview-with-safari/"/>
    <id>https://blog.fiteen.top/2018/debug-webview-with-safari/</id>
    <published>2018-07-25T15:21:07.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iphone-真机模拟器设置">iPhone 真机/模拟器设置<a href="#iphone-真机模拟器设置" title="iPhone 真机/模拟器设置"></a></h2><p>需要如下图所示，点击“设置” → 点击 “Safari 浏览器” → 点击“高级” → 打开“Web 检查器”。</p><a id="more"></a><p><img src="/2018/debug-webview-with-safari/open-the-web-inspector.jpg" class="φcy" alt="打开 Web 检查器"></p><p>若模拟器中无“Web 检查器”选项，无需设置。</p><h2 id="safari-设置">Safari 设置<a href="#safari-设置" title="Safari 设置"></a></h2><p>打开 Mac 电脑中的 Safari 浏览器，打开偏好设置，点击菜单中的“高级”选项卡，勾选“在菜单栏中显示“开发”菜单”</p><p><img src="/2018/debug-webview-with-safari/safari-perferences-advanced.jpg" class="φcy" alt="Safari-偏好设置-高级"></p><h2 id="进入检查器">进入检查器<a href="#进入检查器" title="进入检查器"></a></h2><p>在手机/模拟器中打开浏览器/App中的某个网页，在 Mac 中打开 Safari，在“开发”中找到目标设备。</p><p><img src="/2018/debug-webview-with-safari/select-target-device.jpg" class="φcy" alt="选择目标设备"></p><blockquote><p>如果你选择的是模拟器，但是开发列表中未出现，重启 Safari 即可。因为必须确保先打开模拟器，再打开 Safari。</p></blockquote><p>点击目标设备中需要查看的网址，便会弹出这个页面对应的检查器。</p><p><img src="/2018/debug-webview-with-safari/web-inspector.jpg" class="φcy" alt="网页检查器"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;iphone-真机模拟器设置&quot;&gt;iPhone 真机/模拟器设置&lt;a href=&quot;#iphone-真机模拟器设置&quot; title=&quot;iPhone 真机/模拟器设置&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;需要如下图所示，点击“设置” → 点击 “Safari 浏览器” → 点击“高级” → 打开“Web 检查器”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://blog.fiteen.top/categories/iOS/"/>
    
    
      <category term="webView" scheme="https://blog.fiteen.top/tags/webView/"/>
    
  </entry>
  
  <entry>
    <title>App Store 审核经验</title>
    <link href="https://blog.fiteen.top/2018/review-experience/"/>
    <id>https://blog.fiteen.top/2018/review-experience/</id>
    <published>2018-06-14T15:56:22.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关资料">相关资料<a href="#相关资料" title="相关资料"></a></h2><h3 id="审核指南">审核指南<a href="#审核指南" title="审核指南"></a></h3><ul><li><a href="https://developer.apple.com/cn/app-store/review/guidelines/" target="_blank">《App Store 审核指南》</a></li><li><a href="https://developer.apple.com/terms/" target="_blank">《苹果开发者计划许可协议》</a></li></ul><a id="more"></a><p>苹果官方会不定期更新 Guidelines 和 PLA，请及时关注。</p><h3 id="关键概念">关键概念<a href="#关键概念" title="关键概念"></a></h3><ul><li><p><a href="https://developer.apple.com/support/itunes-connect/cn/" target="_blank">iTunes Connect</a></p><p>iTunes Connect 是一套以网页为基础的工具，用于管理在 App Store 上销售的面向 iPhone、iPad、Mac、Apple Watch、Apple TV 和 iMessage 的 app；同时也用于管理 iTunes Store 和 iBooks Store 上的内容。开发者通过 iTunes Connect 提交和管理 app，邀请用户使用 TestFlight 进行测试，添加税务和银行信息，以及访问销售报告等。</p></li><li><p>元数据</p><p>元数据指的是 iTunes Connect 中输入的 App 信息和平台版本信息——例如，App 名称、描述、关键词和屏幕快照。此信息的部分显示在 App Store 产品页面，并且可以被本地化。</p></li><li><p>二进制文件</p><p>包含在 ipa 包中的一个可执行文件，提审时需重点检查包括但不限于 info.plist、包／文件大小、icon 规格、私有 API、第三方 SDK、64位等内容。</p></li></ul><h3 id="审核状态">审核状态<a href="#审核状态" title="审核状态"></a></h3><p>开发者在审核过程中需要特别关注的两个<a href="https://help.apple.com/itunes-connect/developer/?lang=zh-cn#/dev18557d60e" target="_blank">App 状态</a>为：</p><ul><li><p>正在等待审核（Waiting For Review）</p><p>您已经提交了一个新的 App 或者更新了一个版本。Apple 已经收到了您的 App 但还没有开始审核。在该状态下可以：</p><ul><li><a href="https://help.apple.com/itunes-connect/developer/?lang=zh-cn#/dev04f55d711" target="_blank">将构建版本从审核中移除</a></li><li>编辑某些 <a href="https://help.apple.com/itunes-connect/developer/?lang=zh-cn#/dev219b53a88" target="_blank">App 信息</a></li></ul></li><li><p>正在审核（In Review）</p><p>Apple 正在审核您的 App。您可以<a href="https://help.apple.com/itunes-connect/developer/?lang=zh-cn#/dev04f55d711" target="_blank">将构建版本从审核中移除</a>。</p></li></ul><p>一般这两个过程都会在24-48小时内完成，即从你提交到审核完成正常应在2天内结束，App 首次提交除外。</p><p>当 App 被拒超过三次，“正在等待审核”过程会延长，极有可能持续一周；若未按照苹果的要求操作，可能被拉入黑名单，“正在审核”过程无限延长。</p><h2 id="近期被拒案例及应对措施">近期被拒案例及应对措施<a href="#近期被拒案例及应对措施" title="近期被拒案例及应对措施"></a></h2><h3 id="账号资质问题">账号资质问题<a href="#账号资质问题" title="账号资质问题"></a></h3><p>对于监管敏感的行业和应用，App Store 的审核会更为苛刻。这类案例主要体现在理财、借贷、医疗类的 App，相关的应对方法有：</p><ol><li><p>证明你的公司，有提供相关资质。</p><p>如果 App 的公司主体具备资质，直接讲资质证明（如营业执照、政府背书）发给苹果审核团队；若不具备，需要将 App 放在有资质的公司主体的账号下提交。</p><p>如果苹果审核团队方面对 App 的性质存在误解，提供相关证明并及时沟通。</p></li><li><p>如果是个人开发者账号提交的应用，须升级为企业开发者账号后再提交。</p></li><li><p>如果是其他开发者账号（比如外包）替你开发，须将其他开发账号添加到你的苹果开发者账号下（在“用户和职能-添加iTunes Connect用户”操作）。</p></li><li><p>尽可能体现 App 产品与公司品牌的关联性，包括但不限于以下几点：</p><ul><li>App 名称的择定</li><li>在 App 的“关于我们”中，中英文介绍公司</li><li>提交“软件著作权登记证书”，或者“商标证书”</li><li>向苹果审核团队阐述 App 功能的运营主体、技术支持网站等</li></ul></li><li><p>设置开关，将敏感内容在审核期间隐藏，审核过后再显示。但近期苹果已经发现这一现象，会不定期抽查过审应用。这种做法也有被竞争对手举报的可能，一旦被查到可能面临被直接下架的风险。</p></li></ol><h3 id="元数据不规范">元数据不规范<a href="#元数据不规范" title="元数据不规范"></a></h3><p>2018年伊始，苹果爸爸就抛出了重磅炸弹——苹果2.1狗年大礼包。我们需要对照<a href="https://help.apple.com/itc/appsspec/#/" target="_blank">元数据规范</a>对本地信息进行修改和调整。</p><p>如果不需要更新 ipa 包，可以直接在被拒信息下面回复，明确告知对方：App 不存在这些问题或者我们已经对相关资源和功能作出了调整，请重新审核。切勿不沟通，直接重新提包，会被苹果认定默认存在大礼包中提及的问题。</p><p>iTC 中在上传屏幕快照时，以 5.5 寸为基准，条件允许时，为不同机型定制不同的屏幕快照更佳。</p><h3 id="内购">内购<a href="#内购" title="内购"></a></h3><p>订阅、游戏内货币、游戏关卡、课程、会员等非实物交换类的虚拟物品，必须且只允许走内购渠道。此外，需要注意以下几点：</p><ul><li>支付页面不能使用网页作为载体，苹果会认为存在变更支付方式的可能</li><li>类别（如消耗型/非消耗性、自动续订/非续订）需要选择正确</li><li>提高产品审核通过率，iTC 中信息尽可能补充完整</li></ul><h3 id="隐私">隐私<a href="#隐私" title="隐私"></a></h3><p>在 Apple 生态体系中，保护用户隐私总是第一要务。当需要访问用户的相册、相机、通讯录、位置、日历等，App 描述中应当注明 app 会要求访问哪些内容类型 (例如，位置、通讯录和日历等)，并说明当用户不授予许可时，app 的哪些功能会无法正常工作。</p><h2 id="如何提高过审速度">如何提高过审速度<a href="#如何提高过审速度" title="如何提高过审速度"></a></h2><h3 id="沟通原则">沟通原则<a href="#沟通原则" title="沟通原则"></a></h3><ul><li><p>尊重</p><p>回复时称对方为审核员，沟通过程中保持严肃、友好、认同的态度，对给出任何审核结果表示感谢。</p></li><li><p>积极</p><p>及时主动告知审核员我方的处理进度。中英文表达皆可，面对积极回复且礼貌的开发者，审核人员更愿意给出直接的意见。</p></li></ul><h3 id="以往经验">以往经验<a href="#以往经验" title="以往经验"></a></h3><ul><li>In Review 状态不要手动撤回，可能会导致后续审核速度变慢。</li><li>对被拒原因不认可，可以直接在被拒消息后申诉。即使回复后直接重新提交新版本，审核员也会看到消息，可以在消息中告知，已经按照要求进行修改，这种情况下苹果的处理效率会高一些。</li><li>处理当前的审核结果一般是同一个审核员，提审后及时查看审核状态，一旦被拒及时回复，可以得到尽可能快对回应和处理。</li><li>提审之前，请先反复检查，避免低级问题或常见问题遗漏到苹果审核人员手中。若连续审核通过，后续审核速度会越来越快，反之，若连续被拒极有可能进入黑名单，审核速度越来越慢。</li><li>遇到竞争对手侵权可以向苹果投诉，但不要多人重复投诉，不然可能会拉长处理时间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;相关资料&quot;&gt;相关资料&lt;a href=&quot;#相关资料&quot; title=&quot;相关资料&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;审核指南&quot;&gt;审核指南&lt;a href=&quot;#审核指南&quot; title=&quot;审核指南&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/cn/app-store/review/guidelines/&quot; target=&quot;_blank&quot;&gt;《App Store 审核指南》&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/terms/&quot; target=&quot;_blank&quot;&gt;《苹果开发者计划许可协议》&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://blog.fiteen.top/categories/iOS/"/>
    
    
      <category term="上架审核" scheme="https://blog.fiteen.top/tags/%E4%B8%8A%E6%9E%B6%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下避免 rm 引发的血案</title>
    <link href="https://blog.fiteen.top/2018/avoid-rm-induced-bloody-cases/"/>
    <id>https://blog.fiteen.top/2018/avoid-rm-induced-bloody-cases/</id>
    <published>2018-04-12T21:53:11.000Z</published>
    <updated>2020-02-23T08:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>习惯使用终端的用户，常会用 <code>rm -fr</code> 命令执行删除操作，但是这种删除的方式不会出现在废纸篓中，一旦误删，要想找回就比较麻烦。近期听说的此类血案也比较多，为了避免造成悲剧，推荐使用 trash 命令来执行删除。</p><a id="more"></a><h2 id="安装-trash">安装 trash<a href="#安装-trash" title="安装 trash"></a></h2><p>通过 Homebrew 安装 <a href="https://github.com/ali-rantakari/trash" target="_blank">Trash</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install trash</span><br></pre></td></tr></table></figure><p>安装成功后，可以通过 <code>trash -fr filename</code>命令删除文件，且文件会移到废纸篓中。</p><h2 id="用-trash-替换-rm-命令">用 trash 替换 rm 命令<a href="#用-trash-替换-rm-命令" title="用 trash 替换 rm 命令"></a></h2><p>打开 ~/.bash_profile 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>在文件中加入以下代码后保存文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias rm&#x3D;&quot;trash&quot;</span><br></pre></td></tr></table></figure><p>使命令生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>这时执行 rm 命令，被删除的文件就会存放在废纸篓中了，废纸篓里的文件虽无法执行“放回原处”的方法，但可以通过鼠标拖拽恢复。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;习惯使用终端的用户，常会用 &lt;code&gt;rm -fr&lt;/code&gt; 命令执行删除操作，但是这种删除的方式不会出现在废纸篓中，一旦误删，要想找回就比较麻烦。近期听说的此类血案也比较多，为了避免造成悲剧，推荐使用 trash 命令来执行删除。&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序员必备" scheme="https://blog.fiteen.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87/"/>
    
    
      <category term="rm" scheme="https://blog.fiteen.top/tags/rm/"/>
    
  </entry>
  
</feed>
